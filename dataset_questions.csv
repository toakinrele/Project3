question_id,title,body
875467,Java client certificates over HTTPS/SSL,"I am using Java 6 and am trying to create an HttpsURLConnection against a remote server, using a client certificate.
The server is using an selfsigned root certificate, and requires that a password-protected client certificate is presented. I've added the server root certificate and the client certificate to a default java keystore which I found in /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/security/cacerts (OSX 10.5).
The name of the keystore file seems to suggest that the client certificate is not supposed to go in there?
Anyway, adding the root certificate to this store solved the infamous javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed' problem.
However, I'm now stuck on how to use the client certificate. I've tried two approaches and neither gets me anywhere.
First, and preferred, try:
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
URL url = new URL(""https://somehost.dk:3049"");
HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();
conn.setSSLSocketFactory(sslsocketfactory);
InputStream inputstream = conn.getInputStream();
// The last line fails, and gives:
// javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure

I've tried skipping the HttpsURLConnection class (not ideal since I want to talk HTTP with the server), and do this instead:
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(""somehost.dk"", 3049);
InputStream inputstream = sslsocket.getInputStream();
// do anything with the inputstream results in:
// java.net.SocketTimeoutException: Read timed out

I am not even sure that the client certificate is the problem here.
"
1638275,Handling an invalid security certificate using MATLAB&#39;s urlread command,"I'm accessing an internal database using MATLAB's urlread command, everything was working fine until the service was moved to a secure server (i.e. with an HTTPS address rather than an HTTP address). Now urlread no longer successfully retrieves results. It gives an error:

Error downloading URL. Your network connection may be down or your proxy settings improperly configured.

I believe the problem is that the service is using an invalid digital certificate since if I try to access the resource directly in a web browser I get ""untrusted connection"" warning which I am able to pass through by adding the site to an Exception list. urlread doesn't have an obvious way of handling this problem.
Under the hood urlread is using Java to access web resources, and the error is thrown at this line:
inputStream = urlConnection.getInputStream;

where urlConnection is a Java object: sun.net.www.protocol.https.HttpsURLConnectionImpl.
Anyone suggest a workaround for this problem?    
"
3508050,How can I get a list of trusted root certificates in Java?,"I would like to be able to get access to all trusted root certificates programmatically in a Java app.  
I was looking at the keystore interface, but I'm hoping to get the list of trusted roots that's implicit with the JRE.
Is this accessible anywhere?
"
304268,Getting a File&#39;s MD5 Checksum in Java,"I am looking to use Java to get the MD5 checksum of a file.  I was really surprised but I haven't been able to find anything that shows how to get the MD5 checksum of a file.
How is it done?
"
4687615,how to achieve transfer file between client and server using java socket,"I have implement the simple TCP server and TCP client classes which can send the message from client to server and the message will be converted to upper case on the server side, but how can I achieve transfer files from server to client and upload files from client to server. the following codes are what I have got.
TCPClient.java   
        import java.io.*;
        import java.net.*;
        import java.util.Scanner;

 class TCPClient {

public static void main(String args[]) throws Exception {
        int filesize=6022386;
        int bytesRead;
        int current = 0;
    String ipAdd="""";
    int portNum=0;
    boolean goes=false;
    if(goes==false){
    System.out.println(""please input the ip address of the file server"");
    Scanner scan=new Scanner(System.in);
    ipAdd=scan.nextLine();
    System.out.println(""please input the port number of the file server"");
    Scanner scan1=new Scanner(System.in);
    portNum=scan1.nextInt();
    goes=true;
    }
    System.out.println(""input done"");
    int timeCount=1;
    while(goes==true){
    //System.out.println(""connection establishing"");

    String sentence="""";
    String modifiedSentence;

    BufferedReader inFromUser = new BufferedReader(new InputStreamReader(
            System.in));

    Socket clientSocket = new Socket(ipAdd, portNum);
    //System.out.println(""connecting"");
    //System.out.println(timeCount);
    if(timeCount==1){
    sentence=""set"";
    //System.out.println(sentence);


    }
    if(timeCount!=1)
        sentence = inFromUser.readLine();
            if(sentence.equals(""close""))
                clientSocket.close();
            if(sentence.equals(""download""))
            {
                byte [] mybytearray  = new byte [filesize];
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                bytesRead = is.read(mybytearray,0,mybytearray.length);
                current = bytesRead;
                do {
   bytesRead =
      is.read(mybytearray, current, (mybytearray.length-current));
   if(bytesRead >= 0) current += bytesRead;
} while(bytesRead > -1);

bos.write(mybytearray, 0 , current);
bos.flush();
long end = System.currentTimeMillis();
//System.out.println(end-start);
bos.close();
clientSocket.close();
            }
           // if(sentence.equals(""send""))
               // clientSocket.
    timeCount--;
    //System.out.println(""connecting1"");
    DataOutputStream outToServer = new DataOutputStream(clientSocket
            .getOutputStream());

    BufferedReader inFromServer = new BufferedReader(new InputStreamReader(
            clientSocket.getInputStream()));


    //System.out.println(""connecting2"");
    //System.out.println(sentence);
    outToServer.writeBytes(sentence + ""\n"");

    modifiedSentence = inFromServer.readLine();

    System.out.println(""FROM SERVER:"" + modifiedSentence);

    clientSocket.close();

}
}

}

TCPServer.java
          import java.io.*;
       import java.net.*;

     class TCPServer {
public static void main(String args[]) throws Exception {

    Socket s = null;

    int firsttime=1;


    while (true) {
        String clientSentence;
    String capitalizedSentence="""";

        ServerSocket welcomeSocket = new ServerSocket(3248);
        Socket connectionSocket = welcomeSocket.accept();

             //Socket sock = welcomeSocket.accept();


        BufferedReader inFromClient = new BufferedReader(
                new InputStreamReader(connectionSocket.getInputStream()));

        DataOutputStream outToClient = new DataOutputStream(
                connectionSocket.getOutputStream());

        clientSentence = inFromClient.readLine();
        //System.out.println(clientSentence);
                    if(clientSentence.equals(""download""))
                    {
                         File myFile = new File (""C:\\Users\\cguo\\11.lsp"");
  byte [] mybytearray  = new byte [(int)myFile.length()];
  FileInputStream fis = new FileInputStream(myFile);
  BufferedInputStream bis = new BufferedInputStream(fis);
  bis.read(mybytearray,0,mybytearray.length);
  OutputStream os = connectionSocket.getOutputStream();
  System.out.println(""Sending..."");
  os.write(mybytearray,0,mybytearray.length);
  os.flush();
  connectionSocket.close();
                    }
        if(clientSentence.equals(""set""))
            {outToClient.writeBytes(""connection is "");
            System.out.println(""running here"");
            //welcomeSocket.close();
             //outToClient.writeBytes(capitalizedSentence);
            }



        capitalizedSentence = clientSentence.toUpperCase() + ""\n"";


    //if(!clientSentence.equals(""quit""))
           outToClient.writeBytes(capitalizedSentence+""enter the message or command: "");


        System.out.println(""passed"");
        //outToClient.writeBytes(""enter the message or command: "");
        welcomeSocket.close();
    System.out.println(""connection terminated"");
    }
}

}
So, the TCPServer.java will be executed first, and then execute the TCPClient.java, and I try to use the if clause in the TCPServer.java to test what is user's input,now I really want to implement how to transfer files from both side(download and upload).Thanks.
"
20227,How do I use 3DES encryption/decryption in Java?,"Every method I write to encode a string in Java using 3DES can't be decrypted back to the original string.  Does anyone have a simple code snippet that can just encode and then decode the string back to the original string?
I know I'm making a very silly mistake somewhere in this code. Here's what I've been working with so far:
** note, I am not returning the BASE64 text from the encrypt method, and I am not base64 un-encoding in the decrypt method because I was trying to see if I was making a mistake in the BASE64 part of the puzzle.
public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext  = new TripleDESTest().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j < 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);
            final String encodedCipherText = new sun.misc.BASE64Encoder().encode(cipherText);

            return cipherText;    
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}

        return null;
    }

    public String decrypt(byte[] message) {
        try
        {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0,  k = 16; j < 8;)
            {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            //final byte[] encData = new sun.misc.BASE64Decoder().decodeBuffer(message);
            final byte[] plainText = decipher.doFinal(message);

            return plainText.toString();            
        }
        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(""Invalid Algorithm""); }
        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(""No Such Padding""); }
        catch (java.security.NoSuchAlgorithmException e) { System.out.println(""No Such Algorithm""); }
        catch (java.security.InvalidKeyException e) { System.out.println(""Invalid Key""); }
        catch (BadPaddingException e) { System.out.println(""Invalid Key"");}
        catch (IllegalBlockSizeException e) { System.out.println(""Invalid Key"");}
        catch (UnsupportedEncodingException e) { System.out.println(""Invalid Key"");}     
        catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        return null;
    }
}

"
6788018,Image encryption/decryption using AES256 symmetric block ciphers,"Is there any good example of how to encrypt and decrypt image and other files with AES on Android?
"
415953,How can I generate an MD5 hash in Java?,"Is there any method to generate MD5 hash of a string in Java?
"
11624571,"ANDROID: SEND MAIL with PreConfigured mail:From Address without using mail provider(Like GMAIL,YAHOO pre-installed in ANDROID DEVICE)","I am trying to use RECOVER PASSWORD button which requires MAIL SENDING to correspondent USERNAME. I would like to know the way if somehow I can send MAIL (In Background) without using GMAIL, YAHOO(Pre Installed EMAIL Provider Service) with my own address like abc@abc.com to every user of my application.
Any Help is most welcome!!
"
13525279,How to encrypt a string such that it can be used as a part of a file path and then decrypt it in Android?,"In my application I have a requirement to encrypt a string that can contain the characters a-z, A-Z, 0-9, underscores, periods, and dashes and then we should be able to use that encrypted string as a part of a file path ie; /mnt/sdcard/encryptedstring/file/ and then I should be able to decrypt that string too. Could you please tell me if there is any way in which this can be achieved?
Thank you.
"
13488155,encrypt a folder of html files and use files in java application after decryption,"
Possible Duplicate:
encrypt the html files for client side and browse them in a swing application 

I am working on a swing application in which in which client has to access the html files locally stored in the machine but i want client should not access the html files directly so want to encrypt the   entire   folder of html files using java and in Java application i would write the hard code to decrypt the html files from encrypted folder. One more thing the updation should  be possible in encrypted folder so that encrypted files may be merged in future on client  side.
I have been stuck here and has no clues for my problem , any help for my problem is appreciated. 
"
11683946,Java encrypt word by word,"I'm trying to take in a long string and encrypt it using the following code:
import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;

public class AESEncrypt {

    /**
     * Turns array of bytes into string
     * 
     * @param buf
     *            Array of bytes to convert to hex string
     * @return Generated hex string
     */
    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;

        for (i = 0; i < buf.length; i++) {
            if (((int) buf[i] & 0xff) < 0x10)
                strbuf.append(""0"");

            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
        }

        return strbuf.toString();
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character
                    .digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    public static void main(String[] args) throws Exception {

        String message = ""Test text!"";

        // Get the KeyGenerator
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128); // 192 and 256 bits may not be available

        // Generate the secret key specs.
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        System.out.println(""Key: "" + asHex(raw));

        // Instantiate the cipher

        Cipher cipher = Cipher.getInstance(""AES"");

        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        byte[] encrypted = cipher.doFinal((args.length == 0 ? message : args[0]).getBytes());
        System.out.println(""encrypted string: "" + asHex(encrypted));

    }
}

However, I would like to encrypt word by word and print out the encrypted text as such: 
Original string -> Test text!
Encrypted string -> 29f84h2f 23f9f92jf3
I couldn't find any examples online that could help me out. Is there anyway I can achieve this?
"
3208160,How to generate an HMAC in Java equivalent to a Python example?,"I'm looking at implementing an app getting Twitter authorization via Oauth in Java. The first step is getting a request token. Here is a Python example for app engine. 
To test my code, I am running Python and checking output with Java. Here is an example of Python generating a Hash-Based Message Authentication Code (HMAC):
#!/usr/bin/python

from hashlib import sha1
from hmac import new as hmac

key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50""
message = ""foo""

print ""%s"" % hmac(key, message, sha1).digest().encode('base64')[:-1]

Output:
$ ./foo.py
+3h2gpjf4xcynjCGU5lbdMBwGOc=

How does one replicate this example in Java?
I've seen an example of HMAC in Java:
try {
    // Generate a key for the HMAC-MD5 keyed-hashing algorithm; see RFC 2104
    // In practice, you would save this key.
    KeyGenerator keyGen = KeyGenerator.getInstance(""HmacMD5"");
    SecretKey key = keyGen.generateKey();

    // Create a MAC object using HMAC-MD5 and initialize with key
    Mac mac = Mac.getInstance(key.getAlgorithm());
    mac.init(key);

    String str = ""This message will be digested"";

    // Encode the string into bytes using utf-8 and digest it
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] digest = mac.doFinal(utf8);

    // If desired, convert the digest into a string
    String digestB64 = new sun.misc.BASE64Encoder().encode(digest);
} catch (InvalidKeyException e) {
} catch (NoSuchAlgorithmException e) {
} catch (UnsupportedEncodingException e) {
}

It uses javax.crypto.Mac, all good. However, the SecretKey constructors take bytes and an algorithm. 
What's the algorithm in the Python example? How can one create a Java secret key without an algorithm?
"
10357630,Decrypting Rijndael in Android,"I basically need to decrypt a password I retrieve from a server encrypted with Rijndael, I have never worked with encrypting/decrypting before and I am completely lost. I found somewhere in this web that Java has some methods implemented without need of external libraries to do so but I didn't get it. The only thing I need is the decrypt since I won't be writing back into the server anyways.
Any idea on how to do it or where I could find documentation about it?
I don't know if this code, taken from an answer here is what I am looking for, I don't understand much of it, as I said, I've never worked with this kind of stuff before:
byte[] sessionKey = null; //Where you get this from is beyond the scope of this post
byte[] iv = null ; //Ditto
byte[] plaintext = null; //Whatever you want to encrypt/decrypt
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
//You can use ENCRYPT_MODE or DECRYPT_MODE
cipher.calling init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sessionKey, ""AES""), new IvParameterSpec(iv));
byte[] ciphertext = cipher.doFinal(plaintext);

Thanks in advance.
"
10283637,How to append to AES encrypted file,"I'm writing some kind of logger that produces encrypted log-file. Unfortunately, cryptography is not my strong side. Now I can write to file several messages and then close file. Then i can open it, append some messages, close again and after decryption I see padding bytes in the middle of file. Is there any way to work with encrypted file without having to decrypt it every time I want to append some messages?
EDIT: little more details. Current implementation utlizes CipherOutputStream. As i understand there's no way to seek using it.
Can i use 'NoPadding' option if i will control that output data size is divisible by block size?
"
10303767,Encrypt and Decrypt in Java,"I would like to store an encrypted password in a Java file. 
I saw at a solution using javax.crypto, but the problem with that was that the key
was being generated on the fly and it was random. 
This password will be then taken and decrypted in the Java program in runtime. 
Given that I am going to store an already encrypted password in a file - I want to get the 
right text when decrypting it. 
Is there a way to tell the javax.crypto method: 
key = KeyGenerator.getInstance(algorithm).generateKey()

Can this be replaced with my own key generated once based on some private key? 
Can anyone point me to some resources on how to do this? 
"
13102788,Is there any sample Java code that does AES encryption exactly like this website?,"http://www.hanewin.net/encrypt/aes/aes-test.htm
If you go to this website and enter the following:
""Key In Hex"":        00000000000000000000000000123456

""Plain Text in Hex"": 00000000000000000000000000000000

And click on ""Encrypt"" button you will see the ciphertext in hex is:
3fa9f2a6e4c2b440fb6f676076a8ba04

Is there a Java program out there that I can do this (I.e. Is there an AES library that will input the ""Key In Hex"" above with the ""Plain Text In Hex"" above and generate the Ciphertext in Hex above? )?
I would appreciate any advice or links to Java sample code that does this. 
"
995514,Https Connection Android,"I am doing a https post and I'm getting an exception of ssl exception Not trusted server certificate. If i do normal http it is working perfectly fine. Do I have to accept the server certificate somehow?
"
20579539,no email send android,"I want when I click on button an email will be send automatically to the user.
I followed this : Sending Email in Android using JavaMail API without using the default/built-in app android-using-javamail-api-without-using-the-default-built-in-a
and here is my code : https://stackoverflow.com/questions/20570957/sending-email-without-user-notice
No crashes or errors, but no email was sent!
Can someone please solve it for me ?
thank you 
GmailSender class:
package com.example.tesst;

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;   
import javax.mail.internet.MimeMultipart;

import android.util.Log;

import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GmailSender extends javax.mail.Authenticator {   
private String mailhost = ""smtp.gmail.com"",imagePath;   
private String user;   
private String password;   
private Session session;   

static 
{   
    Security.addProvider(new com.example.tesst.JSSEProvider());   
}  

public GmailSender(String user, String password,String imagePath) {   
    this.user = user;   
    this.password = password;   
    this.imagePath=imagePath;
    Properties props = new Properties();   
    props.setProperty(""mail.transport.protocol"", ""smtp"");   
    props.setProperty(""mail.host"", mailhost);   
    props.put(""mail.smtp.auth"", ""true"");   


    props.put(""mail.smtp.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.class"",   
            ""javax.net.ssl.SSLSocketFactory"");   
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
    props.setProperty(""mail.smtp.quitwait"", ""false"");   

    session = Session.getDefaultInstance(props, this);   
}   

protected PasswordAuthentication getPasswordAuthentication() {   
    return new PasswordAuthentication(user, password);   
}   

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
    try{


         Transport transport = session.getTransport();  

         MimeMessage message = new MimeMessage(session);  
         message.setSubject(subject);  
         message.setFrom(new InternetAddress(sender));  
         message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipients));  

         //  
         // This HTML mail have to 2 part, the BODY and the embedded image  
         //  
         MimeMultipart multipart = new MimeMultipart(""related"");  

         // first part  (the html)  
         BodyPart messageBodyPart = new MimeBodyPart();  
         String htmlText = ""<H1>""+body+""</H1>"";  
         messageBodyPart.setContent(htmlText, ""text/html"");  

         // add it  
         multipart.addBodyPart(messageBodyPart);  

         // second part (the image)  
      //   messageBodyPart = new MimeBodyPart();  
     //    DataSource fds = new FileDataSource(imagePath);  
     //    messageBodyPart.setDataHandler(new DataHandler(fds));  
     //    messageBodyPart.setHeader(""Content-ID"",imagePath);  

         // add it  
       //  multipart.addBodyPart(messageBodyPart);  

         // put everything together  
         message.setContent(multipart);  

         transport.connect();  
         transport.sendMessage(message,message.getRecipients(Message.RecipientType.TO));  
         transport.close();  
    }catch(Exception e){
        Log.e("""", ""FILE NOT FOUND EXCEPTION ""+e.getMessage());
    }
}   

public class ByteArrayDataSource implements DataSource {   
    private byte[] data;   
    private String type;   

    public ByteArrayDataSource(byte[] data, String type) {   
        super();   
        this.data = data;   
        this.type = type;   
    }   

    public ByteArrayDataSource(byte[] data) {   
        super();   
        this.data = data;   
    }   

    public void setType(String type) {   
        this.type = type;   
    }   

    public String getContentType() {   
        if (type == null)   
            return ""application/octet-stream"";   
        else  
            return type;   
    }   

    public InputStream getInputStream() throws IOException {   
        return new ByteArrayInputStream(data);   
    }   

    public String getName() {   
        return ""ByteArrayDataSource"";   
    }   

    public OutputStream getOutputStream() throws IOException {   
        throw new IOException(""Not Supported"");   
    }   
}   
}  

JSSEProvider  class 
   package com.example.tesst;


   import java.security.AccessController;

   import java.security.Provider;


   public final class JSSEProvider extends Provider {

public JSSEProvider() {
    super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
    AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {
        public Void run() {
            put(""SSLContext.TLS"",
                    ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
            put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
            put(""KeyManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
            put(""TrustManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
            return null;
        }
    });
}


   }

MainActivity  class
 package com.example.tesst;


 import android.os.Bundle;

 import android.app.Activity;

 import android.util.Log;

 import android.view.Menu;

 import android.view.View;

 import android.widget.Button;


 public class MainActivity extends Activity {


public Button send;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    send=(Button) findViewById(R.id.send);
    send.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View arg0) {
            // TODO Auto-generated method stub
            try {   
                   GmailSender sender = new GmailSender(""mobilibksu@gmail.com"", ""12345"","""");
                   sender.sendMail(""test"",""bla bla blaaaa"",""lamachanz@gmail.com"",""lamachanz@gmail.com"");   
                } 
             catch (Exception e) 
               {   
                   Log.e(""SendMail"", e.getMessage(), e);   
               }
        }
    });
}

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}


 }

"
19698272,Encrypt in java and Decrypt in C# For AES 256 bit,"1.I have java function which encrypt xml file and return encrypted String.
/// Java Class 
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Crypt {

    public static String key = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    public static byte[] key_Array = Base64.decodeBase64(key);

    public static String encrypt(String strToEncrypt)
    {       
        try
        {   
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            //Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");      

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");

            Cipher _Cipher = Cipher.getInstance(""AES"");     
            _Cipher.init(Cipher.ENCRYPT_MODE, SecretKey);       

            return Base64.encodeBase64String(_Cipher.doFinal(strToEncrypt.getBytes()));     
        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());
        }
        return null;
    }

    public static void main(String[] args) {        
        StringBuilder sb = new StringBuilder();
        sb.append(""xml file string ..."");

        String EncryptedString = encrypt(sb.toString());        
        System.out.println(""[EncryptedString]:""+EncryptedString);
    }
}

2.I have c# function which decrypt the message which is encrypted by java function.
/// C# Function
private static string Decrypt(string encryptedText)
{
    RijndaelManaged aesEncryption = new RijndaelManaged();            
    aesEncryption.BlockSize = 256;
    //aesEncryption.KeySize = 256;
    //aesEncryption.Mode = CipherMode.CBC;
    //aesEncryption.Padding = PaddingMode.PKCS7;

    string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    //string ivStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";        

    byte[] keyArr = Convert.FromBase64String(keyStr);
    //byte[] ivArr = Convert.FromBase64String(ivStr);

    aesEncryption.Key = keyArr;
    //aesEncryption.IV = ivArr;

    ICryptoTransform decrypto = aesEncryption.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(encryptedText.ToCharArray(), 0, encryptedText.Length);  
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length); /// CryptographicException: Length of the data to decrypt is invalid.    
    return ASCIIEncoding.UTF8.GetString(decryptedData); 
}

Java encrypt function is work well. But the problem is C# function, when I decrypt I get below error message
CryptographicException: Length of the data to decrypt is invalid.

I searched solutions by using below ref

AES Encryption in Java and Decryption in C#
C# / Java | AES256 encrypt/decrypt
Encyption/Decryption in C# and Java

but I still face the same error.Could anyone give me suggestion please.
Updated
I Just change my C# crypto function. Below is my change lists

Block Size to 128
Key Size to 256
IV Size to 16
Key Size to 32

/// Updated decrypt function
private static string Decrypt(string encryptedText)
{
    RijndaelManaged aesEncryption = new RijndaelManaged();            
    aesEncryption.BlockSize = 128;
    aesEncryption.KeySize = 256;

    //aesEncryption.Mode = CipherMode.CBC;
    aesEncryption.Padding = PaddingMode.None;

    string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    string ivStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";           

    byte[] ivArr = Convert.FromBase64String(ivStr);
    byte[] IVkey16BytesValue = new byte[16];
    Array.Copy(ivArr, IVkey16BytesValue, 16);

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArr32BytesValue = new byte[32];
    Array.Copy(keyArr, KeyArr32BytesValue, 32);

    aesEncryption.IV = IVkey16BytesValue;
    aesEncryption.Key = KeyArr32BytesValue; 

    ICryptoTransform decrypto = aesEncryption.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(encryptedText.ToCharArray(), 0, encryptedText.Length);
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length); 
    return ASCIIEncoding.UTF8.GetString(decryptedData);
}

In this time, no error occur. But I get decrypted message which i cannot read.
g:�\0�\td��Y\\符O����\rL��W�wHm�>f�\au����%��0��\ ..........

Please let me get your suggestion again. 
"
19053470,"Android MD5 issue calculating MD5, missing characters","I've been developing an Android App and in certain part of the app I need to calculate the MD5 of a certain string. I've been using the following code, but every now and then the output string if the byte it has to convert to String is lower than 10, then it will miss a 0 in the two byte representation:
    MessageDigest di = java.security.MessageDigest.getInstance(""MD5"");
    di.update(cadena.getBytes());
    byte mdi[] = di.digest();

    StringBuffer md5= new StringBuffer();
    for (byte b : mdi) {
        md5.append(Integer.toHexString(0xFF & b));
    }

For example, if I pass the string 109370 the MD5 it will have to return is 932ff0696b0434d7a83e1ff84fe298c5 but instead it calculates the 932ff0696b434d7a83e1ff84fe298c5.
That's because the byte array has a 4 and Integer.toHexString() is returning only 1 char array instead of two.
Any thought about how can I handle this?
Thanks!
"
29224892,C# to Java Encryption and Decryption,"I'm trying to do an Encryption and Decryption in Java Android. 
Below is my code for C#, I need to convert it to Java Android. Can someone help me how to do it?
I've been doing this for almost 2 days yet can't find any solutions on how to convert it. I'm newbie in Android.
public static string Encrypt(string toEncrypt)
        {
            byte[] keyArray;
            byte[] toEncryptArray = UTF8Encoding.UTF8.GetBytes(toEncrypt);

            System.Configuration.AppSettingsReader settingsReader = new AppSettingsReader();

            string key = ""KEY"";

            MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
            keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
            hashmd5.Clear();

            TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
            tdes.Key = keyArray;
            tdes.Mode = CipherMode.ECB;
            tdes.Padding = PaddingMode.PKCS7;

            ICryptoTransform cTransform = tdes.CreateEncryptor();
            byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);
            tdes.Clear();
            return Convert.ToBase64String(resultArray, 0, resultArray.Length);
        }

        public static string Decrypt(string cipherString)
        {
            try
            {
                byte[] keyArray;
                byte[] toEncryptArray = Convert.FromBase64String(cipherString);

                string key = ""KEY"";

                MD5CryptoServiceProvider hashmd5 = new MD5CryptoServiceProvider();
                keyArray = hashmd5.ComputeHash(UTF8Encoding.UTF8.GetBytes(key));
                hashmd5.Clear();

                TripleDESCryptoServiceProvider tdes = new TripleDESCryptoServiceProvider();
                tdes.Key = keyArray;
                tdes.Mode = CipherMode.ECB;
                tdes.Padding = PaddingMode.PKCS7;

                ICryptoTransform cTransform = tdes.CreateDecryptor();
                byte[] resultArray = cTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length);

                tdes.Clear();
                return UTF8Encoding.UTF8.GetString(resultArray);
            }
            catch (Exception)
            {
                return ""Invalid"";
            }
        }

"
13626965,How to ignore PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException?,"I got the following exception when try to post a request to a http server:
Here is the code I used
URL url = new URL(
        ""https://www.abc.com"");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();

conn.setRequestMethod(""GET"");

conn.setDoOutput(true);

DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
// wr.writeBytes(params);
wr.flush();
wr.close();

BufferedReader br = new BufferedReader(new InputStreamReader(
        conn.getInputStream()));
String line = null;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

Here is the exception:
Exception in thread ""main"" javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at com.sun.net.ssl.internal.ssl.Alerts.getSSLException(Alerts.java:174)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1731)
    at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:241)
    at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:235)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1206)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:136)
    at com.sun.net.ssl.internal.ssl.Handshaker.processLoop(Handshaker.java:593)
    at com.sun.net.ssl.internal.ssl.Handshaker.process_record(Handshaker.java:529)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:925)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1170)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1197)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1181)
    at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:434)
    at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:166)
    at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1014)
    at sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:230)
    at com.amazon.mzang.tools.httpchecker.CategoryYank.getPV(CategoryYank.java:32)
    at com.amazon.mzang.tools.httpchecker.CategoryYank.main(CategoryYank.java:18)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:323)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:217)
    at sun.security.validator.Validator.validate(Validator.java:218)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:126)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:209)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:249)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1185)
    ... 13 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:174)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:238)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:318)
    ... 19 more

The server is not owned by me. Is there a way to ignore this exception?
"
28233303,"javax.net.ssl.SSLException: Read error: ssl=0x56e63588: I/O error during system call, Connection reset by peer","I have been using using org.apache.http.client.HttpClient to download some data from a HTTP server for past 2 years and its been working fine.
Recently we switched to HTTPS for some security reasons.This is also working fine with WiFi and High speed mobile data(3G).But most often with slow data connection(2G) My download interrupted with following stack trace. 
 javax.net.ssl.SSLException: Read error: ssl=0x56e63588: I/O error during system call, Connection reset by peer
    at com.android.org.conscrypt.NativeCrypto.SSL_read(Native Method)
    at com.android.org.conscrypt.OpenSSLSocketImpl$SSLInputStream.read(OpenSSLSocketImpl.java:690)
    at org.apache.http.impl.io.AbstractSessionInputBuffer.fillBuffer(AbstractSessionInputBuffer.java:103)
    at org.apache.http.impl.io.AbstractSessionInputBuffer.read(AbstractSessionInputBuffer.java:120)
    at org.apache.http.impl.io.ChunkedInputStream.read(ChunkedInputStream.java:131)
    at org.apache.http.conn.EofSensorInputStream.read(EofSensorInputStream.java:140)
    at java.io.FilterInputStream.read(FilterInputStream.java:114)

This is how my Code Looks like :
                HttpPost httpPost = new HttpPost(url);
                UrlEncodedFormEntity p_entity = new UrlEncodedFormEntity(
                        params, HTTP.UTF_8);
                httpPost.setEntity(p_entity);
                response = httpClient.execute(httpPost);
                DataInputStream in = new               DataInputStream(response.getEntity().getContent());
                String st = """";
                result = new Vector<String>();
                while ((st = readLine(in)) != null) {
                result.addElement(st);
         }

"
28115035,Encrypting files with AES on Android,"So I am working on a personal project for myself, and I am trying to encrypt files on my phone. These files can be anything i.e Documents, photos, etc. Right now I am trying to get this working properly. When ever I run the encryption it seems to work properly and encrypt the files. When I run the decrypt, sometimes it works and other times it doesn't. When it fails I generally get a ""Error while finalizing cipher, pad block corrupted"" error. I'm also not using different test files, so it isn't like some files work and others don't. It's the same two files I try each time. 
public static void encryptfile(String path,String Pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    FileInputStream fis = new FileInputStream(path);
    FileOutputStream fos = new FileOutputStream(path.concat("".crypt""));
    byte[] key = (salt + Pass).getBytes(""UTF-8"");
    MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
    key = sha.digest(key);
    key = Arrays.copyOf(key,16);
    SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, sks);
    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    cos.flush();
    cos.close();
    fis.close();
}

public static void decrypt(String path,String Pass) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
    FileInputStream fis = new FileInputStream(path);
    FileOutputStream fos = new FileOutputStream(path.replace("".crypt"",""""));
    byte[] key = (salt + Pass).getBytes(""UTF-8"");
    MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
    key = sha.digest(key);
    key = Arrays.copyOf(key,16);
    SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, sks);
    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();
}

Currently the Salt and Password are static and do not change for testing purposes. Still get errors about half the time.
Does anyone have any ideas on why this happens? I have been searching around and I have found a couple things to try, none of which worked. I have looked through some of the following questions for solutions:
Android decryption: Error while finalizing cipher
last block incomplete with CipherInputStream/CipherOutputStream, even with padding AES/CBC/PKCS5Padding
Encryption error on Android 4.2
Decrypting error : ""no iv set when one expected""
How to handle ""last block incomplete in decryption""
Encryption and decryption of image file
Tips on encryption/decryption of images in java using AES
Any help is greatly appreciated! I think I am just missing something simple...
Update! 
People were right when it was the salt. When I removed the salt, the problem was solved... Did a little more digging, turns out salt+Pass was the issues, but because the salt was a byte[] and Pass was a string. I changed salt to String and then used salt.concat(Pass) and the problem was solved!
"
27993890,"IPBoard password hashing issue, doesn&#39;t match algorithm","A quick link to the IPBoard page explaining that the forum uses the standard md5(md5($salt).md5($password)) format that most forums use can be found here: https://www.invisionpower.com/support/guides/_/advanced-and-developers/miscellaneous/passwords-in-ipboard-r130
I actually come from using MyBB which uses the same structure, so I would have thought just changing the table/column names in my query would make for a relatively simple switch, boy was I wrong.
The original query that I had used was the following
SELECT * FROM `forum_members` WHERE `name`=? AND `members_pass_hash`= MD5(CONCAT(MD5(members_pass_salt), MD5(?)))""

This is a prepared statement, in which the username and the raw password are provided by my server. This unfortunately was not working, I took a few steps and started to debug the data, instead of using the SQL MD5 function I grabbed the data and performed MD5 checks in Java to get a better idea of what was going on.
To do this, I used the following MD5 function I've used for a long time:
public String MD5(String md5) {
           try {
                java.security.MessageDigest md = java.security.MessageDigest.getInstance(""MD5"");
                byte[] array = md.digest(md5.getBytes());
                StringBuffer sb = new StringBuffer();
                for (int i = 0; i < array.length; ++i) {
                  sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
               }
                return sb.toString();
            } catch (java.security.NoSuchAlgorithmException e) {
            }
            return null;
        }

This yielded some slightly strange results, in which the data wasn't matching up.
Database salt: *nzFC 
Database hash: 6bac5cba673134ea084e481b57921134
Server generated hash: d7f94e3f262e7dee81b12ac087c42b18

The server generated has was generated by using the MD5(MD5(salt) + MD5(rawpassword)) method the other forums use, including IPB. This worked on MyBB, so I'm a bit flustered. 
I've checked for things such as capitalization problems, etc, but I'm coming up absolutely blank. 
"
27706853,How do I make an ODK Android app(whose source I can&#39;t modify) trust a fake certificate from my localhost?,"I'm developing a web app that is accessed by the ODK Android app( https://opendatakit.org/). The work that I'm doing requires an https connection. However ODK returns with javax.net.ssl.SSLPeerUnverifiedException. How do I make odk trust the SSL connection with my localhost?
"
27284478,Char array Vs Byte array which one to use?,"I was passing sensitive information (between my app and backend) like password in String format.
Later on I realized that password can be easily read from heap memory dump as it is stored in text format. 
String password = ""super_password"";

So I decided to use Char array, 
Char[] passChar = password.toCharArray();

but I am worried that password can still be read from memory dump character by character. Then I thought of using byte array instead. 
byte[] passByte = password.getBytes();

My question: Is it safe to use byte array for passing sensitive information like password ? 
OR can anyone recommend anything secure ?
"
26920068,LDAP Error 49 from Java JNDI Connection,"* CHECK BELOW AN ANSWER WITH A FULL WORKING SOLUTION *
I'm stucked days with a Java LDAP connection problem.
This is my method to connect to a LDAP Server:
public boolean authenticate(String user, String password) {
    StringBuilder url = new StringBuilder(""ldap://"");
    url.append(""10.0.0.1"");
    url.append("":"");
    url.append(389);

    StringBuilder securityPrincipal = new StringBuilder(""uid="");
    securityPrincipal.append(user);
    securityPrincipal.append("","");
    securityPrincipal.append(""dc=XXXXX,dc=YYY,dc=ZZ"");

    Hashtable<String, String> env;
    env = new Hashtable<String, String>();
    env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
    env.put(Context.PROVIDER_URL, url.toString());
    env.put(Context.SECURITY_AUTHENTICATION, ""simple"");
    env.put(Context.SECURITY_PRINCIPAL, securityPrincipal.toString());

    env.put(Context.SECURITY_CREDENTIALS, password);

    System.out.println(url);
    System.out.println(securityPrincipal.toString());

    try {
        ldap = new InitialLdapContext(env, null);
    } catch (NamingException e) {
        e.printStackTrace();
        return false;
    }

    return true;
}

For security and disclosure reasons, I ommited ""dc"" for XXXXX, YYY and ZZ and changed LDAP server's IP. 
I used the same combination into a PHP software (GLPI) and it worked like a charm. But, for GOD's sake, Java cannot accept this LDAP configurarion giving me always this error:
javax.naming.AuthenticationException: [LDAP: error code 49 - Invalid Credentials]
    at com.sun.jndi.ldap.LdapCtx.mapErrorCode(Unknown Source)
    at com.sun.jndi.ldap.LdapCtx.processReturnCode(Unknown Source)
    at com.sun.jndi.ldap.LdapCtx.processReturnCode(Unknown Source)

Full dn is this:
uid=tiagoadami,dc=XXXXX,dc=YYY,dc=ZZ

Variable user is filled with ""tiagoadami"" and variable ""argument"" is filled with the plain text password.
This is very annoying. My password is correct, and I'm authenticating into every single application with username ""tiagoadami"" and the password. I'm out of options right now. Can anyone help me?
"
24968466,How to use Cipher on this Method to decrypt a String?,"Hello I build this 2 Methods the Encryption works fine but the Decryption get an error because 
cipher wants a byte and i want to encrypt from a String
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class Test {

    private byte[] encrypted;

    private String encryptedtext;
    private String decrypted;



    public String Encrypt (String pInput) {


      try {

         String Input = pInput;
         String key = ""Bar12345Bar12345Bar12345Bar12345""; 

         // Erstelle key and cipher
         SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
         Cipher cipher = Cipher.getInstance(""AES"");

         // Verschlüsselung
         cipher.init(Cipher.ENCRYPT_MODE, aesKey);
         byte[] encrypted = cipher.doFinal(Input.getBytes());
         encryptedtext = new String(encrypted);
         System.err.println(""encrypted:"" + encryptedtext);


      }catch(Exception e) {
         e.printStackTrace();
      }

        return encrypted;
    }



    public String Decrypt (String pInput) {


       try {

           String Input = pInput; 

           String key = ""Bar12345Bar12345Bar12345Bar12345""; 

           // Erstelle key and cipher
           SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
           Cipher cipher = Cipher.getInstance(""AES"");

           // Entschlüsselung
           cipher.init(Cipher.DECRYPT_MODE, aesKey);
           decrypted = new String(cipher.doFinal(encryptedtext)); // HERE IS THE PROBLEM IT WANT BYTE BUT I WANT TO ENCRYPT FROM A STRING
           System.err.println(""decrypted: "" + decrypted);

        }catch(Exception e) {
           e.printStackTrace();
        }
        return pInput;
      }

}

"
24668843,Algorithm AES And Algorithm Twofish,"I have a project to make an encryption and decryption for string input in java. I've been stucked for a week doing some research in it. I really appreciate if you have sample source code or function method for Algorithm AES and Algorithm Twofish in java that I may use in my project. I really need your help ... hope someone out there could be my savior. Thanks very much.
"
15920739,RSA implementation using java,"I am implementing RSA in java I have encountered a code which is given below it is showing plaintext in numeric form after decrypting the plaintext, but I want it in simple english which I entered. I don't want to use the java api.
TestRsa.Java 
import java.io.IOException;
import java.math.BigInteger;
import java.util.Random;

public class TestRsa {

    private BigInteger p, q;
    private BigInteger n;
    private BigInteger PhiN;
    private BigInteger e, d;

    public TestRsa() {
        initialize();
    }

    public void initialize() {
        int SIZE = 512;
        /* Step 1: Select two large prime numbers. Say p and q. */
        p = new BigInteger(SIZE, 15, new Random());
        q = new BigInteger(SIZE, 15, new Random());
        /* Step 2: Calculate n = p.q */
        n = p.multiply(q);
        /* Step 3: Calculate ø(n) = (p - 1).(q - 1) */
        PhiN = p.subtract(BigInteger.valueOf(1));
        PhiN = PhiN.multiply(q.subtract(BigInteger.valueOf(1)));
        /* Step 4: Find e such that gcd(e, ø(n)) = 1 ; 1 < e < ø(n) */
        do {
            e = new BigInteger(2 * SIZE, new Random());
        } while ((e.compareTo(PhiN) != 1)
                || (e.gcd(PhiN).compareTo(BigInteger.valueOf(1)) != 0));
        /* Step 5: Calculate d such that e.d = 1 (mod ø(n)) */
        d = e.modInverse(PhiN);
    }

    public BigInteger encrypt(BigInteger plaintext) {
        return plaintext.modPow(e, n);
    }

    public BigInteger decrypt(BigInteger ciphertext) {
        return ciphertext.modPow(d, n);
    }

    public static void main(String[] args) throws IOException {
        TestRsa app = new TestRsa();
        int plaintext;
        System.out.println(""Enter any character : "");
        plaintext = System.in.read();
        BigInteger bplaintext, bciphertext;
        bplaintext = BigInteger.valueOf((long) plaintext);
        bciphertext = app.encrypt(bplaintext);
        System.out.println(""Plaintext : "" + bplaintext.toString());
        System.out.println(""Ciphertext : "" + bciphertext.toString());
        bplaintext = app.decrypt(bciphertext);
        System.out.println(""After Decryption Plaintext : ""
                + bplaintext.toString());
    }
}

"
23482145,Unique string identifier with fixed length,"Using user email (that by default it's a unique identifier) and if I need current timestamp, I'd like to generate an alphanumeric string of 11 characters (or less) that represent a unique identifier. 
First to create an ad hoc (irreversible) algorithm to do it, I'd like to know if in Java there is something.
"
23561104,How to encrypt and decrypt String with my passphrase in Java (Pc not mobile platform)?,"I want to encrypt a string and then put it on a file. Also want to decrypt it when I want.  I don’t need very strong security. I just want to make it harder to get my data others.
I tried several ways. Here are these.
Md5 Encryption:
How to hash a string in Android?
public static final String md5(final String toEncrypt) {
        try {
            final MessageDigest digest = MessageDigest.getInstance(""md5"");
            digest.update(toEncrypt.getBytes());
            final byte[] bytes = digest.digest();
            final StringBuilder sb = new StringBuilder();
            for (int i = 0; i < bytes.length; i++) {
                sb.append(String.format(""%02X"", bytes[i]));
            }
            return sb.toString().toLowerCase();
        } catch (Exception exc) {
            return """"; // Impossibru!
        }
    }

I tried this function and able to encrypt a string but I can’t decrypt data from it. So it is not the solution.
DES Encryption:
Encrypt and decrypt a String in java
Here passphrase is Auto generated. Is always passphrase will same on all time? Then where is my security. So it is not my solution too.
AES Encryption:
How do I encrypt/decrypt a string with another string as a password?
I also tried Aes from this link. Here key is also auto generated?
Is there any other way?
"
26649389,How to disable SSLv3 in android for HttpsUrlConnection?,"We wrote client application in android which connects with https servers using HttpsUrlConnection apis. Due to Poodle vulnerability, we need to disable SSLv3 from the list of enabled protocols while invoking any request. 
We followed the guidelines captured by oracle
and added following line before invoking url connection
java.lang.System.setProperty(""https.protocols"", ""TLSv1"");

This solution works fine with normal java program. 
We got SSLHandShakeException when tried to connect with a server which only works on SSLv3 protocol.
But concern is : same fix does not work for android. Am I missing something or should I try another approach for android? Please suggest.
"
32508961,Java equivalent of an OpenSSL AES CBC encryption,"I'm not a cryptography profi and specially due to the fact that OpenSSL has lots of missing documentation, I'm not sure how can I solve this problem.
I have an external system which expects to receive encrypted messages. The only example provided uses OpenSSL in this way:
$ openssl enc -aes-256-cbc -a -in t.txt -k testpass
U2FsdGVkX1/RUdaSJKRXhHv3zUyTsQwu5/ar2ECKDlrNyH5GL4xRR4fgxkiWqkS1
cQstcoSIgWfRPSOFj/5OtdNLeNXiVR6MxSKJ+NvS9LyUD8+Rg6XIcYUvxR4gHi3w
DWT44LAMCpRAh1Q0t4Z2g7rwb0D05T6ygLaWvB5zD/xGZD3brTqSlWmiJb9Imgda
M6soZO7BhbYdqWqEUl5r6+EbkD21f6L3NX3hJFo+BJ+VFctiAlBO8NwT5l4ogo/s
GErm8gqRr57XoX/kvKAimg==

Where the t.txt file contains this string on one line:
AMOUNT=10&TID=#19:23&CURRENCY=EUR&LANGUAGE=DE&SUCCESS_URL=http://some.url/sucess&ERROR_URL=http://some.url/error&CONFIRMATION_URL=http://some.url/confirm&NAME=customer full name`

I have found this other question and I have been able to do the encryption using following code:
String password = ""passPhrase"";
String salt = ""15charRandomSalt"";
int iterations = 100;

/* Derive the key, given password and salt. */
SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(Charset.forName(""UTF8"")), iterations, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

/* Encrypt the message. */
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
byte[] cipherText = cipher.doFinal(toBeEncrypted.getBytes(""UTF-8""));
encryptedData = Base64.getEncoder().encodeToString(cipherText);
encryptedData += Base64.getEncoder().encodeToString(iv);

What I can not understand is how should I generate similar output (encryptedData) to what OpenSSL does. I have the salt, iv and cipherText, is the OpenSSL output Base64 encoded result of a concatenation of these? or only one single of them?
The only thing I share with that other system before encryption is the pass phrase. How could they decrypt the result if salt and number of iterations is not known to them?
Can somebody give answers to those unknown parameters and also tell me if the above code is the equivalent of OpenSSL process?
"
9210514,Unable to find valid certification path to requested target - error even after cert imported,"I have a Java client trying to access a server with a self-signed certificate.
When I try to Post to the server, I get the following error:

unable to find valid certification path to requested target

Having done some research on the issue, I then did the following.

Saved my servers domain name as a root.cer file.

In my Glassfish server's JRE, I ran this:
keytool -import -alias example -keystore cacerts -file root.cer


To check the cert was added to my cacert successfully, I did this:
keytool -list -v -keystore cacerts

I can see the cert is present.

I then restarted Glassfish and retried the 'post'.


I am still getting the same error.
I have a feeling this is because my Glassfish is not actually reading the cacert file that I have amended but maybe some other one.
Have any of you had this issue and can push me in the right direction?
"
40123319,Easy way to Encrypt/Decrypt string in Android,"My question is how to encrypt a String:
String AndroidId;

@Override
public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
  setContentView(R.layout.download_movie_activity);

  cancel = (Button)findViewById(R.id.img_cancle);

  linear= (LinearLayout)findViewById(R.id.progress);
  linear.setVisibility(View.GONE);

  String encrypted = ""MzIyNTE2"" + ""OTQNzM4NTQ="";

  Log.e(""Encrypt"", encrypted);

  WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
  WifiInfo wInfo = wifiManager.getConnectionInfo();
  AndroidId = wInfo.getMacAddress();

  AndroidId=encrypted;

How do i encrypt my AndroidId in which I storing a MAC address.
"
43418958,Is it possible to create synchronised random numbers on two different devices?,"Is there a secure way to create same random numbers on two different devices on java without can predict next number or whole number series by user/coder?
I thought a synchronised initiation like firstly users enter same numbers at run of program.This number may be processed with cryptographic techniques(?). And that follows to generate same number series on both of devices. But i really don't know how to do it and how much is it safe?
Note: I have searched for it, but don't have enough knowledge for this specific situation.
"
42805652,Setup AsyncHttpClient to use HTTPS,"I am using com.loopj.android:android-async-http:1.4.9 for my request to server. It was working fine until I SSL/TLS is required in my server. So I need to modify my AsyncHTTPClient to use HTTPS in all URLs.
I checked this similar how to make HTTPS calls using AsyncHttpClient? but did not provide clear solution to the problem. The accepted solution was not secure as well because of this warning from the library itself: 

Warning! This omits SSL certificate validation on every device, use
  with caution.

So I went on and check other solutions. I ended up following the recommendation from: https://developer.android.com/training/articles/security-ssl.html. Thus, I have something similar to this:
// Load CAs from an InputStream
// (could be from a resource or ByteArrayInputStream or ...)
CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
// From https://www.washington.edu/itconnect/security/ca/load-der.crt
InputStream caInput = new BufferedInputStream(new FileInputStream(""load-der.crt""));
Certificate ca;
try {
    ca = cf.generateCertificate(caInput);
    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
    caInput.close();
}

// Create a KeyStore containing our trusted CAs
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);

// Create a TrustManager that trusts the CAs in our KeyStore
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);

// Create an SSLContext that uses our TrustManager
SSLContext context = SSLContext.getInstance(""TLS"");
context.init(null, tmf.getTrustManagers(), null);

// Get SocketFactory from our SSLContext
//
//      !!!PROBLEM IS HERE!!!
//   
javax.net.ssl.SSLSocketFactory socketFactory = context.getSocketFactory();

As you can see in the last line, it gives an SSLSocketFactory from javax.net.ssl package. However the AsyncHTTPClient instance requires 
asyncHTTPClient.setSSLSocketFactory(cz.msebera.android.httpclient.conn.ssl.SSLSocketFactory)
EDIT:
My server is using a self-signed certificate.
"
42416313,md5 encryption and decryption java unable to encrypt more than 16bytes,"Please help me to encrypt full string ""TEST STRING TO ENCRYPT"".
here encryption is done for 16 bytes only.
The following is my code for md5 encrption and decryption.
Please help me to encrypt more bytes.
import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class Md5Encryption 
{
    private static final String ALGORITHM = ""md5"";
    private static final String DIGEST_STRING = ""HG58YZ3CR9"";
    private static final String CHARSET_UTF_8 = ""utf-8"";
    private static final String SECRET_KEY_ALGORITHM = ""DESede"";
    private static final String TRANSFORMATION_PADDING = ""DESede/CBC/PKCS5Padding"";

    /* Encryption Method */
    public String encrypt(String message) throws Exception 
    { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        cipher.init(Cipher.ENCRYPT_MODE, key, iv); 

        final byte[] plainTextBytes = message.getBytes(CHARSET_UTF_8); 
        final byte[] cipherText = cipher.doFinal(plainTextBytes); 

        return new String(cipherText); 
    } 

   /* Decryption Method */
    public String decrypt(String message) throws Exception { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        decipher.init(Cipher.DECRYPT_MODE, key, iv); 

        final byte[] plainText = decipher.update(message.getBytes()); 

        return new String(plainText, CHARSET_UTF_8); 
    }

    public static void main(String[] args) throws Exception {


        String text = ""TEST STRING TO ENCRYPT"";
        String codedtext = new Md5Encryption().encrypt(text);
//        String codedtext = "".ªÉ…U$L§U`8Ë‰­?¦”›°„"";
        String decodedtext = new Md5Encryption().decrypt(codedtext); 

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array 
        System.out.println(decodedtext); // This correctly shows ""TEST STRING TO ENCRYPT"" 
    } 


}

"
41270781,"MD5 in Java, works with apostrophe (&#39;)","I'm trying to hash a string in java using MD5, and every solution I've found on SO doesn't handle the apostrophe character correctly. I've tried:
private static String getMD5(String input) throws NoSuchAlgorithmException {
    final String md5Hex = md5Hex(input);
    return md5Hex;
}

Which uses the DigestUtils class. I've also tried the solution from https://dzone.com/articles/get-md5-hash-few-lines-java:
    private static String getMD5(String input) throws Exception {
       MessageDigest m = MessageDigest.getInstance(""MD5"");
       m.update(input.getBytes(), 0, input.length());
       return new BigInteger(1, m.digest()).toString(16);
   }

But that doesn't work either. What solution in Java works for getting an MD5 hash with a string that may contain apostrophes and other special characters? 
CLARIFICATION: the code above doesn't throw an error, it just generates the wrong MD5 checksum.
"
13022717,Java and HTTPS url connection without downloading certificate,"This code connects to a HTTPS site and I am assuming I am not verifying the certificate.  But  why don't I have to install a certificate locally for the site?  Shouldn't I have to install a certificate locally and load it for this program or is it downloaded behind the covers?  Is the traffic between the client to the remote site still encrypted in transmission?
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class TestSSL {

    public static void main(String[] args) throws Exception {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        } };
        // Install the all-trusting trust manager
        final SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        URL url = new URL(""https://www.google.com"");
        URLConnection con = url.openConnection();
        final Reader reader = new InputStreamReader(con.getInputStream());
        final BufferedReader br = new BufferedReader(reader);        
        String line = """";
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }        
        br.close();
    } // End of main 
} // End of the class //

"
38179237,"Generate 32 digit, 128 bit number by digest function (MD5, 128 bits) in XSLT","I have a sample XML for which I need to generate a reference key using XSLT which will be MD5 code of 128 bits, using the data in the nodes.
The sample Input XML is 
<document>
<party>
    <gtin>1000909090</gtin>
    <pos>
        <attrGroupMany name=""temperatureInformation"">
            <row>
                <attr name=""temperatureCode"">STORADE</attr>
                <attrQual name=""maximumTemperature"" qual=""FAH"">80</attrQual>
                <attrQual name=""minimumTemperature"" qual=""ABC"">10</attrQual>
            </row>
            <row>
                <attr name=""temperatureCode"">HANDLING</attr>
                <attrQual name=""maximumTemperature"" qual=""XYZ"">20</attrQual>
                <attrQual name=""minimumTemperature"" qual=""PQR"">30</attrQual>
            </row>
        </attrGroupMany>
    </pos>
</party>
</document>

Currently the reference key ( as you can see below ) is the simple concat of data but now it needs to be a MD5 key.
<xsl:stylesheet 
version=""1.0""
xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"">

<xsl:output indent=""yes""/>

<xsl:template match=""document""> 
    <CatalogItem>
        <RelationshipData>
            <Relationship>
                <RelationType>SUPPLIER_DATA</RelationType>  
                <RelatedItems>      
                    <xsl:for-each select=""party/pos/attrGroupMany[@name ='temperatureInformation']/row/attrQual"">                       
                        <RelatedItem>
                            <xsl:attribute name=""referenceKey"">
                                <xsl:value-of select=""concat('SUPPLIER_DATA','-',../attr[@name='temperatureCode'],'-',@name,'-',@qual,'-',.    )""/>
                            </xsl:attribute>
                        </RelatedItem>
                    </xsl:for-each>

                </RelatedItems>
            </Relationship>
        </RelationshipData>
    </CatalogItem>

</xsl:template> 

</xsl:stylesheet>

The expected output is 
<?xml version=""1.0"" encoding=""UTF-8""?>
<CatalogItem>
<RelationshipData>
  <Relationship>
     <RelationType>SUPPLIER_DATA</RelationType>
     <RelatedItems>
        <RelatedItem referenceKey=""8c0b1e2856825c8e799904f6f780e651"" />
        <RelatedItem referenceKey=""0700013c4df307fbe3a46ea06e2ad205"" />
        <RelatedItem referenceKey=""4e423d8b26dc91e5166df9a4f25490d5"" />
        <RelatedItem referenceKey=""9a9a1440c113df91314a2a26c31d39f3"" />
     </RelatedItems>
  </Relationship>
</RelationshipData>
</CatalogItem>

I am unaware of how to use external function or deep functionality in XSL. Any inputs or idea or suggestion please share..
"
37562926,File Download SSLHandshakeException,"When I try to programmatically download a file using Java code, I'm getting an exception:
Exception in thread ""main"" javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1949)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1509)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:216)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:979)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:914)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1062)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1375)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1403)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1387)
    at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:559)
    at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:185)
    at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1513)
    at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1441)
    at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:254)
    at java.net.URL.openStream(URL.java:1045)
    at DownloadFileExample.download(DownloadFileExample.java:15)
    at DownloadFileExample.main(DownloadFileExample.java:24)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)
    at sun.security.validator.Validator.validate(Validator.java:260)
    at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)
    at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)
    at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1491)
    ... 20 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:141)
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:126)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)
    ... 26 more

Here is my code including the file I want to download:
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class DownloadFileExample
{
    public static void download(String downloadURL) throws IOException
    {
        URL website = new URL(downloadURL);
        String fileName = ""downloaded.zip"";

        try (InputStream inputStream = website.openStream())
        {
            Files.copy(inputStream, Paths.get(fileName), StandardCopyOption.REPLACE_EXISTING);
        }
    }

    public static void main(String[] arguments) throws IOException
    {
        String downloadURL = ""https://mh-nexus.de/downloads/HxDSetupEN.zip"";
        download(downloadURL);
    }
}

I tried downloading using the HTTP protocol at first but it gives me a 301 moved permanently status code so I realized that it redirects to HTTPS. However, HTTPS gives me the SSLHandshakeException from above. Using a browser, the download works flawlessly. How do I download the file correctly using Java code?
"
1709441,Generate RSA key pair and encode public as string,"I want to generate 512 bit RSA keypair and then encode my public key as a string. How can I achieve this?
"
25122287,java.security.cert.CertPathValidatorException: Trust anchor for certification path not found. Android 2.3,"In my server (production server), I have a goDaddy ssl certificate.
I have both iOS and Android apps connecting with the server, iOS connecting with no problems, android with versions 4.* everything is good, but with devices with 2.3.* I always get a SSLHandshakeException.
I did exactly like on Android Developers page (https://developer.android.com/training/articles/security-ssl.html).
I already saw similar threads here in Stack Overflow (here) but none is helping.
Then I saw this thread talking about Extended Key Usage, but when debugging I get the following information:
[2]: OID: 2.5.29.37, Critical: false
Extended Key Usage: [ ""1.3.6.1.5.5.7.3.1"", ""1.3.6.1.5.5.7.3.2"" ]

So I guess the certificate is not ""forcing"" Extended Key Usage.
Also on this thread there are some other possible causes such as date/time being completely wrong, which are all not existent.
Taking that into consideration, I now don't know where the problem might be.
Any suggestions?
EDIT:
StackTrace below:
08-04 16:54:30.139: W/System.err(4832): Caused by: java.security.cert.CertificateException: java.security.cert.CertPathValidatorException: Trust anchor for certification path not found.
08-04 16:54:30.149: W/System.err(4832):     at org.apache.harmony.xnet.provider.jsse.TrustManagerImpl.checkServerTrusted(TrustManagerImpl.java:161)
08-04 16:54:30.149: W/System.err(4832):     at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.verifyCertificateChain(OpenSSLSocketImpl.java:664)
08-04 16:54:30.149: W/System.err(4832):     at org.apache.harmony.xnet.provider.jsse.NativeCrypto.SSL_do_handshake(Native Method)
08-04 16:54:30.159: W/System.err(4832):     at org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:474)

"
29559215,How can I get the public key of a secure webpage using java,"I need to get the public keys of a secured website programmatically through java. I have read this, this, this and this and others as well. 
But I haven't found a solution of getting it through java.
EDIT:::
Based on Zielu's answer I wrote the following program:
import java.security.PublicKey;
import java.security.cert.Certificate;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

public class RetrievePublicKey {

    private static PublicKey getKey(String hostname, int port) throws Exception {
        SSLSocketFactory factory = HttpsURLConnection.getDefaultSSLSocketFactory();        
        SSLSocket socket = (SSLSocket) factory.createSocket(hostname, port);
        socket.startHandshake();
        Certificate[] certs = socket.getSession().getPeerCertificates();
        Certificate cert = certs[0];
        PublicKey key = cert.getPublicKey();
        System.out.println(key);
        return key;
    }
    public static void main(String[] args) throws Exception {
        System.out.println(getKey(""bctcl-parasuram.bctchn.local"", 8443));
    }

}

But when I run it, i get the following exception:
Exception in thread ""main"" javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.ssl.Alerts.getSSLException(Alerts.java:192)
    at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1937)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:302)
    at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1478)
    at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212)
    at sun.security.ssl.Handshaker.processLoop(Handshaker.java:957)
    at sun.security.ssl.Handshaker.process_record(Handshaker.java:892)
    at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:1050)
    at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1363)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1391)
    at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1375)
    at RetrievePublicKey.getKey(RetrievePublicKey.java:22)
    at RetrievePublicKey.main(RetrievePublicKey.java:30)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:387)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)
    at sun.security.validator.Validator.validate(Validator.java:260)
    at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:324)
    at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:229)
    at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:124)
    at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1460)
    ... 9 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:145)
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:131)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:280)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:382)
    ... 15 more

"
44047862,Generate a DES key and use cipher for encryption,"I want to learn about cryptography with java and I found 
these slides on the internet. On page 9 I found on an example and I tried to use it. However, the following code is not compiling. Where is the mistake? 
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class Gen_DESAES_key{


byte[] message = ""Hello World"".getBytes();

KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
SecretKey desKey = keygenerator.generateKey();

Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
desCipher.init(Cipher.ENCRYPT_MODE,deskey);

byte[] encryptedMessage = desCipher.doFinal(message);
}

"
5980658,How to SHA1 hash a string in Android?,"In Objective C I've been using the following code to hash a string:
-(NSString *) sha1:(NSString*)stringToHash {    
    const char *cStr = [stringToHash UTF8String];
    unsigned char result[20];
    CC_SHA1( cStr, strlen(cStr), result );
    return [NSString stringWithFormat:@""%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X"",
        result[0], result[1], result[2], result[3], 
        result[4], result[5], result[6], result[7],
        result[8], result[9], result[10], result[11],
        result[12], result[13], result[14], result[15],
        result[16], result[17], result[18], result[19]
        ];  
}

Now I need the same for Android but can't find out how to do it. I've been looking for example at this: Make SHA1 encryption on Android?
 but that doesn't give me the same result as on iPhone. Can anyone point me in the right direction?
"
2383322,How to Encrypt in C# .NET same as Java code,"I need to send an encrypted string from a private key to a webserver for authentication.  I have Java client code that generates the encrypted string correctly (such that the webserver can decrypt it with the public key).  I am trying to write C# code to perform the exact same encryption - but have not succeeded.
First a keystore was generated in java using keytool similar to this:
keytool -genkey -dname ""cn=Application Test, ou=XXX, o=YYY, c=US"" -alias AppTest -keypass AppTest -keystore AppTest.jks -storepass AppTest -validity 1800 -keyalg RSA

Then this java code correctly reads the keystore and encrypts the data (privateKey.getAlgorithm() returns ""RSA""):  
KeyStore ks = KeyStore.getInstance(""JKS"");
InputStream is = new FileInputStream(""AppTest.jks"");
ks.load(is, ""AppTest"".toCharArray());
is.close();
PrivateKey privateKey = (PrivateKey) ks.getKey(user, password.toCharArray());

// Encrypt with the private key
String stamp = ""123456"";
byte[] bytesStampUtf8Unencrypted = stamp.getBytes(Charset.forName(""UTF-8""));
Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());
cipher.init(Cipher.ENCRYPT_MODE, privateKey);
byte[] bytesTimestampUtf8Encrypted = cipher.doFinal(bytesStampUtf8Unencrypted);
String encrypted = new String((new Base64()).encode(bytesStampUtf8Unencrypted));

This all works great when passed to the web service.  I then used keytool to convert from the java keystore to an PKCS12 certificate for use in my .NET application:
keytool -importkeystore -srckeystore AppTest.keystore -destkeystore KEYSTORE.p12  -srcstoretype JKS -deststoretype PKCS12 -srcstorepass AppTest -deststorepass AppTest-srcalias AppTest -destalias AppTest -srckeypass AppTest -destkeypass AppTest -noprompt

Using keytool I compared the finger prints of the keystore and P12 files - identical.  I thought the following C# code should work:
X509Certificate2 myCertificate =
   new X509Certificate2(@""C:\Temp\KEYSTORE.p12"", ""AppTest"");
RSACryptoServiceProvider privateKey =
   myCertificate.PrivateKey as RSACryptoServiceProvider;
String stamp = ""123456"";
byte[] buffer = Encoding.UTF8.GetBytes(stamp);
byte[] encryptedBytes = privateKey.Encrypt(buffer, false);
String encrypted = Convert.ToBase64String(encryptedBytes);

It reads the converted keystore file correctly, executes without problem, and generates what appears to be encrypted data, but the web service does NOT like the encrypted string (can't decrypt with the public key).  When I replaced the C# encrypted string with the Java encrypted one (in the debugger) and sent that string through the C# program to the web service - it all worked as well - so I am confident the problem is in the encryption process, and not in the web service communication.
I have no control over the way the original key was generated (as a java keystore), nor what encryption method is expected by the web service.    I can only control the .NET client that interacts with the Java based web service.
Am I missing some flag, setting, variable, what?
"
6547214,Java decrypt error: data not block size aligned,"I'm trying to encrypt data between my android application and a PHP webservice.
I found the next piece of code in this website: http://schneimi.wordpress.com/2008/11/25/aes-128bit-encryption-between-java-and-php/
But when I try to decrypt I get the Exception of the title ""data not block size aligned""
This are the method in my MCrypt class
public String encrypt(String text) throws Exception
{
    if(text == null || text.length() == 0)
        throw new Exception(""Empty string"");

    Cipher cipher;
    byte[] encrypted = null;

    try {
        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e)
    {           
        throw new Exception(""[encrypt] "" + e.getMessage());
    }

    return new String( encrypted );
}

public String decrypt(String code) throws Exception
{
    if(code == null || code.length() == 0)
        throw new Exception(""Empty string"");

    Cipher cipher;
    byte[] decrypted = null;

    try {
        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e)
    {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return new String( decrypted );
}


private static byte[] hexToBytes(String hex) {
  String HEXINDEX = ""0123456789abcdef"";
  int l = hex.length() / 2;
  byte data[] = new byte[l];
  int j = 0;

  for (int i = 0; i < l; i++) {
    char c = hex.charAt(j++);
    int n, b;

    n = HEXINDEX.indexOf(c);
    b = (n & 0xf) << 4;
    c = hex.charAt(j++);
    n = HEXINDEX.indexOf(c);
    b += (n & 0xf);
    data[i] = (byte) b;
  }

  return data;
}

private static String padString(String source)
{
  char paddingChar = ' ';
  int size = 16;
  int x = source.length() % size;
  int padLength = size - x;

  for (int i = 0; i < padLength; i++)
  {
      source += paddingChar;
  }

  return source;
}

And this is how I'm using it in my activity to test:
String encrypted = mcrypt.encrypt(jsonUser.toString());
String decrypted = mcrypt.decrypt(encrypted);

the encrypt method works fine, but the second throws an exception.
"
5520640,Encrypting and Decrypting Using Java: Unable to get same output,"I am trying to learn and test the java 1.6 encryption/decryption API. I want to know what I am doing wrong and what I am missing in terms of knowledge. 
In the code that follows below, I create two ciphers: one to encrypt and another to decrypt. When I use these ciphers, I initialize them with different SecretKey's, but I am still able to get the same value back out. Why is this?
    String algorithm = ""DES"";
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);

    byte[] encBytes = ""12345678"".getBytes(""UTF8"");
    byte[] decBytes = ""56781234"".getBytes(""UTF8"");

    DESKeySpec keySpecEncrypt = new DESKeySpec(encBytes);
    DESKeySpec keySpecDecrypt = new DESKeySpec(decBytes);


    SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);
    SecretKey keyDecrypt = keyFactory.generateSecret(keySpecDecrypt);

    Cipher cipherEncrypt = Cipher.getInstance(algorithm);
    Cipher cipherDecrypt = Cipher.getInstance(algorithm);

    String input = ""john doe"";

    cipherEncrypt.init(Cipher.ENCRYPT_MODE, keyEncrypt);
    byte[] inputBytes = cipherEncrypt.doFinal(input.getBytes());
    System.out.println(""inputBytes: "" + new String(inputBytes));

    cipherDecrypt.init(Cipher.DECRYPT_MODE, keyDecrypt);
    byte[] outputBytes = cipherDecrypt.doFinal(inputBytes);
    System.out.println(""outputBytes: "" + new String(outputBytes));

"
3483582,How to create OAuth HMAC-SHA1 signature on GAE/J?,"EDIT: java equivalent to php's hmac-SHA1
(well hopefully, trying a.t.m.)
My understanding is that to create a signature I need a 'base string' and a 'key'. I guess I know how to create the base string, and I assume I'm supposed to use 'OAuth Consumer Secret' that Google have assigned to my app as the key.
But what am I supposed to do with these two to obtain the signature? Is there any HMAC-class on GAE/Java?
Would it play if I just stored somewhere what OAuth Playground generates for me? Is it how you do it? Or does OAuth signature have some expiration date?
(I tried AuthSub before but failed too, even though it looks quite simple. Also OAuth seems like more 'standard' to me, so I'd like to stick with OAuth.)
"
11783062,How to decrypt file in Java encrypted with openssl command using AES?,"I need to decrypt in JAVA a file encrypted in UNIX with the following command:
openssl aes-256-cbc -a -salt -in password.txt -out password.txt.enc
mypass
mypass

I have to decrypt in java as I do here I do in UNIX
openssl aes-256-cbc -d -a -in password.txt.enc -out password.txt.new
mypass

Someone can give me a java code to do this?
"
992019,Java 256-bit AES Password-Based Encryption,"I need to implement 256 bit AES encryption, but all the examples I have found online use a ""KeyGenerator"" to generate a 256 bit key, but I would like to use my own passkey. How can I create my own key? I have tried padding it out to 256 bits, but then I get an error saying that the key is too long. I do have the unlimited jurisdiction patch installed, so thats not the problem :)
Ie. The KeyGenerator looks like this ...
// Get the KeyGenerator
KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
kgen.init(128); // 192 and 256 bits may not be available

// Generate the secret key specs.
SecretKey skey = kgen.generateKey();
byte[] raw = skey.getEncoded();

Code taken from here
EDIT
I was actually padding the password out to 256 bytes, not bits, which is too long. The following is some code I am using now that I have some more experience with this.
byte[] key = null; // TODO
byte[] input = null; // TODO
byte[] output = null;
SecretKeySpec keySpec = null;
keySpec = new SecretKeySpec(key, ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
cipher.init(Cipher.ENCRYPT_MODE, keySpec);
output = cipher.doFinal(input)

The ""TODO"" bits you need to do yourself :-)
"
10842350,Java AES CBC Decryption,"PHP Encrypt Function
$privateKey = ""1234567812345678"";
$iv = ""1234567812345678"";
$data = ""Test string"";

$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_CBC, $iv);

echo(base64_encode($encrypted));

Result: iz1qFlQJfs6Ycp+gcc2z4w==

When I try to decrypt this result in Java using the function below, all I get back is ì�š@ÔBKxnfÈ~¯Ô'M  while I am expecting ""Test string"". Any ideas where I am wrong? Thanks
public static String decrypt() throws Exception{
    try{
        String Base64EncodedText = ""iz1qFlQJfs6Ycp+gcc2z4w=="";
        String decodedText = com.sun.xml.internal.messaging.saaj.util.Base64.base64Decode(Base64EncodedText);
        String key = ""1234567812345678"";
        String iv = ""1234567812345678"";

        javax.crypto.spec.SecretKeySpec keyspec = new javax.crypto.spec.SecretKeySpec(key.getBytes(), ""AES"");
        javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv.getBytes());

        javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(javax.crypto.Cipher.DECRYPT_MODE, keyspec, ivspec);
        byte[] decrypted = cipher.doFinal(decodedText.getBytes());

        String str = new String(decrypted);

        return str;

    }catch(Exception e){
        return null;
    }   
}

"
11864696,How to create Java Key Store (.jks) file with AES encryption,"Reading Oracle documentation, I see that by default JKS files are encrypted using PBEWithMD5AndTripleDES. While DES alone makes me feel uneasy, MD5 lights a big red light. I'd like to use PBEWithSHA256And256BitAES-CBC-BC or PBEWithSHA256And128bitAES-CBC-BC to encrypt private keys.
Do I have to write new Cryptography Service Provider implementing whole KeyStore interface or is it possible to parametrise the creation of KeyStore (either using plain java or BouncyCastle)?
EDIT:
A little bit of background.
I know that 3DES isn't broken, just as is MD5 used as KDF (or in PBE). The problem is, that this is the situation for now. For all we know, MD5 may be broken to the level MD4 is broken tomorrow. My application life is at least 10 years, and it's very likely it's much more. Somehow I don't see people after those 10 years delving deep into working crypto code just because it may not be secure. One just needs to look at last few of the big ""mishaps"" with password leaks to see how likely is that, and that were obvious things to anyone that saw the raw database.
That being said: NSA crypto suite B allows only AES for symmetric encryption, of any kind. 
NIST list only SHA-1 and SHA-2 algorithms for HMAC and KDF use, while SHA-1 use is not recommended. Suite B allows only SHA-2 hash functions. Those algorithms are publicly available, so why shouldn't I use them?
"
11116143,SHA256withRSA sign from PHP verify from JAVA,"For my current project I have to send a signature from PHP to Java application. I am using Crypt/RSA right now for signing my data. 
For test I am signing just ""abc"" with following code : 
$rsa = new Crypt_RSA();
$plaintext = 'abc';

    $rsa->loadKey(""MIICXgIBAAKBgQDjh+hNsqJe566JO0Sg7Iq5H1AdkauACdd8QMLp9YNY0HPslVH0
rXaOFo0zgH0Ktu/Ku3lS1lfxbFQAY8b6ywZKvu4eoxlnEwuBwy09CG+3ZiVLBjCj
TZHA/KOkpVLa+tA6KsoP6zv/xI/ACkSCxPGR0q3SiRuhXV/6tacoKxUYnwIDAQAB
AoGBAIC00GOjONYWmFRoglnFdHNjkx4m2KyE5LAUsi1GBBapU+nwTXvq47VcbGNF
u3XkJaC4i9igBv86GApgZp5XWia86On/Lz9NR4fB2EFP6Ydy84GfCDNNvkism4BR
aA+eYdNiQ3Wfyi98ZpUi+rPsoI6Cid4eSkCC4poTUaqzMkiBAkEA9Gn1oIlUEoVI
q/u5Y9vflXRDt95AA9AokJkQj7XTNjsz8ypU8TO6D6ZykpcbK6zjU0UJsQiC3dKj
AgmAR2VzYwJBAO5RETMAyDnR+5g+MtHpwGqGdY4dq0j4y4CsdtOYKWwSTh3VQy+C
eghJoyPRfIpulw2Mk/l+occEI0ohJl0+UJUCQQDSZtjVLwMZwnUx4EvSw/ewL9sP
0Jpo7evNtoaEQDEncUWiYeGnljDowg/FU6FHMtiq2TajmMEXdflvioBMdfAjAkEA
3TB60SbJr/i4Fo6sJm5ZO8W+eAALiTf50VzBERTqZTb8L+5PZFoqn2SROV5mxClu
o5G1idzBlHC/vD7WV7bNnQJAd0FrxaMBurJ4Uv/B8TDP+eeBdB7d9rKw0+TVlcel
cbpIz6BIP6+nmsgy6dbDRnx0eC/MgF2EU0wrCu1DK0PyWA=="");
    $rsa->setHash(""sha256"");
    $signature = $rsa->sign($plaintext);

$signature_encoding = mb_convert_encoding($signature, ""UTF-8"");
    error_log(""signature encoded in UTF-8 :"" . $signature_encoding);

    $encoded_sign = base64_encode($signature_encoding);
    error_log(""encoded sign for abc: "" . $encoded_sign);

I can verify the signature from php code. But when it comes to verifying from JAVA, i was not successfull. Here is the java code that does the verify operation : 
public boolean verify(String signed, String data, PubKey pubKey) throws Exception{

    PublicKey publicKey = jceProvider.generateRSAPublicKeyFromX509(
            base64.decode(pubKey.getEncodedKey())
    );

    byte[] signature = base64.decode(signed);
    byte[] verifier = data.getBytes(Charset.forName(""UTF-8""));

    return jceProvider.verify(signature, verifier, publicKey);

}

public class JCEProvider {

    public boolean verify (byte[] signature, byte[] verifier, PublicKey publicKey) throws Exception{

        Signature rsaSignature = Signature.getInstance(""SHA256withRSA"");

        rsaSignature.initVerify(publicKey);
        rsaSignature.update(verifier);

        return rsaSignature.verify(signature);

    }

I dont think it is because of keys, I can already verify it from PHP as I told before. There is something that I miss about PHP encoding or byte streams but I am lost for the moment. 
Any help would be appreciated.
"
10221411,need Help in RSA ENCRYPTION(doFinal),"i am trying to encrypt and decrypt a string using RSA algorithm. Here the encryption is working good but problem is in decryption.
   the code gets terminated when it reaches the doFinal in DECRYPT method.
Am i taking the input wrong or is there any problem with public and private keys?
please give me suggestions regarding this.
Thank u.
public class rsa 
{   
 private KeyPair keypair;       

 public rsa() throws NoSuchAlgorithmException, NoSuchProviderException 
    {
        KeyPairGenerator keygenerator = KeyPairGenerator.getInstance(""RSA"");
        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");
        keygenerator.initialize(1024, random);
        keypair = keygenerator.generateKeyPair();
    }
public String ENCRYPT(String Algorithm, String Data ) throws Exception
{   
    String alg = Algorithm;
    String data=Data;
    byte[] encrypted=new byte[2048];
    if(alg.equals(""RSA""))
    {   

        PublicKey publicKey = keypair.getPublic();
        Cipher cipher;
        cipher = Cipher.getInstance(""RSA"");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
         encrypted = cipher.doFinal(data.getBytes());
        System.out.println(""Encrypted String[RSA] -> "" + encrypted);
    }
    return encrypted.toString();
}
public String DECRYPT(String Algorithm, String Data ) throws Exception
{   
    String alg = Algorithm;
    byte[] Decrypted=Data.getBytes();


    if(alg.equals(""RSA""))
    {   

        PrivateKey privateKey = keypair.getPrivate();
        Cipher cipher;  
        cipher = Cipher.getInstance(""RSA"");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] dec = cipher.doFinal(Decrypted);

        System.out.println(""Decrypted String[RSA] -> "" + dec.toString());

    }
    return Decrypted.toString();
}
public static void main(String[] args) throws Exception
{
    rsa RSA=new rsa();
    RSA.ENCRYPT(""RSA"", ""avinash"");
    RSA.DECRYPT(""RSA"",""[B@cb7e2c"");
}

}
 got exception as

Exception in thread ""main"" javax.crypto.BadPaddingException: Data must start with zero
at sun.security.rsa.RSAPadding.unpadV15(Unknown Source)
at sun.security.rsa.RSAPadding.unpad(Unknown Source)
at com.sun.crypto.provider.RSACipher.doFinal(RSACipher.java:356)
at com.sun.crypto.provider.RSACipher.engineDoFinal(RSACipher.java:382)
at javax.crypto.Cipher.doFinal(Cipher.java:2086)
at EncryptionProvider.rsa.DECRYPT(rsa.java:56)
at EncryptionProvider.rsa.main(rsa.java:68)

Encrypted String[RSA] -> [B@4a96a
"
13433529,Android 4.2 broke my encrypt/decrypt code and the provided solutions don&#39;t work,"First of all, I've already seen 
Android 4.2 broke my AES encrypt/decrypt code
and
Encryption error on Android 4.2
and the provided solution:
SecureRandom sr = null;
if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {
    sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
} else {
    sr = SecureRandom.getInstance(""SHA1PRNG"");
}

doesn't work for me, because, when decoding data encrypted in Android<4.2 in Android 4.2, I get:
javax.crypto.BadPaddingException: pad block corrupted
at com.android.org.bouncycastle.jcajce.provider.symmetric.util.BaseBlockCipher.engineDoFinal(BaseBlockCipher.java:709)

My code is quite simple, and was working until Android 4.2:
public static byte[] encrypt(byte[] data, String seed) throws Exception {

    KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
    SecureRandom secrand = SecureRandom.getInstance(""SHA1PRNG"");
    secrand.setSeed(seed.getBytes());
    keygen.init(128, secrand);

    SecretKey seckey = keygen.generateKey();
    byte[] rawKey = seckey.getEncoded();

    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    return cipher.doFinal(data);
}

public static byte[] decrypt(byte[] data, String seed) throws Exception {

    KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
    SecureRandom secrand = SecureRandom.getInstance(""SHA1PRNG"");
    secrand.setSeed(seed.getBytes());
    keygen.init(128, secrand);

    SecretKey seckey = keygen.generateKey();
    byte[] rawKey = seckey.getEncoded();

    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    return cipher.doFinal(data);
}

My guess is that the default provider wasn't the only thing that changed in Android 4.2, otherwise my code would work with the proposed solution.
My code was based on some post I found here at StackOverflow a long time ago; I see that it differs from the mentioned posts as it just crypts and decrypts byte arrays, whereas the others solutions crypt and decrypt Strings (HEX Strings, I think).
Does it have to do with the seed? Does it have a min/max length, restriction of chars, etc?
Any idea / solution?
EDIT:
After a lot of tests, I see that there are 2 problems:

The provider changed in Android 4.2 (API 17) -> This one is easy to fix, just apply the solution I mentioned at top of the post
BouncyCastle changed from 1.34 to 1.45 in Android 2.2 (API 8)->Android2.3 (API 9), so the decryption problem I previously told is the same as described here: BouncyCastle AES error when upgrading to 1.45 

So now the question is: is there any way to recover data crypted in BouncyCastle 1.34 in BouncyCastle 1.45+?
"
18573573,AES 512 bit encryption with Android,"Is it possible to do AES 512-bit Encryption with Android app for user credential?
Has Anyone tried this?
I search a lot about this but did not get the Help.
Any Help is Appreciated.
Thanks
"
17972024,Java BouncyCastle Cast6Engine (CAST-256) encrypting,"I'm trying to implement a function that receives a string and returns the encoded values of the String in CAST-256. The following code is what i implement following the example on BoncyCastle official web page (http://www.bouncycastle.org/specifications.html , point 4.1).
import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.engines.CAST6Engine;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Base64;


public class Test {

    static{
        Security.addProvider(new BouncyCastleProvider());
    }

    public static final String UTF8 = ""utf-8"";
    public static final String KEY = ""CLp4j13gADa9AmRsqsXGJ"";

    public static byte[] encrypt(String inputString) throws UnsupportedEncodingException {
        final BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CAST6Engine());
        byte[] key = KEY.getBytes(UTF8);
        byte[] input = inputString.getBytes(UTF8);
        cipher.init(true, new KeyParameter(key));

        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];

        int outputLen = cipher.processBytes(input, 0, input.length, cipherText, 0);
        try {
            cipher.doFinal(cipherText, outputLen);
        } catch (CryptoException ce) {
            System.err.println(ce);
           System.exit(1);
        }
        return cipherText;
    }

    public static void main(String[] args) throws UnsupportedEncodingException {
        final String toEncrypt = ""hola"";
        final String encrypted = new String(Base64.encode(test(toEncrypt)),UTF8);
        System.out.println(encrypted);
    }

}

But , when i run my code i get 
QUrYzMVlbx3OK6IKXWq1ng== 
and if you encode hola in CAST-256 with the same key ( try here if you want http://www.tools4noobs.com/online_tools/encrypt/) i should get 
w5nZSYEyA8HuPL5V0J29Yg==.
What is happening? Why im getting a wront encrypted string? 
I'm tired of find that on internet and didnt find a answer.
"
17079579,AES algo - Decryption Issue,"I have written code for AES decryption, but did not have any success.
My AES algo class is here.
http://pastebin.com/QtpFnW84
and implementation is :
String Masterkey = ""eX0XcsF8lkeX0XcsF8lkeX0XcsF8lkeX0XcsF8lkeX0XcsF8lk"";
    try {
        String s = AES_Algo
                .decrypt(
                        Masterkey,
                        ""LVmDIcmVIuNVPObjLXkVbFc13NCX1Md3DjrvfiioMQHS7QmizT3dlSujgA7NS0zI HEweRWGcwOKpu0wurK495yCTWkJO33X1n+at60xLdJ7ZUreRWN9RatUjRQuLI7Ft kwH7QMTQAYXQizGJ0HrArja8QA/YnkiGpgO0pdmYm9Mb6g/sIXhz1Oeo42uwzTM1 F+t6AM/qrH9ZMozlctU6LQQVIggP8zzmnwvjNCyyYJCsXedOEMcvrpQV100gz+pf cE4RisPgN0IOKzvzepJ88E3VMPCXBv/AV4Z2/fuBcmimzGdvZwKgYM/39TGNBS7t T491knA3ZdMoAnSPFvdM4khfRyM5I9FJpwDxmpykA4VpBUhyd4p+ZS1ZSQ8Zwi3I 5egtoNkSJhI6pjAR7PbzJtJ+VAWCVIdsFP4Kc+KKPBE0HVS5UiQQ+OJjx2r9iMMR OYqeyqMv8xw3Wy7TBMiKnQMCRo5+K1mDabx164+6cfoKk8+6b5WlNfBQVobZpQs2"");
        Log.e(""s"", s);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }

Each time i am getting exception :
06-13 05:03:43.013: W/System.err(1757): java.lang.NumberFormatException: unable to parse 'LV' as integer
06-13 05:03:43.043: W/System.err(1757):     at java.lang.Integer.parse(Integer.java:433)
06-13 05:03:43.043: W/System.err(1757):     at java.lang.Integer.parseInt(Integer.java:422)
06-13 05:03:43.043: W/System.err(1757):     at java.lang.Integer.valueOf(Integer.java:704)
06-13 05:03:43.043: W/System.err(1757):     at com.caddytips.AES_Algo.toByte(AES_Algo.java:76)
06-13 05:03:43.043: W/System.err(1757):     at com.caddytips.AES_Algo.decrypt(AES_Algo.java:32)

Can anybody help me please? 
Thanks in advance.
"
15669550,Get SHA1 of HexString like HashCalc does,"HashCalc has, at the top, a field called ""Data Format"" I switch that to ""HexString"" then type in test value of 9a in the data field. I run a SHA-1 hash on it and the answer is:13cba177bcfad90e7b3de70616b2e54ba4bb107f
(NOTE: online hashers will hash ""9a"" as a string resulting in an answer of e8eef065fb7295044d65b305bab18a9a645d1abf. Which is wrong for this application)
Now, I need to embed this type of hashing into my Java program. This is what I got so far (wrapped in try/catch):
String ss = ""9a"";
ByteBuffer bb = ByteBuffer.allocate(8);  
byte[] ba = bb.putLong(Long.decode(""0x""+ss).longValue()).array();
MessageDigest md = MessageDigest.getInstance(""SHA-1"");
String results = encodeHex(md.digest(ba));
System.out.println(""sha:""+results);

However, my result is E73C417858807239DD5BC30BA978C14D57F80834
What am I doing wrong? 
EDIT: Added Hex tag back, it seems obvious that the data has to be in some sort of hex format. As HashCalc has to be set to ""HexString"" and not ""TextString"" which returns a different result. And the solution could well include a change to how Im dealing with these hex numbers. --> which turned out to be true
"
20929105,PHP + Android XML Encryption/Decryption,"I have an app that is downloading and parsing an xml into an sql database. My problem is that the data from the xml once the app is deployed could easily be scraped and other people could use my hard earned data for their own evil purposes/apps. Basically I need to encrypt the xml using php, and then decrypt it using android. I've seen a couple of php classes that make it easy to encrypt but I'm not entirely sure what method to encrypt would be compatible with android. 
Edit after solution:
At first I thought I had to ignore brackets for some reason and was going to iterate through all the text and spit out formatted xml lol. Much simpler than that.
$mcrypt = new MCrypt();
$datainxml = file_get_contents(""data.xml"");
$cipher = $mcrypt->encrypt($value);
echo $cipher;

"
24338108,Java - Encrypt String with existing public key file,"I've been researching this for the past 4-5 hours now and can't seem to find an answer that actually works despite finding 'answers' that used everything from a few methods to an entire ~100 line class. I can't imagine that there isn't some simple function to do such a trivial thing :P
I have a pre-existing set of public / private keys (actually, two sets - one generated by ssh-keygen and another by openssl so .. whatever format works is cool). 
All I am after is a simple java equivalent to what I write in python like -
key_object = someModule.KeyObject(nameOfPublicKeyFile)

def encrypt (SomePlainText) :
  return someOtherModule.encrypt(key_object, SomePlainText)

Any help would be awesome!
"
23374233,Which hashing algorithms are available in Android?,"This question might sound a little bit stupid, but there's a lack of documentation.
In order to hash strings in Android, we can use MessageDigest, which is from java.security package.
However, the basic setup is like the following:
MessageDigest.getInstance( ""SHA-512"" );

Which is not cool, therefore:

Can we know which algorithms are available on the current device? What does it depend on? Android SDK? Java SDK? This is painful in Android, because of the segmentation we've to handle...
Why the hell don't we have a Constant / Enum for that string??? Aren't them common for the whole world?

I hope you can answer both of my questions.
Thanks.
"
22201511,AES decryption gives wrong results,"I'm trying to encrypt a string in Android app and then decrypt it in ASP.Net server. I'm not getting any errors but decryption doesn't return true results. Here is Android side:
public void clckBtn(View v) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(
                    ""MyDifficultPassw"".getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(""tryToEncrypt"".getBytes());
            System.out.println(toHex(encrypted));

        } catch (Exception e) {
            System.out.println(e.toString());
        }

    }


    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
    }

The output is: CE3E99F50E6D30201E38D4955F07BA7C
Asp.Net side :
 protected void Page_Load(object sender, EventArgs e)
        {
            using (Aes myAes = Aes.Create())
            {
                string asd = DecryptStringFromBytes_Aes(GetBytes(""CE3E99F50E6D30201E38D4955F07BA7C""), GetBytes(""MyDifficultPassw""), myAes.IV);
                int we = 0;
            }

        }

        static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key
, byte[] IV)
        {
            // Check arguments. 
            if (cipherText == null || cipherText.Length <= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length <= 0)
                throw new ArgumentNullException(""Key"");

            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an Aes object 
            // with the specified key and IV. 
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                aesAlg.Padding = PaddingMode.None;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key
, aesAlg.IV);



                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {

                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt
, decryptor, CryptoStreamMode.Read))
                    {

                        using (StreamReader srDecrypt = new StreamReader(
csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting 

                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }

        static byte[] GetBytes(string str)
        {
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }

In Asp.Net Aes class requires a IV (initialization vector). In Android there is no such thing. I think the problem is something about that.
"
6486121,Why is the ciphertext 32 bytes long when encrypting 16 bytes with AES?,"I use encryption AES algorithm, when i encrypt 16 byte(one block) the result is 32 byte.
Is this ok?
My source code that i used is:
package net.sf.andhsli.hotspotlogin;

import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

/**
 * Usage:
 * <pre>
 * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)
 * ...
 * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)
 * </pre>
 * @author ferenc.hechler
 */
public class SimpleCrypto {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
    }

}

"
28622438,AES-256 Password Based Encryption/Decryption in Java,"I found a guide for implementing AES encryption/decryption in Java and tried to understand each line as I put it into my own solution.  However, I don't fully understand it and am having issues as a result.  The end goal is to have passphrase based encryption/decryption. I've read other articles/stackoverflow posts about this, but most do not provide enough explanation (I am very new to crypto in Java)
My main issues right now are that even when I set byte[] saltBytes = ""Hello"".getBytes(); 
I still get a different Base64 result in the end (char[] password is random each time, but I read that it is safer to leave passwords in char[] form.  My other problem is that when the program gets to decrypt(), I get a NullPointerException at
 byte[] saltBytes = salt.getBytes(""UTF-8"");
Thank you in advance for any help/advice you can give me.
The code in question:
import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    public static void main(String []args) throws Exception {

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + message.toString());
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {

        salt = getSalt();
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        SecretKey secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(plaintext.toString().getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        byte[] saltBytes = salt.getBytes(""UTF-8"");
        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(encryptedText.toString());

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(encryptedText, saltBytes, iterations, keySize);
        SecretKey secretkey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretkey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return decryptedTextBytes.toString();

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return salt.toString();
    }
}

"
26633349,Disable SSL as a protocol in HttpsURLConnection,"Due to the POODLE vulnerability, my server, hosted in Amazon AWS does no longer support SSLv3.
As a result, the first HTTPS connection my Android app does against the server results in an error when the connection was being established.
Error reading server response: javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x77d8ab68: Failure in SSL library, usually a protocol error
error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure (external/openssl/ssl/s23_clnt.c:741 0x7339ad74:0x00000000)
       [....]
Caused by: javax.net.ssl.SSLHandshakeException: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x77d8ab68: Failure in SSL library, usually a protocol error
error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure (external/openssl/ssl/s23_clnt.c:741 0x7339ad74:0x00000000)
       at com.android.org.conscrypt.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:448)
       at com.android.okhttp.Connection.upgradeToTls(Connection.java:146)
       at com.android.okhttp.Connection.connect(Connection.java:107)
       at com.android.okhttp.internal.http.HttpEngine.connect(HttpEngine.java:294)
       at com.android.okhttp.internal.http.HttpEngine.sendSocketRequest(HttpEngine.java:255)
       at com.android.okhttp.internal.http.HttpEngine.sendRequest(HttpEngine.java:206)

The error happens only in the first request. Subsequent requests work for some time.
To fix this I'm trying to remove SSL from the list of protocols accepted by the Android client, and ensure I'm going only with TLS. 
To do this, I set a custom SSLSocketFactory which removes SSL from the list of enabled protocols and supported cypher suites.
/**
 * SSLSocketFactory that wraps one existing SSLSocketFactory and delegetes into it adding
 * a new cipher suite
 */
public class TLSOnlySocketFactory extends SSLSocketFactory {

    private final SSLSocketFactory delegate;

    public TLSOnlySocketFactory(SSLSocketFactory delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getDefaultCipherSuites() {

        return getPreferredDefaultCipherSuites(this.delegate);
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return getPreferredSupportedCipherSuites(this.delegate);
    }



    @Override
    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        final Socket socket = this.delegate.createSocket(s, host, port, autoClose);

        ((SSLSocket)socket).setEnabledCipherSuites(getPreferredDefaultCipherSuites(delegate));
        ((SSLSocket)socket).setEnabledProtocols(getEnabledProtocols((SSLSocket)socket));

        return socket;
    }



   [.....]

        ((SSLSocket)socket).setEnabledCipherSuites(getPreferredDefaultCipherSuites(delegate));
        ((SSLSocket) socket).setEnabledProtocols(getEnabledProtocols((SSLSocket)socket));

        return socket;
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        final Socket socket = this.delegate.createSocket(host, port);

        ((SSLSocket)socket).setEnabledCipherSuites(getPreferredDefaultCipherSuites(delegate));
        ((SSLSocket) socket).setEnabledProtocols(getEnabledProtocols((SSLSocket)socket));

        return socket;
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        final Socket socket = this.delegate.createSocket(address, port, localAddress, localPort);

        ((SSLSocket)socket).setEnabledCipherSuites(getPreferredDefaultCipherSuites(delegate));
        ((SSLSocket) socket).setEnabledProtocols(getEnabledProtocols((SSLSocket)socket));

        return socket;
    }

    private String[] getPreferredDefaultCipherSuites(SSLSocketFactory sslSocketFactory) {
        return getCipherSuites(sslSocketFactory.getDefaultCipherSuites());
    }

    private String[] getPreferredSupportedCipherSuites(SSLSocketFactory sslSocketFactory) {
        return getCipherSuites(sslSocketFactory.getSupportedCipherSuites());
    }

    private String[] getCipherSuites(String[] cipherSuites) {
        final ArrayList<String> suitesList = new ArrayList<String>(Arrays.asList(cipherSuites));
        final Iterator<String> iterator = suitesList.iterator();
        while (iterator.hasNext()) {
            final String cipherSuite = iterator.next();
            if (cipherSuite.contains(""SSL"")) {
                iterator.remove();
            }
        }
        return suitesList.toArray(new String[suitesList.size()]);
    }

    private String[] getEnabledProtocols(SSLSocket socket) {
        final ArrayList<String> protocolList = new ArrayList<String>(Arrays.asList(socket.getSupportedProtocols()));
        final Iterator<String> iterator = protocolList.iterator();
        while (iterator.hasNext()) {
            final String protocl = iterator.next();
            if (protocl.contains(""SSL"")) {
                iterator.remove();
            }
        }
        return protocolList.toArray(new String[protocolList.size()]);
     }

}

As you see, my SSLSocketFactory delegates into another SSLSocketFactory and what it does is simply removing SSL from the list of enabled protocols.
I establish this factory as
final TLSOnlySocketFactory tlsOnlySocketFactory = new TLSOnlySocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
HttpsURLConnection.setDefaultSSLSocketFactory(tlsOnlySocketFactory);

This does NOT fix the issue. From time to time, I still see the error when the connection was established. Oddly enough, this does not fix it, but it clearly minimises the occurrences of the issue.
How could I force the HttpsUrlConnection in my Android client to use only TLS?
Thank you.
"
26849580,Alternative to using SecureRandom to generate AES key and IV,"I am trying to encrypt text using the AES encryption algorithm , save this encrypted text to a file and then reopen later and decrypt these. Following is my encryption and decryption logic
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    byte[] stringBytes = clear_text.getBytes();
    byte[] raw = cipher.doFinal(stringBytes);
    return Base64.encodeBase64String(raw);

And this is the decryption logic 
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key, iv);
    byte[] raw = Base64.decodeBase64(encText);
    byte[] stringBytes = cipher.doFinal(raw);
    String clear_text = new String(stringBytes, ""UTF8"");
    return clear_text;

I get a BadPaddingSize exception. My guess is that by using the SecureRandom class, both the methods use different keys while encrypting or decypting text. Is there a way I can use the same key in both the routines?
"
25121868,MD5 SHA512Managed c# conversion to Java code,"I need help to convert this code to Java for password comparison and it must run on Android.
I am specially confused in how to add the salt given in this C# Code here:
Code C#
using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace CMS.Core.Utility
{
    public sealed class CMSHashManager
    {
        private static readonly string _salt = ""3D5900AE-111A-45BE-96B3-D9E4606CA793"";
        private static readonly int _hashIterationsMax = 10;
        private CMSHashManager()
        {
        }

        #region Public Methods
        //Gets the salted hash value with predetermined iterations.
        public static string GetPasswordHash(string plaintextPassword)
        {
            string hashData = plaintextPassword;
            for (int hashLimit = 0; hashLimit < _hashIterationsMax; hashLimit++)
                hashData = GetHash(_salt + hashData);
            return hashData;
        }

        //Verifies the hash
        public static bool VerifyHashedPassword(string plaintextPassword, string encryptedPassword)
        {
            string hashData = GetPasswordHash(plaintextPassword);
            return encryptedPassword.Equals(hashData);
        }

        #endregion Public Methods

        #region Private Methods
        //Gets the hash value of the data using SHA512Managed
        private static string GetHash(string unhashedData)
        {
            byte[] hashData = Encoding.UTF8.GetBytes(unhashedData);
            // on server 2003 or higher, can use SHA512CryptoServiceProvider         
            //SHA512CryptoServiceProvider sha512CryptoServiceProvider = new SHA512CryptoServiceProvider();

            SHA512Managed sha512CryptoServiceProvider = new SHA512Managed();
            hashData = sha512CryptoServiceProvider.ComputeHash(hashData);
            sha512CryptoServiceProvider.Clear();
            return Convert.ToBase64String(hashData);
        }
        #endregion Private Methods

    }

}

I have already written this java method which creates a MD5 hash:
Code Java
public String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{
    MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-512""); 
    digest.update(password.getBytes(""UTF-16LE"")); 
    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i = 0; i < messageDigest.length; i++) {
        String h = Integer.toHexString(0xFF & messageDigest[i]);
        while (h.length() < 2)
            h = ""0"" + h;
        hexString.append(h);
    }
    return hexString.toString();
}

Test
For testing purposes you can use the following case:
plaintext:12345
Encrypted:NgkuakH7UsCQwGHMQOhVXI3nW6M+1AtREY4Qx35osQo87p/whZIzy8cZU7+R7XnmyzgMzLWSvX+rTiW‌​‌​zfGTPsA==
"
34074485,java.io.file help selecting multiple files from folder and listing hash values,"The ﬁrst program should take two inputs as arguments: directory1 and directory2. the program should compute a hash value (using HMAC) for each ﬁle in the folder directory1 and store that hash value in a new ﬁle that will be saved under the folder directory2.
(b). The second program should perform the veriﬁcation process. It also takes the same two input arguments as the ﬁrst program. It should generate hashes again (you can reuse some code from the ﬁrst program here) and check whether they are matching with the corresponding values stored in directory2. For each ﬁle, this program should output two strings: the ﬁlename and YES/NO (denoting whether the hashes matched or not)
i have done some work which will generate hash value of a single file from one folder and i need help in generating hash value of all files from that folder these are the codes as follows. 
Function
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.security.MessageDigest;

public class HMAC {

public static void main(String args[]) throws Exception {


  String datafile = ""/Users/Samip/Desktop/crypto1"";

MessageDigest md = MessageDigest.getInstance(""SHA1"");
FileInputStream fis = new FileInputStream(datafile);
byte[] dataBytes = new byte[1024];

int nread = 0; 

while ((nread = fis.read(dataBytes)) != -1) {
  md.update(dataBytes, 0, nread);
};

byte[] mdbytes = md.digest();

//convert the byte to hex format
StringBuffer sb = new StringBuffer("""");



for (int i = 0; i < mdbytes.length; i++) {
    sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
}

//System.out.println(""SHA-1 value is :: "" + sb.toString());





    FileWriter file = new FileWriter(""/Users/Samip/Desktop/crypto/output.txt"");
    PrintWriter output = new PrintWriter(file);
    output.println(sb.toString());    
    output.close(); 
    System.out.println(sb.toString());

 }
 }

i hope someone can help me with this.
"
31432218,MCRYPT_RIJNDAEL_256 PHP Encryption in Java,"I have the following source code provided by DHL that performs MCRYPT_RIJNDAEL_256 and MCRYPT_RIJNDAEL_128 encryption in PHP:
<?php
    function encrypt_128($data, $key) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $data, MCRYPT_MODE_ECB));
    }

    function encrypt_256($data, $key) {
        return base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $data, MCRYPT_MODE_ECB));
    }

    $data = ""sellerid=Company&returnsreference=0003&contents_value=101&contents_description=clothes&fullname=Joe%20Bloggs&company=Company&email=joe.bloggs@gmail.com&email_confirm=joe.bloggs@gmail.com&telephone=123&address_line_1=1&city=Acampo&postcode=952200001&country_code=US&weight=1&height=2&length=3&width=4"";
    $key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
    echo '128:' . PHP_EOL;
    echo encrypt_128($data, $key) . PHP_EOL;
    echo PHP_EOL;
    echo '256:' . PHP_EOL;
    echo encrypt_256($data, $key) . PHP_EOL;
    echo PHP_EOL;
?>

Which outputs:
128:
AEt1OHf8hjEnQYeJq07qIxj1j8M0Tyzbg4/5NCwzMwIAA72SecGEdi4XoxwXlgpTbNRyum642KVM3POo2pcPPiRiA6+WPEf6XB0eTAzIUVp8yt2Ibjk83SsNVHCK7n4lR5wXICQ4Go/zFdz68Uwc2Y2mu3SCdiferc2noyhLaInEtej8Q8yF2NwwsZreLtf/6zM7S4RKR6SDa7G2EM3wu0FjOhcyA+6HaTpl+3ZFSdMs5YwqksZjWD5SYQskVXks5y4wtw++sduJ77p2iMe/bLdIAtNwgwLHty9y7jFellxlWMeWmysmyYFNUPaoUPbXM4kDlBle3jz4sjpLiUdjQdLJIfCN6UWyQf47vFzxubt3IfsbiqHU2Qo9mHb7WQh4vtPC+U3wjM9kzV9eXcMCRQ==

256:
BUMVdaCQoce//aQWEsMgSHNRsWVPvi02ljCtF1PUfEA8Wm0tTZ6EUBEGsAiTOSINwiWikaoGm5jyBRaajHgtgj4y/7R8t5KkxEwM5H9iU/X56c8H65p3pV2P7wNayLiu5eUcLJBXb+siqCCi2VFETgGOMC8o9zjXPQ0oNCYYy5+tT2NGxSGebjM7XMIOAkIKCKvSbF+lUdxPRS1vs5ILuvzx9LP4+461ZYGYmmDKX35qPbCnsx8xaYkXnhAO8W1ddm1ylcanyAFWb2hk6UUmS7SGpSmJMAVwyUDT2uFxaizL4Z6p+KeBRgjPW2i9b5gC/MpjphJO4IKhTqKfHwziinYQ6FZOtDKtD7JC8om1kINpaMIZEHLXHEHF/iuqRbaFcH+M1Qph4Uu95d0eJ0x1A2rs2zRdlWVR72RHVIWez0w=

I need to perform 256 bit Rijndael encryption in Java. I have written the following code:
import org.apache.commons.codec.binary.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;

public class Encrypt {
    public static byte[] ivBytes = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    public static void main(String[] args) throws InvalidKeyException, UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        String data = ""sellerid=Company&returnsreference=0003&contents_value=101&contents_description=clothes&fullname=Joe%20Bloggs&company=Company&email=joe.bloggs@gmail.com&email_confirm=joe.bloggs@gmail.com&telephone=123&address_line_1=1&city=Acampo&postcode=952200001&country_code=US&weight=1&height=2&length=3&width=4"";
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String encoded = encode(data, key);
        System.out.println(""Encoded: "" + encoded);
        String decoded = decode(encoded, key);
        System.out.println(""Decoded: "" + decoded);
    }

    public static String encode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = data.getBytes(""UTF-8"");
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
        return Base64.encodeBase64String(cipher.doFinal(textBytes));
    }

    public static String decode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = Base64.decodeBase64(data);
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
        return new String(cipher.doFinal(textBytes), ""UTF-8"");
    }
}

Which is outputting:
Encoded: AEt1OHf8hjEnQYeJq07qIxtV0c4Zcfro0Yidrx/rb91OBcbyZ1RZ5id7dYCVhJe4WUvIb2OWyOVDqeVu7cHkM7zHrxRoY5hyQDWKsj4BIuxqxKO0grLYRgqQ2MZtm23D5Ko23h5sJetEYsKI1AxeXJLPQmUDB+RecELIDzJparWto9UcU6llik/v8ZX7DDmrg6K57xaSlCKWVkCKI2HivblAYwTirh7D9n/hO46c3MLngM1/Ao32S1y2XwkNX8k7PTFce5M6BLsDlzoZKjkv+t8n8GTAPPLheC0z9iLBHQbEs2WhzVY4UoCNStITWitn6QI9EwCuVX7oRVlQMi2pqow0GaGwFJ3kqGn5nbXlrbc5Lg4G8SUnM1NB01LbIEBVnVuzXQg8y+Zam47uMJ/0iQ==
Decoded: sellerid=Company&returnsreference=0003&contents_value=101&contents_description=clothes&fullname=Joe%20Bloggs&company=Company&email=joe.bloggs@gmail.com&email_confirm=joe.bloggs@gmail.com&telephone=123&address_line_1=1&city=Acampo&postcode=952200001&country_code=US&weight=1&height=2&length=3&width=4

i.e. It is encrypting it with 128 bit encryption. How do I get 256 bit Rijndael encryption?
"
30429112,What type of database it is more secure for my mobile application?,"I'm doing a new mobile application with Android which it's storing information in a database and I want to know about what it's the most secure database or if there is some another service that could replace it and will be more secure.
I'm really new in this field and I don't want to have problems later, so I want to start my app as secure as possible since the beginning.
Thanks in advance!
"
38477845,Java load public key,"I have a public key returned like
""kty"" : ""RSA"",
""alg"" : ""RS256"",
""ext"" : false,
""n"": ""vswzzDmrqLSHUu61YDxUhM87hjcVjg42NwpFOyLQK8CyW5YRcr1YUkFRNDbb92MTNW3CsSWJX3DSuilnxf8n3_JW-A9R5JAqwmEygYIXuFcoJ_pb923bph0-ayWPBfD-qwYrELvpiEHBf1QSLJYkRb1wzAlwhCeYJorifu2WhCZoOVVYQAEyNqYF7AVhNImioT8-lhFWGqHp2Jt7-oXtCjVVyyShRHUMYyCRzGj1VGI6AU5DgVebXYD2GJawUhX    -AD2CzsX8lMXeaVu88sBU9XLL1Zb_cOvAC7wTXxcls0taKx-8PiWUWKjSg0-O2ZXbfFROyQpQYHQH0BkO8XRh8w""
""e"" : ""AQAB""

And, I want to use java to load it, and my code is like
package key;

import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class PublicKeyReader {

    public static PublicKey get() throws Exception {
        String key = ""vswzzDmrqLSHUu61YDxUhM87hjcVjg42NwpFOyLQK8CyW5YRcr1YUkFRNDbb92MTNW3CsSWJX3DSuilnxf8n3_JW-A9R5JAqwmEygYIXuFcoJ_pb923bph0-ayWPBfD-qwYrELvpiEHBf1QSLJYkRb1wzAlwhCeYJorifu2WhCZoOVVYQAEyNqYF7AVhNImioT8-lhFWGqHp2Jt7-oXtCjVVyyShRHUMYyCRzGj1VGI6AU5DgVebXYD2GJawUhX-AD2CzsX8lMXeaVu88sBU9XLL1Zb_cOvAC7wTXxcls0taKx-8PiWUWKjSg0-O2ZXbfFROyQpQYHQH0BkO8XRh8w"";

        X509EncodedKeySpec spec = new X509EncodedKeySpec(key.getBytes());
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        return kf.generatePublic(spec);
    }

    public static void main(String[] args) {
        try {
            new PublicKeyReader().get();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}

and I got exception thrown, says java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: invalid key format
How to load it correctly?
"
34522859,How to RSA verify a signature in java that was generated in php,"We are using phpseclib for Public key signing of data and android java is used for Public key verification. But it repeatedtly failed. 
PHP Code For generating keys and signing by private key
 include_once(""phpseclib/autoload.php"");

 function getKeys($keysize=2048){

        $rsa = new Crypt_RSA();
        //$rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        //$rsa->setPublicKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
        $rsa->setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS8);
        $rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_PKCS1);
        $d = $rsa->createKey($keysize);
        return array(""publickey""=>$d['publickey'], ""privatekey""=>$d['privatekey']);

    }

    function encryptdata($message, $encryptionKey){

        $rsa = new Crypt_RSA();
        //$rsa->setPublicKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
        $rsa->setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS8);
        $rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_PKCS1);

        //$rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
        $rsa->loadKey($encryptionKey); // public key
        return $rsa->encrypt($message);
    } 

    function decryptdata($message, $decryptionKey){

        $rsa = new Crypt_RSA();
//        $rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_OPENSSH);
//        $rsa->setPublicKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS1);
        $rsa->setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS8);
        $rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_PKCS1);

        $rsa->loadKey($decryptionKey); // private key
        return $rsa->decrypt($message);

    }    

    $keys = getKeys();
    file_put_contents(""key.pub"", $keys[""publickey""]);
    file_put_contents(""key.priv"", $keys[""privatekey""]);

    $publickey = file_get_contents(""key.pub"");
    $privatekey = file_get_contents(""key.priv"");

    //print_r($keys);
    $string = ""Hi I m here"";
    $hash = hash(""sha256"", $string);

    $encdata = encryptdata($hash, $privatekey);
    echo $base_encdata  = base64_encode($encdata);

JAVA Code 
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.io.UnsupportedEncodingException;
import org.apache.commons.codec.binary.Base64;
import java.security.spec.X509EncodedKeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.lang.String;
class PubCheck {
    public static boolean verify(String message, String signature, PublicKey publicKey) throws SignatureException{
    try {
        Signature sign = Signature.getInstance(""SHA1withRSA"");
        sign.initVerify(publicKey);
        sign.update(message.getBytes(""UTF-8""));
        return sign.verify(Base64.decodeBase64(signature.getBytes(""UTF-8"")));
    } catch (Exception ex) {
        throw new SignatureException(ex);
    }
    }

    public static void main(String[] args) 
    throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException, SignatureException 
    {
    String plainData = ""Hi I m here"";
    String pkey = ""MIIBCgKCAQEA2tF2g/muNw9xKTVcIkjUMvMhygtIW49yo1PgbwqDQ/w9MSfEARtYYF6Tenfz0twaR/eI14GXmlIffflORe4eaSuMBhwQFOIKU/1+v1BV3RLqGGblvHTVaMVm49AGiqxNnh1LBbcSrC5UhMqlL/HGiku0oYsbjLzwcLc5ac6aBQVD60wWGNm1g26lRQGRbCLqxVfcWKT3AMvEQK3cEx/En7/5Vg1V8xnJraNMrO8UGnaX8LLJFzYJiSCEShh7F+pMHbf4MaBekw7Aaf5hPJtczNsR137R92Be3OP4idI5NLmTV+Pi1DWlxhjEhswKH88SP+gsW31gS7B/ddECUqewQwIDAQAB"";

    String data = ""aP0nuYYA1hE5odsCkR/DcdRbBvO2Z8IOlqXf/bKZJiG8HELIop90Vno1dKC1qyHEAOXy0gtH7GtJamzoBjDZmHPT6eto9EZP/xE7xZ8L05kjp0z2thLqO7on4C6DrG++TK1j+E3T7V0UeU874WIB0AEVzu1XUKFW6aeuU67a/gdn8N2n7N/WXtlyNSVZXg8f4PeUhGvFJrhINZT7BuMMZj1gZs4wMJPAICwfvVeg02RPH0N3Ybf2iVgRuZlmtQXGTyBlCxe9ybdHzuQM6nXghpLNmaOzCypb+yVs3Da7E0b3/fKQ7JqPSquWex2ERZbIMSTC6oCzc1rOF6iKVAd92Q=="";

    byte[] encodedPublicKey = pkey.getBytes( ""utf-8"" );
    //System.out.println(new String(encodedPublicKey, ""UTF-8"") + ""\n"");

    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec( encodedPublicKey );
    //PKCS8EncodedKeySpec publicKeySpec = new PKCS8EncodedKeySpec(encodedPublicKey);

    KeyFactory keyFactory = KeyFactory.getInstance( ""RSA"" );

    PublicKey publicKey = keyFactory.generatePublic( publicKeySpec );

    boolean retvar = verify(plainData, data, publicKey);

    // 3 - verifying content with signature and content :
    /*Signature sig = Signature.getInstance( ""SHA256withRSA"" );
    sig.initVerify( publicKey );
    sig.update( data.getBytes( ) );
    ret = sig.verify( sign.getBytes( ) );*/

    //byte[] decoded = Base64.decodeBase64(data);
    }
}

I compiled java code by 
javac -cp commons-codec-1.10.jar:. PubCheck.java
java -cp commons-codec-1.10.jar:. PubCheck

Then found following exception
Exception in thread ""main""   java.security.spec.InvalidKeySpecException: java.security.InvalidKeyException: invalid key format
at sun.security.rsa.RSAKeyFactory.engineGeneratePublic(RSAKeyFactory.java:205)
at java.security.KeyFactory.generatePublic(KeyFactory.java:334)
at PubCheck.main(PubCheck.java:67)
Caused by: java.security.InvalidKeyException: invalid key format
at sun.security.x509.X509Key.decode(X509Key.java:387)
at sun.security.x509.X509Key.decode(X509Key.java:403)
at sun.security.rsa.RSAPublicKeyImpl.<init>(RSAPublicKeyImpl.java:83)
at  sun.security.rsa.RSAKeyFactory.generatePublic(RSAKeyFactory.java:298)
at sun.security.rsa.RSAKeyFactory.engineGeneratePublic(RSAKeyFactory.java:201)
... 2 more

Disclaimer : I have zero knowledge about java. all the code I try found from net. 
UPDATE : Issue finally solved and java code able to verify by help from Maarten Bodewes. Code he provided works with one change I need to pass PKCS1 from phpseclib So I changed
Signature sig = Signature.getInstance( ""SHA256withRSAandMGF1"");

to
Signature sig = Signature.getInstance( ""SHA256withRSA"");

PHP Code need changes for using sign instead of manually encrypt/hashing.
function getKeys($keysize=2048){

    $rsa = new Crypt_RSA();
    $rsa->setPrivateKeyFormat(CRYPT_RSA_PRIVATE_FORMAT_PKCS8);
    $rsa->setPublicKeyFormat(CRYPT_RSA_PUBLIC_FORMAT_PKCS1);
    $d = $rsa->createKey($keysize);
    return array(""publickey""=>$d['publickey'], ""privatekey""=>$d['privatekey']);

}


$string = ""Hi I m here"";
/*
$keys = getKeys();
file_put_contents(""key1.pub"", $keys[""publickey""]);
file_put_contents(""key1.priv"", $keys[""privatekey""]);
die;*/

$publickey = file_get_contents(""key1.pub"");
$privatekey = file_get_contents(""key1.priv"");

$hash = new Crypt_Hash('sha256');
$rsa = new Crypt_RSA();    
$rsa->loadKey($privatekey);
$rsa->setSignatureMode(CRYPT_RSA_ENCRYPTION_PKCS1);
$rsa->setHash('sha256');

$signature = $rsa->sign($string);
echo base64_encode($signature);

"
31915617,How to Encrypt String With Public Key and Decrypt with Private key ?,"i want to encrypt a password with a key from server and decrypt the encrypted password in serverside. this is the code i have used in my application
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package publicprivatekey;

import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import javax.crypto.*;

/**
 *
 * @author Rajorshi
 */
public class PublicPrivateKey {

    public static String getEncrypted(String data, String Key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        PublicKey publicKey = KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(Key.getBytes())));
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] encryptedbytes = cipher.doFinal(data.getBytes());
        return new String(Base64.getEncoder().encode(encryptedbytes));
    }

    public static String getDecrypted(String data, String Key) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        PrivateKey pk = KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(Key.getBytes())));
        cipher.init(Cipher.DECRYPT_MODE, pk);
        byte[] encryptedbytes = cipher.doFinal(Base64.getDecoder().decode(data.getBytes()));
        return new String(encryptedbytes);
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        // TODO code application logic here
        KeyGenerator keyGenerator = KeyGenerator.getInstance(""Blowfish"");
        keyGenerator.init(448);
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(1024);
        KeyPair keyPair = keyPairGenerator.genKeyPair();

        String pubKey = new String(Base64.getEncoder().encode(keyPair.getPublic().getEncoded()));
        String priKey = new String(Base64.getEncoder().encode(keyPair.getPrivate().getEncoded()));
        System.out.println(""Public Key:"" + pubKey);
        System.out.println(""Private Key:"" + priKey);
        String cipherText = getEncrypted(""hi this is a string"", pubKey);

        System.out.println(""CHIPHER:"" + cipherText);
        String decryptedText = getDecrypted(cipherText, priKey);
        System.out.println(""DECRYPTED STRING:"" + decryptedText);

    }

}

i want to encrypt a password with a key from server and decrypt the encrypted password in serverside. this is the code i have used in my application.
"
44234719,Encryption Between PHP &amp; Java,"I was looking to encrypt data between a PHP server and a Java Client. Individually the code works fine and I would like to stick with OpenSSL on the PHP server. 
Do any of you see anything that I am missing here as I get an error when trying to decode the PHP encrypted string:
PHP:
<?php

$iv = 'fedcba9876543210'; #Same as in JAVA
$key = '0123456789abcdef'; #Same as in JAVA



$ciphers = openssl_get_cipher_methods(FALSE);
$ciphers_and_aliases = openssl_get_cipher_methods(true);
$cipher_aliases = array_diff($ciphers_and_aliases, $ciphers);

print_r($ciphers);

//print_r($cipher_aliases);


// DEFINE our cipher
define('AES_CBC', 'aes-128-cbc');
// Generate a 256-bit encryption key
// This should be stored somewhere instead of recreating it each time
$encryption_key = ""test_key"";
// Generate an initialization vector
// This *MUST* be available for decryption as well
//$iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length(AES_CBC));

// Create some data to encrypt
$data = ""Hello World!!!"";
$data_b64= base64_encode($data);
echo ""Before encryption: $data<br><br>Before Base64: $data_b64<br><br>"";
// Encrypt $data using aes-256-cbc cipher with the given encryption key and
// our initialization vector. The 0 gives us the default options, but can
// be changed to OPENSSL_RAW_DATA or OPENSSL_ZERO_PADDING
$encrypted = openssl_encrypt($data_b64, AES_CBC, $encryption_key, 0, $iv);
$len = strlen($encrypted);
echo ""Encrypted Len: $len  <br><br>"";
$encrypted64 = base64_encode($encrypted);
echo ""Encrypted b64: $encrypted64<br><br>"";
// If we lose the $iv variable, we can't decrypt this, so:
// - $encrypted is already base64-encoded from openssl_encrypt
// - Append a separator that we know won't exist in base64, "":""
// - And then append a base64-encoded $iv
$encrypted = $encrypted64 . ':' . base64_encode($iv);
echo ""Encrypted: $encrypted<br><br>"";
// To decrypt, separate the encrypted data from the initialization vector ($iv).
$parts = explode(':', $encrypted);
// $parts[0] = encrypted data
// $parts[1] = base-64 encoded initialization vector
// Don't forget to base64-decode the $iv before feeding it back to
//openssl_decrypt
$decrypted64 = openssl_decrypt(base64_decode($parts[0]), AES_CBC, $encryption_key, 0, base64_decode($parts[1]));
$decrypted = base64_decode($decrypted64);
echo ""Decrypted: $decrypted\n"";
?>

PHP output:

Before encryption: Hello World!!!
Before Base64: SGVsbG8gV29ybGQhISE=
Encrypted Len: 44 
Encrypted b64:
  U21yMVRGQTdROVc3TWJ1Wm1HUTBhMmZmenlIN2tvdWQ5SHA5ekVxUmp5az0=
Encrypted:
  U21yMVRGQTdROVc3TWJ1Wm1HUTBhMmZmenlIN2tvdWQ5SHA5ekVxUmp5az0=:ZmVkY2JhOTg3NjU0MzIxMA==
Decrypted: Hello World!!!

Java Code:
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.util.Base64;
import java.security.*;

public class Sandbox {

    public static String encrypt(String key, String initVector, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(Base64.getEncoder().encode(value.getBytes()));
            System.out.println(""encrypted string: ""
                    + Base64.getEncoder().encodeToString(encrypted));

            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static String decrypt(String key, String initVector, String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");


            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] temp = Base64.getDecoder().decode(encrypted);

            System.out.println((new String(temp)).length());
            byte[] original = cipher.doFinal(temp);
            original = Base64.getDecoder().decode(original);

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static void main(String[] args) {
        String key = ""0123456789abcdef""; // 128 bit key
        String initVector = ""fedcba9876543210""; // 16 bytes IV

//        for (Provider provider : Security.getProviders()) {
//            System.out.println(provider.getName());
//            for (String key2 : provider.stringPropertyNames()) {
//                System.out.println(""\t"" + key2 + ""\t"" + provider.getProperty(key2));
//            }
//        }
        System.out.println(decrypt(key, initVector,
                encrypt(key, initVector, ""Hello World!!!"")));

        System.out.println(decrypt(key, initVector, ""R090NDcvclAyY2E1cmxLWG9kSGlnUktHdEI5U05sRGxNdWF4NFFjUUV0OD0=""));
    }
}

Java Output:
> 
30
Hello World!!!

44

null

javax.crypto.IllegalBlockSizeException: Input length must be multiple of 16 when decrypting with padded cipher
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:913)
    at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:824)
    at com.sun.crypto.provider.AESCipher.engineDoFinal(AESCipher.java:436)
    at javax.crypto.Cipher.doFinal(Cipher.java:2165)
    at Sandbox.decrypt(Sandbox.java:43)
    at Sandbox.main(Sandbox.java:67)
BUILD SUCCESSFUL (total time: 1 second)

"
43960761,How to store and reuse keypair in Java?,"I am wanting generate a keypair once and reuse it.
public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(2048, new SecureRandom());
        KeyPair pair = generator.generateKeyPair();

        return pair;
}

How do I go about this?
"
41934099,Unsupported curve: 1.2.840.10045.3.1.7 on Java app,"I have a Java 8 application raising the following exception when connecting a ldaps or a https server:
Caused by: javax.net.ssl.SSLHandshakeException:
    Unsupported curve: 1.2.840.10045.3.1.7

My client environment is:
Alpine Linux 3.5 on a Docker container
OpenJDK 1.8.0_111
Wildfly 10.1.0.Final

I can workaround this problem if I connect from:

An Alpine Linux box using AES128-SHA cipher (TLSv1)
A container with CentOS 7 instead of Alpine Linux 3.5 (all ciphers work)

But will always fail if I connect from:

An Alpine Linux box using ECDHE-RSA-AES256-GCM-SHA384 cipher (TLSv1.2)

Is there something suggested to fix this problem on my Alpine Linux installation?
"
41162523,how to compare sha1 encripted password in Java?,"Let say i have encripted SHA1 password like this
String pass = ""f6ce584e7b4ff5253eed4a2ea2b44247"";

and i want make condition like this :
 if (pass.equals(""userinput"")){
        System.out.println(""success"");
    }

please someone help me to make proper condition / function to compare those both value between user input and encripted password. Your help will be highly appreciated. thanks
"
28042594,How to verify signatureBytes after signing it with SHA256withRSA?,"I am Signing some text using ""Windows-MY""  KeyStore .
I want to sign using my private key and verify using Public Key.    
KeyStore keyStore = KeyStore.getInstance(""Windows-MY"");
                keyStore.load(null, null); 
Enumeration en = keyStore.aliases();
while (en.hasMoreElements()) {   
    KeyStore keyStore = KeyStore.getInstance(""Windows-MY"");
                keyStore.load(null, null);
    String alias = en.nextElement().toString();
    X509Certificate c = (X509Certificate) keyStore.getCertificate(alias);
    String serialNumber = c.getSerialNumber().toString();
    System.out.println(""--"" + aliasName);
                PrivateKey privateKey = (PrivateKey) keyStore.getKey(aliasName, null);
                PublicKey publicKey = (PublicKey) c.getPublicKey();
                Certificate[] chain = keyStore.getCertificateChain(aliasName);
    DataOutputStream fout = new DataOutputStream(outstream);
    // -------------------------------------------------------
    String data = ""Monika"";
    byte[] content = data.getBytes();
    Provider p = keyStore.getProvider();
    // ----------------------signature---start---------------------------

    Signature signature = Signature.getInstance(""SHA256withRSA"", p);
    System.out.println("" signature.getProvider():""+ signature.getProvider());
    signature.initSign(privateKey);
    signature.update(content);
    byte[] signatureBytes = signature.sign();
    System.out.println(""signatureBytes-------------""+ signatureBytes.toString());
    // ----------------------signature----------end------------------

    // ------------------------verification---------------
    Signature signature1 = Signature.getInstance(""SHA256withRSA"", p);
    System.out.println("" signature1.getProvider():""+ signature1.getProvider());
    signature1.initVerify(publicKey);
    signature1.update(content);
    boolean verifies = signature1.verify(signatureBytes);
    System.out.println(""signature verifies: "" + verifies);
    // ------------------------------------------------
    fout.close();
} // while

Output: 
privateKey:RSAPrivateKey [size=2048 bits, type=Exchange, container=AC0BEBA9-A361-4611-96D9-B365B671FBC3]
 signature.getProvider():SunMSCAPI version 1.6
signatureBytes-------------[B@1402d5a
 signature1.getProvider():SunRsaSign version 1.5
signature verifies: false

Notice that:

My Private key is already RSAPrivateKey .
Provider for Signing is SunMSCAPI.
But I dont know about Provider for Verification with PrivateKey.

"
46988680,AES 256 algorithm support,"Is there anywhere a secure and trusted API that allows me to use the AES-256 algorithm in my Android application?
I have written a simple API using javax.crypto and java.security classes with JDK 9 that offers support for AES-256.
Because Android is still stuck with JDK 7 (JDK 8 doesn't support AES-256), I cannot use these API. So, how can I use encryption based on AES-256 algorithm?
"
46984264,migrating encrypted data to Sql server from MYSQL server,"We have aes-256 encryption for some data in one of the tables and we are migrating this to sql server. The problem is that we cannot decrypt the data in sql server due to incompatibility. Is there any way we can encrypt data in MYSQL in a way which is compatible with sql server aswell. Any advise ?
"
