question_id,title,body,answer_id,snippet_so,snippet_gpt
30429112,What type of database it is more secure for my mobile application?,"I'm doing a new mobile application with Android which it's storing information in a database and I want to know about what it's the most secure database or if there is some another service that could replace it and will be more secure.
I'm really new in this field and I don't want to have problems later, so I want to start my app as secure as possible since the beginning.
Thanks in advance!
",30431207,"import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import android.util.Base64;

public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}
","
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = ""YourDatabaseName"";
    private static final int DATABASE_VERSION = 1;

    public DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        // Create your database tables
        String createTableQuery = ""CREATE TABLE IF NOT EXISTS your_table_name (""
                + ""id INTEGER PRIMARY KEY,""
                + ""name TEXT,""
                + ""age INTEGER)"";
        db.execSQL(createTableQuery);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Upgrade your database if needed
        // Example: db.execSQL(""DROP TABLE IF EXISTS your_table_name"");
        // Then, recreate your tables by calling onCreate(db);
    }

    // Helper methods for inserting, updating, deleting records, etc.
    // Add your own methods here
    // ...

    // Usage example
    public void insertRecord(int id, String name, int age) {
        SQLiteDatabase db = this.getWritableDatabase();
        String insertQuery = ""INSERT INTO your_table_name (id, name, age) VALUES (?, ?, ?)"";
        db.execSQL(insertQuery, new Object[]{id, name, age});
        db.close();
    }
}
"
875467,Java client certificates over HTTPS/SSL,"I am using Java 6 and am trying to create an HttpsURLConnection against a remote server, using a client certificate.
The server is using an selfsigned root certificate, and requires that a password-protected client certificate is presented. I've added the server root certificate and the client certificate to a default java keystore which I found in /System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home/lib/security/cacerts (OSX 10.5).
The name of the keystore file seems to suggest that the client certificate is not supposed to go in there?
Anyway, adding the root certificate to this store solved the infamous javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed' problem.
However, I'm now stuck on how to use the client certificate. I've tried two approaches and neither gets me anywhere.
First, and preferred, try:
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
URL url = new URL(""https://somehost.dk:3049"");
HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();
conn.setSSLSocketFactory(sslsocketfactory);
InputStream inputstream = conn.getInputStream();
// The last line fails, and gives:
// javax.net.ssl.SSLHandshakeException: Received fatal alert: handshake_failure

I've tried skipping the HttpsURLConnection class (not ideal since I want to talk HTTP with the server), and do this instead:
SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(""somehost.dk"", 3049);
InputStream inputstream = sslsocket.getInputStream();
// do anything with the inputstream results in:
// java.net.SocketTimeoutException: Read timed out

I am not even sure that the client certificate is the problem here.
",876785,"import javax.net.ssl.*; import java.security.SecureRandom; import
java.security.cert.X509Certificate;

public class SSLTool {

  public static void disableCertificateValidation() {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { 
      new X509TrustManager() {
        public X509Certificate[] getAcceptedIssuers() { 
          return new X509Certificate[0]; 
        }
        public void checkClientTrusted(X509Certificate[] certs, String authType) {}
        public void checkServerTrusted(X509Certificate[] certs, String authType) {}
    }};

    // Ignore differences between given hostname and certificate hostname
    HostnameVerifier hv = new HostnameVerifier() {
      public boolean verify(String hostname, SSLSession session) { return true; }
    };

    // Install the all-trusting trust manager
    try {
      SSLContext sc = SSLContext.getInstance(""SSL"");
      sc.init(null, trustAllCerts, new SecureRandom());
      HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
      HttpsURLConnection.setDefaultHostnameVerifier(hv);
    } catch (Exception e) {}   } }
","
import java.io.InputStream;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;

public class ClientCertificateExample {
    public static void main(String[] args) throws Exception {
        // Load the client certificate keystore
        String keystorePath = ""/path/to/client_certificate_keystore.p12"";
        String keystorePassword = ""keystore_password"";
        String keystoreType = ""PKCS12"";
        
        System.setProperty(""javax.net.ssl.keyStore"", keystorePath);
        System.setProperty(""javax.net.ssl.keyStorePassword"", keystorePassword);
        System.setProperty(""javax.net.ssl.keyStoreType"", keystoreType);
        
        // Create SSL context with the default trust manager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, null, null);
        
        // Create SSL socket factory from the SSL context
        SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
        
        // Create URL object with the remote server URL
        URL url = new URL(""https://somehost.dk:3049"");
        
        // Create HttpsURLConnection with the URL
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        
        // Set the SSL socket factory on the connection
        conn.setSSLSocketFactory(sslSocketFactory);
        
        // Get the input stream from the connection
        InputStream inputStream = conn.getInputStream();
        
        // Use the input stream as needed
        // ...
        
        // Close the input stream and connection
        inputStream.close();
        conn.disconnect();
    }
}
"
27706853,How do I make an ODK Android app(whose source I can&#39;t modify) trust a fake certificate from my localhost?,"I'm developing a web app that is accessed by the ODK Android app( https://opendatakit.org/). The work that I'm doing requires an https connection. However ODK returns with javax.net.ssl.SSLPeerUnverifiedException. How do I make odk trust the SSL connection with my localhost?
",27706920,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
","
import javax.net.ssl.*;

public class SSLUtils {

    public static void trustSelfSignedSSL() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }
        }};

        // Create a SSL context instance
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());

        // Get the default HttpsURLConnection and set the SSL context
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Bypass hostname verification
        HostnameVerifier allHostsValid = (hostname, session) -> true;
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    }
}
"
13626965,How to ignore PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException?,"I got the following exception when try to post a request to a http server:
Here is the code I used
URL url = new URL(
        ""https://www.abc.com"");
HttpURLConnection conn = (HttpURLConnection) url.openConnection();

conn.setRequestMethod(""GET"");

conn.setDoOutput(true);

DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
// wr.writeBytes(params);
wr.flush();
wr.close();

BufferedReader br = new BufferedReader(new InputStreamReader(
        conn.getInputStream()));
String line = null;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}

Here is the exception:
Exception in thread ""main"" javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at com.sun.net.ssl.internal.ssl.Alerts.getSSLException(Alerts.java:174)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:1731)
    at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:241)
    at com.sun.net.ssl.internal.ssl.Handshaker.fatalSE(Handshaker.java:235)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1206)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:136)
    at com.sun.net.ssl.internal.ssl.Handshaker.processLoop(Handshaker.java:593)
    at com.sun.net.ssl.internal.ssl.Handshaker.process_record(Handshaker.java:529)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:925)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1170)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1197)
    at com.sun.net.ssl.internal.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1181)
    at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:434)
    at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:166)
    at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1014)
    at sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:230)
    at com.amazon.mzang.tools.httpchecker.CategoryYank.getPV(CategoryYank.java:32)
    at com.amazon.mzang.tools.httpchecker.CategoryYank.main(CategoryYank.java:18)
Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:323)
    at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:217)
    at sun.security.validator.Validator.validate(Validator.java:218)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:126)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:209)
    at com.sun.net.ssl.internal.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:249)
    at com.sun.net.ssl.internal.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1185)
    ... 13 more
Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
    at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:174)
    at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:238)
    at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:318)
    ... 19 more

The server is not owned by me. Is there a way to ignore this exception?
",24501156,"package com.beingjavaguys.testftp;

import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

/**
 * Fix for Exception in thread ""main"" javax.net.ssl.SSLHandshakeException:
 * sun.security.validator.ValidatorException: PKIX path building failed:
 * sun.security.provider.certpath.SunCertPathBuilderException: unable to find
 * valid certification path to requested target
 */
public class ConnectToHttpsUrl {
    public static void main(String[] args) throws Exception {
        /* Start of Fix */
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
            public void checkClientTrusted(X509Certificate[] certs, String authType) { }
            public void checkServerTrusted(X509Certificate[] certs, String authType) { }

        } };

        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) { return true; }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        /* End of the fix*/

        URL url = new URL(""https://nameofthesecuredurl.com"");
        URLConnection con = url.openConnection();
        Reader reader = new InputStreamReader(con.getInputStream());
        while (true) {
            int ch = reader.read();
            if (ch == -1) 
                break;
            System.out.print((char) ch);
        }
    }
}
","
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class Main {

    public static void main(String[] args) throws Exception {
        // Create a TrustManager that accepts all certificates
        TrustManager[] trustAllCerts = new TrustManager[]{
                new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }

                    public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }

                    public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }
                }
        };

        // Install the TrustManager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        URL url = new URL(""https://www.abc.com"");
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setRequestMethod(""GET"");
        conn.setDoOutput(true);

        DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
        wr.flush();
        wr.close();

        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }

        br.close();
        conn.disconnect();
    }
}
"
3208160,How to generate an HMAC in Java equivalent to a Python example?,"I'm looking at implementing an app getting Twitter authorization via Oauth in Java. The first step is getting a request token. Here is a Python example for app engine. 
To test my code, I am running Python and checking output with Java. Here is an example of Python generating a Hash-Based Message Authentication Code (HMAC):
#!/usr/bin/python

from hashlib import sha1
from hmac import new as hmac

key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50""
message = ""foo""

print ""%s"" % hmac(key, message, sha1).digest().encode('base64')[:-1]

Output:
$ ./foo.py
+3h2gpjf4xcynjCGU5lbdMBwGOc=

How does one replicate this example in Java?
I've seen an example of HMAC in Java:
try {
    // Generate a key for the HMAC-MD5 keyed-hashing algorithm; see RFC 2104
    // In practice, you would save this key.
    KeyGenerator keyGen = KeyGenerator.getInstance(""HmacMD5"");
    SecretKey key = keyGen.generateKey();

    // Create a MAC object using HMAC-MD5 and initialize with key
    Mac mac = Mac.getInstance(key.getAlgorithm());
    mac.init(key);

    String str = ""This message will be digested"";

    // Encode the string into bytes using utf-8 and digest it
    byte[] utf8 = str.getBytes(""UTF8"");
    byte[] digest = mac.doFinal(utf8);

    // If desired, convert the digest into a string
    String digestB64 = new sun.misc.BASE64Encoder().encode(digest);
} catch (InvalidKeyException e) {
} catch (NoSuchAlgorithmException e) {
} catch (UnsupportedEncodingException e) {
}

It uses javax.crypto.Mac, all good. However, the SecretKey constructors take bytes and an algorithm. 
What's the algorithm in the Python example? How can one create a Java secret key without an algorithm?
",11102291,"import org.apache.commons.codec.binary.Hex;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class HashingUtility {
    public static String HMAC_MD5_encode(String key, String message) throws Exception {

        SecretKeySpec keySpec = new SecretKeySpec(
                key.getBytes(),
                ""HmacMD5"");

        Mac mac = Mac.getInstance(""HmacMD5"");
        mac.init(keySpec);
        byte[] rawHmac = mac.doFinal(message.getBytes());

        return Hex.encodeHexString(rawHmac);
    }
}
","
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Main {
    public static void main(String[] args) {
        String key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50"";
        String message = ""foo"";

        try {
            Mac hmacSha1 = Mac.getInstance(""HmacSHA1"");
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ""HmacSHA1"");
            hmacSha1.init(secretKey);

            byte[] digest = hmacSha1.doFinal(message.getBytes());
            String encodedDigest = Base64.getEncoder().encodeToString(digest);

            System.out.println(encodedDigest);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            e.printStackTrace();
        }
    }
}
"
23374233,Which hashing algorithms are available in Android?,"This question might sound a little bit stupid, but there's a lack of documentation.
In order to hash strings in Android, we can use MessageDigest, which is from java.security package.
However, the basic setup is like the following:
MessageDigest.getInstance( ""SHA-512"" );

Which is not cool, therefore:

Can we know which algorithms are available on the current device? What does it depend on? Android SDK? Java SDK? This is painful in Android, because of the segmentation we've to handle...
Why the hell don't we have a Constant / Enum for that string??? Aren't them common for the whole world?

I hope you can answer both of my questions.
Thanks.
",23455539,"import android.util.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Created by sergi.castellsague on 04/05/2014.
 */
public class SecurityManager
{
private static final int ITERATIONS = 1000;

public enum HashMethod
{
    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }
    };

    public abstract String getHashString();

}

public static HashMethod getAppropriateHash()
{
    HashMethod method = null;

    if ( isPBKDFAvailable() )
    {
        method = HashMethod.PBKDF2;
    }
    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }
    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
    {
        method = HashMethod.SHA1;
    }

    return method;
}


private static boolean isPBKDFAvailable()
{
    try
    {
        SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
    }
    catch ( Exception notAvailable)
    {
        return false;
    }
    return true;
}

private static boolean isDigestAvailable( String method )
{
    try
    {
        MessageDigest.getInstance( method );
    }
    catch ( Exception notAvailable )
    {
        return false;
    }

    return true;
}

public static String getHashedPassword( HashMethod method, String password )
{
    String hashed;

    if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )
    {
        hashed = generatePBKDF( password );
    }
    else
    {
        hashed = password;
        for ( int i = 0; i < ITERATIONS; i++ )
        {
            hashed = generateDigestPassword( password, method.getHashString() );
        }
    }

    return hashed;
}

private static String generatePBKDF( String password )
{
    // Generate a 512-bit key
    final int outputKeyLength = 512;

    char[] chars = new char[password.length()];
    password.getChars( 0, password.length(), chars, 0 );
    byte[] salt = ""salt_on_client_is_funny"".getBytes(); // In security terms, this is worthess. However, it's required.

    byte[] hashedPassBytes = new byte[0];
    try
    {
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
        KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );

        hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();
    }
    catch ( Exception shouldNotHappen )
    {}

    return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );
}

private static String generateDigestPassword( String password, String algorithm )
{
    byte[] digest = new byte[0];
    byte[] buffer = password.getBytes();

    try {
        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
        messageDigest.reset();
        messageDigest.update( buffer );
        digest = messageDigest.digest();
    }
    catch ( NoSuchAlgorithmException ex )
    {}

    return Base64.encodeToString(digest, Base64.DEFAULT);
}
}
","
import java.security.Provider;
import java.security.Security;
import java.util.HashSet;
import java.util.Set;

public class AvailableHashAlgorithms {

    public static Set<String> getAvailableAlgorithms() {
        Set<String> algorithms = new HashSet<>();
        for (Provider provider : Security.getProviders()) {
            for (Object key : provider.keySet()) {
                String keyString = key.toString();
                if (keyString.startsWith(""MessageDigest."")) {
                    algorithms.add(keyString.substring(""MessageDigest."".length()));
                }
            }
        }
        return algorithms;
    }

    public static void main(String[] args) {
        Set<String> availableAlgorithms = getAvailableAlgorithms();
        for (String algorithm : availableAlgorithms) {
            System.out.println(algorithm);
        }
    }
}
"
13488155,encrypt a folder of html files and use files in java application after decryption,"
Possible Duplicate:
encrypt the html files for client side and browse them in a swing application 

I am working on a swing application in which in which client has to access the html files locally stored in the machine but i want client should not access the html files directly so want to encrypt the   entire   folder of html files using java and in Java application i would write the hard code to decrypt the html files from encrypted folder. One more thing the updation should  be possible in encrypted folder so that encrypted files may be merged in future on client  side.
I have been stuck here and has no clues for my problem , any help for my problem is appreciated. 
",13488262," import java.security.*;
   import javax.crypto.*;
   import javax.crypto.spec.*;
   import java.io.*;

   /**
   * This program generates a AES key, retrieves its raw bytes, and
   * then reinstantiates a AES key from the key bytes.
   * The reinstantiated key is used to initialize a AES cipher for
   * encryption and decryption.
   */

   public class AES {

     /**
     * Turns array of bytes into string
     *
     * @param buf   Array of bytes to convert to hex string
     * @return  Generated hex string
     */
     public static String asHex (byte buf[]) {
      StringBuffer strbuf = new StringBuffer(buf.length * 2);
      int i;

      for (i = 0; i < buf.length; i++) {
       if (((int) buf[i] & 0xff) < 0x10)
        strbuf.append(""0"");

       strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
      }

      return strbuf.toString();
     }

     public static void main(String[] args) throws Exception {

       String message=""This is just an example"";

       // Get the KeyGenerator

       KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
       kgen.init(128); // 192 and 256 bits may not be available


       // Generate the secret key specs.
       SecretKey skey = kgen.generateKey();
       byte[] raw = skey.getEncoded();

       SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");


       // Instantiate the cipher

       Cipher cipher = Cipher.getInstance(""AES"");

       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

       byte[] encrypted =
         cipher.doFinal((args.length == 0 ?
          ""This is just an example"" : args[0]).getBytes());
       System.out.println(""encrypted string: "" + asHex(encrypted));

       cipher.init(Cipher.DECRYPT_MODE, skeySpec);
       byte[] original =
         cipher.doFinal(encrypted);
       String originalString = new String(original);
       System.out.println(""Original string: "" +
         originalString + "" "" + asHex(original));
     }
   }
","
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncryptor {
    // Change these values as per your needs
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
    private static final String KEY_DERIVATION = ""PBKDF2WithHmacSHA256"";
    private static final int KEY_SIZE = 128;
    private static final int ITERATION_COUNT = 65536;
    private static final byte[] SALT = new byte[] { 0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF };

    public static void encryptFolder(File folder, String encryptedFolder) throws Exception {
        if (!folder.isDirectory()) {
            throw new IllegalArgumentException(""Input folder is not a directory"");
        }
        
        File[] files = folder.listFiles();
        if (files == null) {
            throw new IllegalStateException(""Failed to list files in input folder"");
        }
        
        for (File inputFile : files) {
            if (inputFile.isFile()) {
                File outputFile = new File(encryptedFolder, inputFile.getName() + "".enc"");
                encryptFile(inputFile, outputFile);
            }
        }
    }

    public static void decryptFolder(String encryptedFolder, File folder) throws Exception {
        if (!folder.isDirectory()) {
            throw new IllegalArgumentException(""Output folder is not a directory"");
        }
        
        File[] files = new File(encryptedFolder).listFiles();
        if (files == null) {
            throw new IllegalStateException(""Failed to list files in encrypted folder"");
        }
        
        for (File inputFile : files) {
            if (inputFile.isFile()) {
                String outputFileName = inputFile.getName().substring(0, inputFile.getName().lastIndexOf("".enc""));
                File outputFile = new File(folder, outputFileName);
                decryptFile(inputFile, outputFile);
            }
        }
    }

    private static void encryptFile(File inputFile, File outputFile) throws Exception {
        try (FileInputStream fileInputStream = new FileInputStream(inputFile);
                FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            byte[] key = generateKey();
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            
            byte[] iv = cipher.getIV();
            fileOutputStream.write(iv.length);
            fileOutputStream.write(iv);
            
            try (CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher)) {
                copyStream(fileInputStream, cipherOutputStream);
            }
        }
    }

    private static void decryptFile(File inputFile, File outputFile) throws Exception {
        try (FileInputStream fileInputStream = new FileInputStream(inputFile);
                FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            int ivLength = fileInputStream.read();
            byte[] iv = new byte[ivLength];
            fileInputStream.read(iv);
            
            byte[] key = generateKey();
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new javax.crypto.spec.IvParameterSpec(iv));
            
            try (CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher)) {
                copyStream(fileInputStream, cipherOutputStream);
            }
        }
    }

    private static void copyStream(InputStream input, OutputStream output) throws IOException {
        byte[] buffer = new byte[8192];
        int length;
        while ((length = input.read(buffer)) != -1) {
            output.write(buffer, 0, length);
        }
    }

    private static byte[] generateKey() throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_DERIVATION);
        SecretKey key = factory.generateSecret(
                new PBEKeySpec(""your_password"".toCharArray(), SALT, ITERATION_COUNT, KEY_SIZE));
        return key.getEncoded();
    }

    public static void main(String[] args) {
        try {
            String inputFolderPath = ""C:/InputFolder"";
            String encryptedFolderPath = ""C:/EncryptedFolder"";
            String outputFolderPath = ""C:/OutputFolder"";
            
            encryptFolder(new File(inputFolderPath), encryptedFolderPath);
            decryptFolder(encryptedFolderPath, new File(outputFolderPath));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
20579539,no email send android,"I want when I click on button an email will be send automatically to the user.
I followed this : Sending Email in Android using JavaMail API without using the default/built-in app android-using-javamail-api-without-using-the-default-built-in-a
and here is my code : https://stackoverflow.com/questions/20570957/sending-email-without-user-notice
No crashes or errors, but no email was sent!
Can someone please solve it for me ?
thank you 
GmailSender class:
package com.example.tesst;

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;   
import javax.mail.internet.MimeMultipart;

import android.util.Log;

import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GmailSender extends javax.mail.Authenticator {   
private String mailhost = ""smtp.gmail.com"",imagePath;   
private String user;   
private String password;   
private Session session;   

static 
{   
    Security.addProvider(new com.example.tesst.JSSEProvider());   
}  

public GmailSender(String user, String password,String imagePath) {   
    this.user = user;   
    this.password = password;   
    this.imagePath=imagePath;
    Properties props = new Properties();   
    props.setProperty(""mail.transport.protocol"", ""smtp"");   
    props.setProperty(""mail.host"", mailhost);   
    props.put(""mail.smtp.auth"", ""true"");   


    props.put(""mail.smtp.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.port"", ""465"");   
    props.put(""mail.smtp.socketFactory.class"",   
            ""javax.net.ssl.SSLSocketFactory"");   
    props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
    props.setProperty(""mail.smtp.quitwait"", ""false"");   

    session = Session.getDefaultInstance(props, this);   
}   

protected PasswordAuthentication getPasswordAuthentication() {   
    return new PasswordAuthentication(user, password);   
}   

public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
    try{


         Transport transport = session.getTransport();  

         MimeMessage message = new MimeMessage(session);  
         message.setSubject(subject);  
         message.setFrom(new InternetAddress(sender));  
         message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipients));  

         //  
         // This HTML mail have to 2 part, the BODY and the embedded image  
         //  
         MimeMultipart multipart = new MimeMultipart(""related"");  

         // first part  (the html)  
         BodyPart messageBodyPart = new MimeBodyPart();  
         String htmlText = ""<H1>""+body+""</H1>"";  
         messageBodyPart.setContent(htmlText, ""text/html"");  

         // add it  
         multipart.addBodyPart(messageBodyPart);  

         // second part (the image)  
      //   messageBodyPart = new MimeBodyPart();  
     //    DataSource fds = new FileDataSource(imagePath);  
     //    messageBodyPart.setDataHandler(new DataHandler(fds));  
     //    messageBodyPart.setHeader(""Content-ID"",imagePath);  

         // add it  
       //  multipart.addBodyPart(messageBodyPart);  

         // put everything together  
         message.setContent(multipart);  

         transport.connect();  
         transport.sendMessage(message,message.getRecipients(Message.RecipientType.TO));  
         transport.close();  
    }catch(Exception e){
        Log.e("""", ""FILE NOT FOUND EXCEPTION ""+e.getMessage());
    }
}   

public class ByteArrayDataSource implements DataSource {   
    private byte[] data;   
    private String type;   

    public ByteArrayDataSource(byte[] data, String type) {   
        super();   
        this.data = data;   
        this.type = type;   
    }   

    public ByteArrayDataSource(byte[] data) {   
        super();   
        this.data = data;   
    }   

    public void setType(String type) {   
        this.type = type;   
    }   

    public String getContentType() {   
        if (type == null)   
            return ""application/octet-stream"";   
        else  
            return type;   
    }   

    public InputStream getInputStream() throws IOException {   
        return new ByteArrayInputStream(data);   
    }   

    public String getName() {   
        return ""ByteArrayDataSource"";   
    }   

    public OutputStream getOutputStream() throws IOException {   
        throw new IOException(""Not Supported"");   
    }   
}   
}  

JSSEProvider  class 
   package com.example.tesst;


   import java.security.AccessController;

   import java.security.Provider;


   public final class JSSEProvider extends Provider {

public JSSEProvider() {
    super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
    AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {
        public Void run() {
            put(""SSLContext.TLS"",
                    ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
            put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
            put(""KeyManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
            put(""TrustManagerFactory.X509"",
                    ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
            return null;
        }
    });
}


   }

MainActivity  class
 package com.example.tesst;


 import android.os.Bundle;

 import android.app.Activity;

 import android.util.Log;

 import android.view.Menu;

 import android.view.View;

 import android.widget.Button;


 public class MainActivity extends Activity {


public Button send;
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    send=(Button) findViewById(R.id.send);
    send.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View arg0) {
            // TODO Auto-generated method stub
            try {   
                   GmailSender sender = new GmailSender(""mobilibksu@gmail.com"", ""12345"","""");
                   sender.sendMail(""test"",""bla bla blaaaa"",""lamachanz@gmail.com"",""lamachanz@gmail.com"");   
                } 
             catch (Exception e) 
               {   
                   Log.e(""SendMail"", e.getMessage(), e);   
               }
        }
    });
}

@Override
public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
}


 }

",20579770,"    package com.example.model;


    import java.security.AccessController;
    import java.security.Provider;

    public final class JSSEProvider extends Provider {

        public JSSEProvider() {
            super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
            AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {
                public Void run() {
                    put(""SSLContext.TLS"",
                            ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                    put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                    put(""KeyManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                    put(""TrustManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                    return null;
                }
            });
        }

 }
","
import android.os.AsyncTask;
import android.util.Log;

import java.util.Properties;

import javax.mail.Message;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class SendEmailTask extends AsyncTask<Void, Void, Void> {
    private static final String TAG = ""SendEmailTask"";
    
    private final String username;
    private final String password;
    private final String recipient;
    private final String subject;
    private final String message;

    public SendEmailTask(String username, String password, String recipient, String subject, String message) {
        this.username = username;
        this.password = password;
        this.recipient = recipient;
        this.subject = subject;
        this.message = message;
    }

    @Override
    protected Void doInBackground(Void... voids) {
        try {
            Properties props = new Properties();
            props.put(""mail.smtp.auth"", ""true"");
            props.put(""mail.smtp.starttls.enable"", ""true"");
            props.put(""mail.smtp.host"", ""smtp.gmail.com"");
            props.put(""mail.smtp.port"", ""587"");

            Session session = Session.getInstance(props, new javax.mail.Authenticator() {
                protected javax.mail.PasswordAuthentication getPasswordAuthentication() {
                    return new javax.mail.PasswordAuthentication(username, password);
                }
            });

            Message email = new MimeMessage(session);
            email.setFrom(new InternetAddress(username));
            email.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient));
            email.setSubject(subject);
            email.setText(message);

            Transport.send(email);
        } catch (Exception e) {
            Log.e(TAG, ""Failed to send email"", e);
        }
        
        return null;
    }
}
"
4687615,how to achieve transfer file between client and server using java socket,"I have implement the simple TCP server and TCP client classes which can send the message from client to server and the message will be converted to upper case on the server side, but how can I achieve transfer files from server to client and upload files from client to server. the following codes are what I have got.
TCPClient.java   
        import java.io.*;
        import java.net.*;
        import java.util.Scanner;

 class TCPClient {

public static void main(String args[]) throws Exception {
        int filesize=6022386;
        int bytesRead;
        int current = 0;
    String ipAdd="""";
    int portNum=0;
    boolean goes=false;
    if(goes==false){
    System.out.println(""please input the ip address of the file server"");
    Scanner scan=new Scanner(System.in);
    ipAdd=scan.nextLine();
    System.out.println(""please input the port number of the file server"");
    Scanner scan1=new Scanner(System.in);
    portNum=scan1.nextInt();
    goes=true;
    }
    System.out.println(""input done"");
    int timeCount=1;
    while(goes==true){
    //System.out.println(""connection establishing"");

    String sentence="""";
    String modifiedSentence;

    BufferedReader inFromUser = new BufferedReader(new InputStreamReader(
            System.in));

    Socket clientSocket = new Socket(ipAdd, portNum);
    //System.out.println(""connecting"");
    //System.out.println(timeCount);
    if(timeCount==1){
    sentence=""set"";
    //System.out.println(sentence);


    }
    if(timeCount!=1)
        sentence = inFromUser.readLine();
            if(sentence.equals(""close""))
                clientSocket.close();
            if(sentence.equals(""download""))
            {
                byte [] mybytearray  = new byte [filesize];
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                bytesRead = is.read(mybytearray,0,mybytearray.length);
                current = bytesRead;
                do {
   bytesRead =
      is.read(mybytearray, current, (mybytearray.length-current));
   if(bytesRead >= 0) current += bytesRead;
} while(bytesRead > -1);

bos.write(mybytearray, 0 , current);
bos.flush();
long end = System.currentTimeMillis();
//System.out.println(end-start);
bos.close();
clientSocket.close();
            }
           // if(sentence.equals(""send""))
               // clientSocket.
    timeCount--;
    //System.out.println(""connecting1"");
    DataOutputStream outToServer = new DataOutputStream(clientSocket
            .getOutputStream());

    BufferedReader inFromServer = new BufferedReader(new InputStreamReader(
            clientSocket.getInputStream()));


    //System.out.println(""connecting2"");
    //System.out.println(sentence);
    outToServer.writeBytes(sentence + ""\n"");

    modifiedSentence = inFromServer.readLine();

    System.out.println(""FROM SERVER:"" + modifiedSentence);

    clientSocket.close();

}
}

}

TCPServer.java
          import java.io.*;
       import java.net.*;

     class TCPServer {
public static void main(String args[]) throws Exception {

    Socket s = null;

    int firsttime=1;


    while (true) {
        String clientSentence;
    String capitalizedSentence="""";

        ServerSocket welcomeSocket = new ServerSocket(3248);
        Socket connectionSocket = welcomeSocket.accept();

             //Socket sock = welcomeSocket.accept();


        BufferedReader inFromClient = new BufferedReader(
                new InputStreamReader(connectionSocket.getInputStream()));

        DataOutputStream outToClient = new DataOutputStream(
                connectionSocket.getOutputStream());

        clientSentence = inFromClient.readLine();
        //System.out.println(clientSentence);
                    if(clientSentence.equals(""download""))
                    {
                         File myFile = new File (""C:\\Users\\cguo\\11.lsp"");
  byte [] mybytearray  = new byte [(int)myFile.length()];
  FileInputStream fis = new FileInputStream(myFile);
  BufferedInputStream bis = new BufferedInputStream(fis);
  bis.read(mybytearray,0,mybytearray.length);
  OutputStream os = connectionSocket.getOutputStream();
  System.out.println(""Sending..."");
  os.write(mybytearray,0,mybytearray.length);
  os.flush();
  connectionSocket.close();
                    }
        if(clientSentence.equals(""set""))
            {outToClient.writeBytes(""connection is "");
            System.out.println(""running here"");
            //welcomeSocket.close();
             //outToClient.writeBytes(capitalizedSentence);
            }



        capitalizedSentence = clientSentence.toUpperCase() + ""\n"";


    //if(!clientSentence.equals(""quit""))
           outToClient.writeBytes(capitalizedSentence+""enter the message or command: "");


        System.out.println(""passed"");
        //outToClient.writeBytes(""enter the message or command: "");
        welcomeSocket.close();
    System.out.println(""connection terminated"");
    }
}

}
So, the TCPServer.java will be executed first, and then execute the TCPClient.java, and I try to use the if clause in the TCPServer.java to test what is user's input,now I really want to implement how to transfer files from both side(download and upload).Thanks.
",4687706,"package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
","
import java.io.*;
import java.net.*;

class TCPServer {

    public static void main(String args[]) throws Exception {
        ServerSocket welcomeSocket = new ServerSocket(3248);
        System.out.println(""Server started!"");
        
        while (true) {
            Socket connectionSocket = welcomeSocket.accept();
            System.out.println(""New client connected: "" + connectionSocket.getInetAddress().getHostAddress());
            
            BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());
            
            String clientSentence = inFromClient.readLine();
            String capitalizedSentence = """";
            
            if (clientSentence.equals(""download"")) {
                File myFile = new File(""C:\\Users\\cguo\\11.lsp"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                bis.read(mybytearray, 0, mybytearray.length);
                OutputStream os = connectionSocket.getOutputStream();
                System.out.println(""Sending file to client..."");
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
            } else {
                capitalizedSentence = clientSentence.toUpperCase() + ""\n"";
                outToClient.writeBytes(capitalizedSentence);
            }
            
            outToClient.close();
            inFromClient.close();
            connectionSocket.close();
        }
    }
}
"
22201511,AES decryption gives wrong results,"I'm trying to encrypt a string in Android app and then decrypt it in ASP.Net server. I'm not getting any errors but decryption doesn't return true results. Here is Android side:
public void clckBtn(View v) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(
                    ""MyDifficultPassw"".getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(""tryToEncrypt"".getBytes());
            System.out.println(toHex(encrypted));

        } catch (Exception e) {
            System.out.println(e.toString());
        }

    }


    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
    }

The output is: CE3E99F50E6D30201E38D4955F07BA7C
Asp.Net side :
 protected void Page_Load(object sender, EventArgs e)
        {
            using (Aes myAes = Aes.Create())
            {
                string asd = DecryptStringFromBytes_Aes(GetBytes(""CE3E99F50E6D30201E38D4955F07BA7C""), GetBytes(""MyDifficultPassw""), myAes.IV);
                int we = 0;
            }

        }

        static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key
, byte[] IV)
        {
            // Check arguments. 
            if (cipherText == null || cipherText.Length <= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length <= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length <= 0)
                throw new ArgumentNullException(""Key"");

            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an Aes object 
            // with the specified key and IV. 
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                aesAlg.Padding = PaddingMode.None;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key
, aesAlg.IV);



                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {

                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt
, decryptor, CryptoStreamMode.Read))
                    {

                        using (StreamReader srDecrypt = new StreamReader(
csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting 

                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }

        static byte[] GetBytes(string str)
        {
            byte[] bytes = new byte[str.Length * sizeof(char)];
            System.Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }

In Asp.Net Aes class requires a IV (initialization vector). In Android there is no such thing. I think the problem is something about that.
",22218410,"import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class Crypto {
     public static final String TAG = ""smsfwd"";

        private static Cipher aesCipher;
        private static SecretKey secretKey;
        private static IvParameterSpec ivParameterSpec;

        private static String CIPHER_TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
        private static String CIPHER_ALGORITHM = ""AES"";
        // Replace me with a 16-byte key, share between Java and C#
        private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        private static String MESSAGEDIGEST_ALGORITHM = ""MD5"";

        public Crypto(String passphrase) {
            byte[] passwordKey = encodeDigest(passphrase);

            try {
                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
            } catch (NoSuchPaddingException e) {
                Log.e(TAG, ""No such padding PKCS5"", e);
            }

            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
            ivParameterSpec = new IvParameterSpec(rawSecretKey);
        }

        public String encryptAsBase64(byte[] clearData) {
            byte[] encryptedData = encrypt(clearData);
            return  Base64.encodeToString(encryptedData, Base64.DEFAULT);
        }

        public byte[] encrypt(byte[] clearData) {
            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }

            byte[] encryptedData;
            try {
                encryptedData = aesCipher.doFinal(clearData);
            } catch (IllegalBlockSizeException e) {
                Log.e(TAG, ""Illegal block size"", e);
                return null;
            } catch (BadPaddingException e) {
                Log.e(TAG, ""Bad padding"", e);
                return null;
            }
            return encryptedData;
        }

        private byte[] encodeDigest(String text) {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
                return digest.digest(text.getBytes());
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
            }

            return null;
        }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import org.apache.commons.codec.binary.Hex;

public class Main {

    public static void main(String[] args) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(
                    ""MyDifficultPassw"".getBytes(StandardCharsets.UTF_8), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(""tryToEncrypt"".getBytes(StandardCharsets.UTF_8));
            System.out.println(toHex(encrypted));

        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
    }
}
"
