question_id,answer_id,snippet_so,snippet_gpt
875467,876785,"import javax.net.ssl.*; import java.security.SecureRandom; import
java.security.cert.X509Certificate;

public class SSLTool {

  public static void disableCertificateValidation() {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { 
      new X509TrustManager() {
        public X509Certificate[] getAcceptedIssuers() { 
          return new X509Certificate[0]; 
        }
        public void checkClientTrusted(X509Certificate[] certs, String authType) {}
        public void checkServerTrusted(X509Certificate[] certs, String authType) {}
    }};

    // Ignore differences between given hostname and certificate hostname
    HostnameVerifier hv = new HostnameVerifier() {
      public boolean verify(String hostname, SSLSession session) { return true; }
    };

    // Install the all-trusting trust manager
    try {
      SSLContext sc = SSLContext.getInstance(""SSL"");
      sc.init(null, trustAllCerts, new SecureRandom());
      HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
      HttpsURLConnection.setDefaultHostnameVerifier(hv);
    } catch (Exception e) {}   } }
","
import java.io.InputStream;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;

public class ClientCertificateExample {
    public static void main(String[] args) throws Exception {
        // Load the client certificate keystore
        String keystorePath = ""/path/to/client_certificate_keystore.p12"";
        String keystorePassword = ""keystore_password"";
        String keystoreType = ""PKCS12"";
        
        System.setProperty(""javax.net.ssl.keyStore"", keystorePath);
        System.setProperty(""javax.net.ssl.keyStorePassword"", keystorePassword);
        System.setProperty(""javax.net.ssl.keyStoreType"", keystoreType);
        
        // Create SSL context with the default trust manager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, null, null);
        
        // Create SSL socket factory from the SSL context
        SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
        
        // Create URL object with the remote server URL
        URL url = new URL(""https://somehost.dk:3049"");
        
        // Create HttpsURLConnection with the URL
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        
        // Set the SSL socket factory on the connection
        conn.setSSLSocketFactory(sslSocketFactory);
        
        // Get the input stream from the connection
        InputStream inputStream = conn.getInputStream();
        
        // Use the input stream as needed
        // ...
        
        // Close the input stream and connection
        inputStream.close();
        conn.disconnect();
    }
}
"
1638275,1640099,"package com.stackoverflow;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.cert.X509Certificate;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;

public class Downloader {
    public static String getData(String address) throws Exception {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] {
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            }
        };

        // Create a host name verifier that always passes
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        // open connection
        URL page = new URL(address);
        HttpURLConnection conn = (HttpURLConnection) page.openConnection();
        BufferedReader buff = new BufferedReader(new InputStreamReader(conn.getInputStream()));

        // read text
        String line;
        StringBuffer text = new StringBuffer();
        while ( (line = buff.readLine()) != null ) {
            //System.out.println(line);
            text.append(line + ""\n"");
        }
        buff.close();

        return text.toString();
    }

    public static void main(String[] argv) throws Exception {
        String str = getData(""https://expired.badssl.com/"");
        System.out.println(str);
    }
}
","
import javax.net.ssl.*;
import java.io.*;
import java.net.*;

public class UrlReadExample {

    public static void main(String[] args) throws Exception {
        // Disable SSL certificate validation
        TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }
                    public void checkClientTrusted(
                            java.security.cert.X509Certificate[] certs, String authType) {
                    }
                    public void checkServerTrusted(
                            java.security.cert.X509Certificate[] certs, String authType) {
                    }
                }
        };

        // Create a SSL context with the custom trust manager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());

        // Set the default SSL socket factory
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create an HTTP URL connection
        URL url = new URL(""https://example.com"");
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();

        // Read the response
        BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));
        String inputLine;
        StringBuilder response = new StringBuilder();
        while ((inputLine = in.readLine()) != null) {
            response.append(inputLine);
        }
        in.close();

        // Print the response
        System.out.println(response.toString());
    }
}
"
3508050,3508175,"import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.security.cert.X509Certificate;
import java.util.Iterator;


public class Main {

    public static void main(String[] args) {
        try {
            // Load the JDK's cacerts keystore file
            String filename = System.getProperty(""java.home"") + ""/lib/security/cacerts"".replace('/', File.separatorChar);
            FileInputStream is = new FileInputStream(filename);
            KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            String password = ""changeit"";
            keystore.load(is, password.toCharArray());

            // This class retrieves the most-trusted CAs from the keystore
            PKIXParameters params = new PKIXParameters(keystore);

            // Get the set of trust anchors, which contain the most-trusted CA certificates
            Iterator it = params.getTrustAnchors().iterator();
            while( it.hasNext() ) {
                TrustAnchor ta = (TrustAnchor)it.next();
                // Get certificate
                X509Certificate cert = ta.getTrustedCert();
                System.out.println(cert);
            }
        } catch (CertificateException e) {
        } catch (KeyStoreException e) {
        } catch (NoSuchAlgorithmException e) {
        } catch (InvalidAlgorithmParameterException e) {
        } catch (IOException e) {
        } 
    }
}
","
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import javax.net.ssl.TrustManagerFactory;

public class TrustedRootCertificates {
    public static void main(String[] args) throws Exception {
        // Get the trust manager factory
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init((KeyStore) null);

        // Get the default trust managers
        javax.net.ssl.TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();

        // Iterate over each trust manager
        for (javax.net.ssl.TrustManager trustManager : trustManagers) {
            if (trustManager instanceof javax.net.ssl.X509TrustManager) {
                // Get the trusted root certificates
                X509Certificate[] trustedRootCertificates = ((javax.net.ssl.X509TrustManager) trustManager).getAcceptedIssuers();

                // Print information about each trusted root certificate
                for (X509Certificate certificate : trustedRootCertificates) {
                    System.out.println(""Subject DN: "" + certificate.getSubjectDN());
                    System.out.println(""Issuer DN: "" + certificate.getIssuerDN());
                    System.out.println(""Serial number: "" + certificate.getSerialNumber());
                    System.out.println();
                }
            }
        }
    }
}
"
304268,304275,"import java.io.*;
import java.security.MessageDigest;

public class MD5Checksum {

   public static byte[] createChecksum(String filename) throws Exception {
       InputStream fis =  new FileInputStream(filename);

       byte[] buffer = new byte[1024];
       MessageDigest complete = MessageDigest.getInstance(""MD5"");
       int numRead;

       do {
           numRead = fis.read(buffer);
           if (numRead > 0) {
               complete.update(buffer, 0, numRead);
           }
       } while (numRead != -1);

       fis.close();
       return complete.digest();
   }

   // see this How-to for a faster way to convert
   // a byte array to a HEX string
   public static String getMD5Checksum(String filename) throws Exception {
       byte[] b = createChecksum(filename);
       String result = """";

       for (int i=0; i < b.length; i++) {
           result += Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );
       }
       return result;
   }

   public static void main(String args[]) {
       try {
           System.out.println(getMD5Checksum(""apache-tomcat-5.5.17.exe""));
           // output :
           //  0bb2827c5eacf570b6064e24e0e6653b
           // ref :
           //  http://www.apache.org/dist/
           //          tomcat/tomcat-5/v5.5.17/bin
           //              /apache-tomcat-5.5.17.exe.MD5
           //  0bb2827c5eacf570b6064e24e0e6653b *apache-tomcat-5.5.17.exe
       }
       catch (Exception e) {
           e.printStackTrace();
       }
   }
}
","
import java.io.FileInputStream;
import java.io.IOException;
import java.security.DigestInputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class FileChecksumExample {

    public static void main(String[] args) {
        try {
            String filePath = ""path/to/your/file.txt"";
            String checksum = getFileChecksum(filePath);
            System.out.println(""MD5 checksum: "" + checksum);
        } catch (NoSuchAlgorithmException | IOException e) {
            e.printStackTrace();
        }
    }

    private static String getFileChecksum(String filePath) throws NoSuchAlgorithmException, IOException {
        MessageDigest md5Digest = MessageDigest.getInstance(""MD5"");
        
        try (DigestInputStream dis = new DigestInputStream(new FileInputStream(filePath), md5Digest)) {
            while (dis.read() != -1) ;
            // DigestInputStream automatically updates the digest (MD5) in the background
            
            byte[] digest = md5Digest.digest();
            StringBuilder result = new StringBuilder();
            
            for (byte b : digest) {
                result.append(String.format(""%02x"", b)); // Convert byte to hexadecimal format
            }
            
            return result.toString();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
","
import java.io.*;
import java.net.*;

class TCPServer {

    public static void main(String args[]) throws Exception {
        ServerSocket welcomeSocket = new ServerSocket(3248);
        System.out.println(""Server started!"");
        
        while (true) {
            Socket connectionSocket = welcomeSocket.accept();
            System.out.println(""New client connected: "" + connectionSocket.getInetAddress().getHostAddress());
            
            BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());
            
            String clientSentence = inFromClient.readLine();
            String capitalizedSentence = """";
            
            if (clientSentence.equals(""download"")) {
                File myFile = new File(""C:\\Users\\cguo\\11.lsp"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                bis.read(mybytearray, 0, mybytearray.length);
                OutputStream os = connectionSocket.getOutputStream();
                System.out.println(""Sending file to client..."");
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
            } else {
                capitalizedSentence = clientSentence.toUpperCase() + ""\n"";
                outToClient.writeBytes(capitalizedSentence);
            }
            
            outToClient.close();
            inFromClient.close();
            connectionSocket.close();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.net.*;

class TCPServer {

    private final static String fileToSend = ""C:\\test1.pdf"";

    public static void main(String args[]) {

        while (true) {
            ServerSocket welcomeSocket = null;
            Socket connectionSocket = null;
            BufferedOutputStream outToClient = null;

            try {
                welcomeSocket = new ServerSocket(3248);
                connectionSocket = welcomeSocket.accept();
                outToClient = new BufferedOutputStream(connectionSocket.getOutputStream());
            } catch (IOException ex) {
                // Do exception handling
            }

            if (outToClient != null) {
                File myFile = new File( fileToSend );
                byte[] mybytearray = new byte[(int) myFile.length()];

                FileInputStream fis = null;

                try {
                    fis = new FileInputStream(myFile);
                } catch (FileNotFoundException ex) {
                    // Do exception handling
                }
                BufferedInputStream bis = new BufferedInputStream(fis);

                try {
                    bis.read(mybytearray, 0, mybytearray.length);
                    outToClient.write(mybytearray, 0, mybytearray.length);
                    outToClient.flush();
                    outToClient.close();
                    connectionSocket.close();

                    // File sent, exit the main method
                    return;
                } catch (IOException ex) {
                    // Do exception handling
                }
            }
        }
    }
}
","
import java.io.*;
import java.net.*;

class TCPServer {

    public static void main(String args[]) throws Exception {
        ServerSocket welcomeSocket = new ServerSocket(3248);
        System.out.println(""Server started!"");
        
        while (true) {
            Socket connectionSocket = welcomeSocket.accept();
            System.out.println(""New client connected: "" + connectionSocket.getInetAddress().getHostAddress());
            
            BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());
            
            String clientSentence = inFromClient.readLine();
            String capitalizedSentence = """";
            
            if (clientSentence.equals(""download"")) {
                File myFile = new File(""C:\\Users\\cguo\\11.lsp"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                bis.read(mybytearray, 0, mybytearray.length);
                OutputStream os = connectionSocket.getOutputStream();
                System.out.println(""Sending file to client..."");
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
            } else {
                capitalizedSentence = clientSentence.toUpperCase() + ""\n"";
                outToClient.writeBytes(capitalizedSentence);
            }
            
            outToClient.close();
            inFromClient.close();
            connectionSocket.close();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
","
import java.io.*;
import java.net.*;
import java.util.Scanner;

class TCPClient {

    public static void main(String args[]) throws Exception {
        int filesize = 6022386;
        int bytesRead;
        int current = 0;
        String ipAdd = """";
        int portNum = 0;
        boolean goes = false;
        if (goes == false) {
            System.out.println(""please input the ip address of the file server"");
            Scanner scan = new Scanner(System.in);
            ipAdd = scan.nextLine();
            System.out.println(""please input the port number of the file server"");
            Scanner scan1 = new Scanner(System.in);
            portNum = scan1.nextInt();
            goes = true;
        }
        System.out.println(""input done"");
        int timeCount = 1;
        while (goes == true) {
            String sentence = """";
            String modifiedSentence;

            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(
                    System.in));

            Socket clientSocket = new Socket(ipAdd, portNum);
            
            if (timeCount == 1) {
                sentence = ""set"";
            } else {
                sentence = inFromUser.readLine();
            }
            
            if (sentence.equals(""close"")) {
                clientSocket.close();
            } else if (sentence.equals(""download"")) {
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                byte[] buffer = new byte[filesize];
                int bytesReadTotal = 0;
                while ((bytesRead = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, bytesRead);
                    bytesReadTotal += bytesRead;
                }
                System.out.println(""File downloaded successfully. Total bytes read: "" + bytesReadTotal);
                fos.close();
            } else {
                DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
                BufferedReader inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                
                outToServer.writeBytes(sentence + ""\n"");
                modifiedSentence = inFromServer.readLine();
                
                System.out.println(""FROM SERVER: "" + modifiedSentence);
                
                clientSocket.close();
            }
            
            timeCount--;
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.net.*;

class TCPServer {

    private final static String fileToSend = ""C:\\test1.pdf"";

    public static void main(String args[]) {

        while (true) {
            ServerSocket welcomeSocket = null;
            Socket connectionSocket = null;
            BufferedOutputStream outToClient = null;

            try {
                welcomeSocket = new ServerSocket(3248);
                connectionSocket = welcomeSocket.accept();
                outToClient = new BufferedOutputStream(connectionSocket.getOutputStream());
            } catch (IOException ex) {
                // Do exception handling
            }

            if (outToClient != null) {
                File myFile = new File( fileToSend );
                byte[] mybytearray = new byte[(int) myFile.length()];

                FileInputStream fis = null;

                try {
                    fis = new FileInputStream(myFile);
                } catch (FileNotFoundException ex) {
                    // Do exception handling
                }
                BufferedInputStream bis = new BufferedInputStream(fis);

                try {
                    bis.read(mybytearray, 0, mybytearray.length);
                    outToClient.write(mybytearray, 0, mybytearray.length);
                    outToClient.flush();
                    outToClient.close();
                    connectionSocket.close();

                    // File sent, exit the main method
                    return;
                } catch (IOException ex) {
                    // Do exception handling
                }
            }
        }
    }
}
","
import java.io.*;
import java.net.*;
import java.util.Scanner;

class TCPClient {

    public static void main(String args[]) throws Exception {
        int filesize = 6022386;
        int bytesRead;
        int current = 0;
        String ipAdd = """";
        int portNum = 0;
        boolean goes = false;
        if (goes == false) {
            System.out.println(""please input the ip address of the file server"");
            Scanner scan = new Scanner(System.in);
            ipAdd = scan.nextLine();
            System.out.println(""please input the port number of the file server"");
            Scanner scan1 = new Scanner(System.in);
            portNum = scan1.nextInt();
            goes = true;
        }
        System.out.println(""input done"");
        int timeCount = 1;
        while (goes == true) {
            String sentence = """";
            String modifiedSentence;

            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(
                    System.in));

            Socket clientSocket = new Socket(ipAdd, portNum);
            
            if (timeCount == 1) {
                sentence = ""set"";
            } else {
                sentence = inFromUser.readLine();
            }
            
            if (sentence.equals(""close"")) {
                clientSocket.close();
            } else if (sentence.equals(""download"")) {
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                byte[] buffer = new byte[filesize];
                int bytesReadTotal = 0;
                while ((bytesRead = is.read(buffer)) != -1) {
                    fos.write(buffer, 0, bytesRead);
                    bytesReadTotal += bytesRead;
                }
                System.out.println(""File downloaded successfully. Total bytes read: "" + bytesReadTotal);
                fos.close();
            } else {
                DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
                BufferedReader inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                
                outToServer.writeBytes(sentence + ""\n"");
                modifiedSentence = inFromServer.readLine();
                
                System.out.println(""FROM SERVER: "" + modifiedSentence);
                
                clientSocket.close();
            }
            
            timeCount--;
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
","
import java.io.*;
import java.net.*;

class TCPServer {
    public static void main(String args[]) throws Exception {
        int firstTime = 1;

        ServerSocket welcomeSocket = new ServerSocket(3248);

        while (true) {
            Socket connectionSocket = welcomeSocket.accept();
            BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());
            String clientSentence = inFromClient.readLine();
            
            if (clientSentence.equals(""download"")) {
                File myFile = new File(""C:\\Users\\cguo\\11.lsp"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                
                bis.read(mybytearray, 0, mybytearray.length);
                
                OutputStream os = connectionSocket.getOutputStream();
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
                os.close();
            } else if (clientSentence.equals(""upload"")) {
                byte[] mybytearray = new byte[6022386];
                InputStream is = connectionSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\path\\to\\uploadedfile.txt"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                
                int bytesRead;
                int current = 0;
                
                do {
                    bytesRead = is.read(mybytearray, current, (mybytearray.length - current));
                    
                    if (bytesRead >= 0) {
                        current += bytesRead;
                    }
                } while (bytesRead > -1);

                bos.write(mybytearray, 0, current);
                bos.flush();
                bos.close();
            } else if (clientSentence.equals(""set"")) {
                outToClient.writeBytes(""Connection is set.\n"");

            	outToClient.writeBytes(""Enter the message or command: "");
            } else {
                String capitalizedSentence = clientSentence.toUpperCase() + ""\n"";
                outToClient.writeBytes(capitalizedSentence + ""Enter the message or command: "");
            }

            connectionSocket.close();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.net.*;

class TCPServer {

    private final static String fileToSend = ""C:\\test1.pdf"";

    public static void main(String args[]) {

        while (true) {
            ServerSocket welcomeSocket = null;
            Socket connectionSocket = null;
            BufferedOutputStream outToClient = null;

            try {
                welcomeSocket = new ServerSocket(3248);
                connectionSocket = welcomeSocket.accept();
                outToClient = new BufferedOutputStream(connectionSocket.getOutputStream());
            } catch (IOException ex) {
                // Do exception handling
            }

            if (outToClient != null) {
                File myFile = new File( fileToSend );
                byte[] mybytearray = new byte[(int) myFile.length()];

                FileInputStream fis = null;

                try {
                    fis = new FileInputStream(myFile);
                } catch (FileNotFoundException ex) {
                    // Do exception handling
                }
                BufferedInputStream bis = new BufferedInputStream(fis);

                try {
                    bis.read(mybytearray, 0, mybytearray.length);
                    outToClient.write(mybytearray, 0, mybytearray.length);
                    outToClient.flush();
                    outToClient.close();
                    connectionSocket.close();

                    // File sent, exit the main method
                    return;
                } catch (IOException ex) {
                    // Do exception handling
                }
            }
        }
    }
}
","
import java.io.*;
import java.net.*;

class TCPServer {
    public static void main(String args[]) throws Exception {
        int firstTime = 1;

        ServerSocket welcomeSocket = new ServerSocket(3248);

        while (true) {
            Socket connectionSocket = welcomeSocket.accept();
            BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));
            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());
            String clientSentence = inFromClient.readLine();
            
            if (clientSentence.equals(""download"")) {
                File myFile = new File(""C:\\Users\\cguo\\11.lsp"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                
                bis.read(mybytearray, 0, mybytearray.length);
                
                OutputStream os = connectionSocket.getOutputStream();
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
                os.close();
            } else if (clientSentence.equals(""upload"")) {
                byte[] mybytearray = new byte[6022386];
                InputStream is = connectionSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\path\\to\\uploadedfile.txt"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                
                int bytesRead;
                int current = 0;
                
                do {
                    bytesRead = is.read(mybytearray, current, (mybytearray.length - current));
                    
                    if (bytesRead >= 0) {
                        current += bytesRead;
                    }
                } while (bytesRead > -1);

                bos.write(mybytearray, 0, current);
                bos.flush();
                bos.close();
            } else if (clientSentence.equals(""set"")) {
                outToClient.writeBytes(""Connection is set.\n"");

            	outToClient.writeBytes(""Enter the message or command: "");
            } else {
                String capitalizedSentence = clientSentence.toUpperCase() + ""\n"";
                outToClient.writeBytes(capitalizedSentence + ""Enter the message or command: "");
            }

            connectionSocket.close();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
","
import java.io.*;
import java.net.*;
import java.util.Scanner;

class TCPClient {
    public static void main(String args[]) throws Exception {
        int fileSize = 6022386;
        int bytesRead;
        int current = 0;
        String ipAdd = """";
        int portNum = 0;
        boolean goes = false;
        
        if (!goes) {
            System.out.println(""Please input the IP address of the file server:"");
            Scanner scan = new Scanner(System.in);
            ipAdd = scan.nextLine();
            
            System.out.println(""Please input the port number of the file server:"");
            Scanner scan1 = new Scanner(System.in);
            portNum = scan1.nextInt();
            
            goes = true;
        }
        
        System.out.println(""Input done."");
        
        int timeCount = 1;
        
        while (goes) {
            String sentence = """";
            String modifiedSentence;

            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));

            Socket clientSocket = new Socket(ipAdd, portNum);
            
            if (timeCount == 1) {
                sentence = ""set"";
            } else {
                sentence = inFromUser.readLine();
            }
            
            if (sentence.equals(""close"")) {
                clientSocket.close();
            } else if (sentence.equals(""download"")) {
                byte [] mybytearray  = new byte [fileSize];
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                
                bytesRead = is.read(mybytearray, 0, mybytearray.length);
                current = bytesRead;
                
                do {
                    bytesRead = is.read(mybytearray, current, (mybytearray.length - current));
                    
                    if (bytesRead >= 0) {
                        current += bytesRead;
                    }
                } while (bytesRead > -1);

                bos.write(mybytearray, 0, current);
                bos.flush();
                bos.close();
            } else if (sentence.equals(""upload"")) {
                File myFile = new File(""C:\\path\\to\\file.txt"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                
                bis.read(mybytearray, 0, mybytearray.length);
                
                OutputStream os = clientSocket.getOutputStream();
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
                os.close();
            }
            
            timeCount--;
            DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
            BufferedReader inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            outToServer.writeBytes(sentence + ""\n"");
            modifiedSentence = inFromServer.readLine();

            System.out.println(""FROM SERVER: "" + modifiedSentence);

            clientSocket.close();
        }
    }
}
"
4687615,4687706,"package filesendtest;

import java.io.*;
import java.net.*;

class TCPServer {

    private final static String fileToSend = ""C:\\test1.pdf"";

    public static void main(String args[]) {

        while (true) {
            ServerSocket welcomeSocket = null;
            Socket connectionSocket = null;
            BufferedOutputStream outToClient = null;

            try {
                welcomeSocket = new ServerSocket(3248);
                connectionSocket = welcomeSocket.accept();
                outToClient = new BufferedOutputStream(connectionSocket.getOutputStream());
            } catch (IOException ex) {
                // Do exception handling
            }

            if (outToClient != null) {
                File myFile = new File( fileToSend );
                byte[] mybytearray = new byte[(int) myFile.length()];

                FileInputStream fis = null;

                try {
                    fis = new FileInputStream(myFile);
                } catch (FileNotFoundException ex) {
                    // Do exception handling
                }
                BufferedInputStream bis = new BufferedInputStream(fis);

                try {
                    bis.read(mybytearray, 0, mybytearray.length);
                    outToClient.write(mybytearray, 0, mybytearray.length);
                    outToClient.flush();
                    outToClient.close();
                    connectionSocket.close();

                    // File sent, exit the main method
                    return;
                } catch (IOException ex) {
                    // Do exception handling
                }
            }
        }
    }
}
","
import java.io.*;
import java.net.*;
import java.util.Scanner;

class TCPClient {
    public static void main(String args[]) throws Exception {
        int fileSize = 6022386;
        int bytesRead;
        int current = 0;
        String ipAdd = """";
        int portNum = 0;
        boolean goes = false;
        
        if (!goes) {
            System.out.println(""Please input the IP address of the file server:"");
            Scanner scan = new Scanner(System.in);
            ipAdd = scan.nextLine();
            
            System.out.println(""Please input the port number of the file server:"");
            Scanner scan1 = new Scanner(System.in);
            portNum = scan1.nextInt();
            
            goes = true;
        }
        
        System.out.println(""Input done."");
        
        int timeCount = 1;
        
        while (goes) {
            String sentence = """";
            String modifiedSentence;

            BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));

            Socket clientSocket = new Socket(ipAdd, portNum);
            
            if (timeCount == 1) {
                sentence = ""set"";
            } else {
                sentence = inFromUser.readLine();
            }
            
            if (sentence.equals(""close"")) {
                clientSocket.close();
            } else if (sentence.equals(""download"")) {
                byte [] mybytearray  = new byte [fileSize];
                InputStream is = clientSocket.getInputStream();
                FileOutputStream fos = new FileOutputStream(""C:\\users\\cguo\\kk.lsp"");
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                
                bytesRead = is.read(mybytearray, 0, mybytearray.length);
                current = bytesRead;
                
                do {
                    bytesRead = is.read(mybytearray, current, (mybytearray.length - current));
                    
                    if (bytesRead >= 0) {
                        current += bytesRead;
                    }
                } while (bytesRead > -1);

                bos.write(mybytearray, 0, current);
                bos.flush();
                bos.close();
            } else if (sentence.equals(""upload"")) {
                File myFile = new File(""C:\\path\\to\\file.txt"");
                byte[] mybytearray = new byte[(int) myFile.length()];
                FileInputStream fis = new FileInputStream(myFile);
                BufferedInputStream bis = new BufferedInputStream(fis);
                
                bis.read(mybytearray, 0, mybytearray.length);
                
                OutputStream os = clientSocket.getOutputStream();
                os.write(mybytearray, 0, mybytearray.length);
                os.flush();
                os.close();
            }
            
            timeCount--;
            DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());
            BufferedReader inFromServer = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            outToServer.writeBytes(sentence + ""\n"");
            modifiedSentence = inFromServer.readLine();

            System.out.println(""FROM SERVER: "" + modifiedSentence);

            clientSocket.close();
        }
    }
}
"
20227,11367849,"
    package com.zenimax.encryption;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.NoSuchProviderException;
    import java.security.Security;
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;
    import org.bouncycastle.jce.provider.BouncyCastleProvider;

    /**
     * 
     * @author Matthew H. Wagner
     */
    public class TripleDesBouncyCastle {
        private static String TRIPLE_DES_TRANSFORMATION = ""DESede/ECB/PKCS7Padding"";
        private static String ALGORITHM = ""DESede"";
        private static String BOUNCY_CASTLE_PROVIDER = ""BC"";

        private static void init()
        {
            Security.addProvider(new BouncyCastleProvider());
        }

        public static byte[] encode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher encrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            encrypter.init(Cipher.ENCRYPT_MODE, keySpec);
            return encrypter.doFinal(input);
        }

        public static byte[] decode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher decrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            decrypter.init(Cipher.DECRYPT_MODE, keySpec);
            return decrypter.doFinal(input);
        }
    }
","
import java.io.UnsupportedEncodingException;
import java.security.*;
import java.util.Arrays;
import javax.crypto.*;
import javax.crypto.spec.*;

public class TripleDESTest {

    public static void main(String[] args) {

        String text = ""kyle boon"";

        byte[] codedtext = new TripleDESTest().encrypt(text);
        String decodedtext = new TripleDESTest().decrypt(codedtext);

        System.out.println(new String(codedtext));
        System.out.println(decodedtext);
    }

    public byte[] encrypt(String message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0, k = 16; j < 8;) {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher cipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, iv);

            final byte[] plainTextBytes = message.getBytes(""utf-8"");
            final byte[] cipherText = cipher.doFinal(plainTextBytes);

            return cipherText;
        } catch (java.security.InvalidAlgorithmParameterException e) {
            System.out.println(""Invalid Algorithm"");
        } catch (javax.crypto.NoSuchPaddingException e) {
            System.out.println(""No Such Padding"");
        } catch (java.security.NoSuchAlgorithmException e) {
            System.out.println(""No Such Algorithm"");
        } catch (java.security.InvalidKeyException e) {
            System.out.println(""Invalid Key"");
        } catch (BadPaddingException e) {
            System.out.println(""Invalid Key"");
        } catch (IllegalBlockSizeException e) {
            System.out.println(""Invalid Key"");
        } catch (UnsupportedEncodingException e) {
            System.out.println(""Invalid Key"");
        }

        return null;
    }

    public String decrypt(byte[] message) {
        try {
            final MessageDigest md = MessageDigest.getInstance(""md5"");
            final byte[] digestOfPassword = md.digest(""HG58YZ3CR9"".getBytes(""utf-8""));
            final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
            for (int j = 0, k = 16; j < 8;) {
                keyBytes[k++] = keyBytes[j++];
            }

            final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
            final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
            final Cipher decipher = Cipher.getInstance(""DESede/CBC/PKCS5Padding"");
            decipher.init(Cipher.DECRYPT_MODE, key, iv);

            final byte[] plainText = decipher.doFinal(message);

            return new String(plainText, ""utf-8"");
        } catch (java.security.InvalidAlgorithmParameterException e) {
            System.out.println(""Invalid Algorithm"");
        } catch (javax.crypto.NoSuchPaddingException e) {
            System.out.println(""No Such Padding"");
        } catch (java.security.NoSuchAlgorithmException e) {
            System.out.println(""No Such Algorithm"");
        } catch (java.security.InvalidKeyException e) {
            System.out.println(""Invalid Key"");
        } catch (BadPaddingException e) {
            System.out.println(""Invalid Key"");
        } catch (IllegalBlockSizeException e) {
            System.out.println(""Invalid Key"");
        } catch (UnsupportedEncodingException e) {
            System.out.println(""Invalid Key"");
        }

        return null;
    }
}
"
6788018,11392104,"import java.security.AlgorithmParameters;
import java.security.SecureRandom;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

class SecurityUtils {

  private static final byte[] salt = { (byte) 0xA4, (byte) 0x0B, (byte) 0xC8,
      (byte) 0x34, (byte) 0xD6, (byte) 0x95, (byte) 0xF3, (byte) 0x13 };

  private static int BLOCKS = 128;

  public static byte[] encryptAES(String seed, String cleartext)
      throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    return cipher.doFinal(cleartext.getBytes(""UTF8""));
  }

  public static byte[] decryptAES(String seed, byte[] data) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    return cipher.doFinal(data);
  }

  private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(BLOCKS, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
  }

  private static byte[] pad(byte[] seed) {
    byte[] nseed = new byte[BLOCKS / 8];
    for (int i = 0; i < BLOCKS / 8; i++)
      nseed[i] = 0;
    for (int i = 0; i < seed.length; i++)
      nseed[i] = seed[i];

    return nseed;
  }

  public static byte[] encryptPBE(String password, String cleartext)
      throws Exception {
    SecretKeyFactory factory = SecretKeyFactory
        .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    return cipher.doFinal(cleartext.getBytes(""UTF-8""));
  }

  public static String decryptPBE(SecretKey secret, String ciphertext,
      byte[] iv) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    return new String(cipher.doFinal(ciphertext.getBytes()), ""UTF-8"");
  }

}
","
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class ImageEncryptionDecryption {

    private static final String AES_ALGORITHM = ""AES"";

    // Change this key to your own secret key
    private static final String AES_SECRET_KEY = ""MySecretKey12345"";

    public static void encryptImage(File inputFile, File outputFile) throws Exception {
        SecretKey secretKey = new SecretKeySpec(AES_SECRET_KEY.getBytes(), AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);

        byte[] buffer = new byte[8192];
        int bytesRead;
        
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] encryptedBytes = cipher.update(buffer, 0, bytesRead);
            if (encryptedBytes != null) {
                outputStream.write(encryptedBytes);
            }
        }
        
        byte[] encryptedBytes = cipher.doFinal();
        if (encryptedBytes != null) {
            outputStream.write(encryptedBytes);
        }
        
        inputStream.close();
        outputStream.close();
    }

    public static void decryptImage(File inputFile, File outputFile) throws Exception {
        SecretKey secretKey = new SecretKeySpec(AES_SECRET_KEY.getBytes(), AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        FileInputStream inputStream = new FileInputStream(inputFile);
        FileOutputStream outputStream = new FileOutputStream(outputFile);

        byte[] buffer = new byte[8192];
        int bytesRead;

        while ((bytesRead = inputStream.read(buffer)) != -1) {
            byte[] decryptedBytes = cipher.update(buffer, 0, bytesRead);
            if (decryptedBytes != null) {
                outputStream.write(decryptedBytes);
            }
        }
        
        byte[] decryptedBytes = cipher.doFinal();
        if (decryptedBytes != null) {
            outputStream.write(decryptedBytes);
        }
        
        inputStream.close();
        outputStream.close();
    }

    public static void main(String[] args) {
        try {
            // Provide the paths of input and output files
            File inputFile = new File(""path_to_input_file"");
            File encryptedFile = new File(""path_to_encrypted_file"");
            File decryptedFile = new File(""path_to_decrypted_file"");

            encryptImage(inputFile, encryptedFile);
            System.out.println(""Image encrypted successfully!"");

            decryptImage(encryptedFile, decryptedFile);
            System.out.println(""Image decrypted successfully!"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
415953,25251120,"public class Hash {
    /**
     * 
     * @param txt, text in plain format
     * @param hashType MD5 OR SHA1
     * @return hash in hashType 
     */
    public static String getHash(String txt, String hashType) {
        try {
                    java.security.MessageDigest md = java.security.MessageDigest.getInstance(hashType);
                    byte[] array = md.digest(txt.getBytes());
                    StringBuffer sb = new StringBuffer();
                    for (int i = 0; i < array.length; ++i) {
                        sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
                 }
                    return sb.toString();
            } catch (java.security.NoSuchAlgorithmException e) {
                //error action
            }
            return null;
    }

    public static String md5(String txt) {
        return Hash.getHash(txt, ""MD5"");
    }

    public static String sha1(String txt) {
        return Hash.getHash(txt, ""SHA1"");
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5HashGenerator {
    public static void main(String[] args) {
        String input = ""Hello, World!"";
        String md5Hash = generateMD5Hash(input);
        System.out.println(""MD5 Hash: "" + md5Hash);
    }

    public static String generateMD5Hash(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] messageDigest = md.digest(input.getBytes());

            StringBuilder sb = new StringBuilder();
            for (byte b : messageDigest) {
                sb.append(String.format(""%02x"", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
}
"
11624571,14256570,"/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * @author Alexander Y. Kleymenov
 * @version $Revision$
 */


import java.security.AccessController;
import java.security.Provider;

public final class JSSEProvider extends Provider {

    public JSSEProvider() {
        super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
        AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {
            public Void run() {
                put(""SSLContext.TLS"",
                        ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                put(""KeyManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                put(""TrustManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                return null;
            }
        });
    }
}
","
import java.util.Properties;
import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.PasswordAuthentication;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class EmailSender {
   public static void main(String[] args) {
      // Recipient's email address
      String to = ""user@example.com"";
      
      // Sender's email address
      String from = ""abc@abc.com"";
      
      // SMTP server information
      String host = ""smtp.example.com"";
      int port = 587;
      String username = ""your_username"";
      String password = ""your_password"";
      
      // Set properties
      Properties properties = new Properties();
      properties.put(""mail.smtp.host"", host);
      properties.put(""mail.smtp.port"", port);
      properties.put(""mail.smtp.auth"", ""true"");
      properties.put(""mail.smtp.starttls.enable"", ""true"");
      
      // Create a Session object
      Session session = Session.getInstance(properties, new javax.mail.Authenticator() {
         protected PasswordAuthentication getPasswordAuthentication() {
            return new PasswordAuthentication(username, password);
         }
      });
      
      try {
         // Create a MimeMessage object
         MimeMessage message = new MimeMessage(session);
         
         // Set From: header field
         message.setFrom(new InternetAddress(from));
         
         // Set To: header field
         message.addRecipient(Message.RecipientType.TO, new InternetAddress(to));
         
         // Set Subject: header field
         message.setSubject(""Password Recovery"");
         
         // Set message content
         message.setText(""Please click the link to recover your password: http://example.com/recover"");
         
         // Send the message
         Transport.send(message);
         
         System.out.println(""Email sent successfully"");
      } catch (MessagingException e) {
         e.printStackTrace();
      }
   }
}
"
13525279,13525299,"import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }


    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
    }


}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class EncryptionExample {
    private static final String KEY = ""encryptionKey"";

    public static void main(String[] args) {
        String originalString = ""This is the string to be encrypted"";
        String encryptedString = encrypt(originalString);
        String decryptedString = decrypt(encryptedString);

        System.out.println(""Original String: "" + originalString);
        System.out.println(""Encrypted String: "" + encryptedString);
        System.out.println(""Decrypted String: "" + decryptedString);
    }

    public static String encrypt(String strToEncrypt) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encryptedBytes = cipher.doFinal(strToEncrypt.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String strToDecrypt) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(strToDecrypt));
            return new String(decryptedBytes);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
"
13488155,13488262," import java.security.*;
   import javax.crypto.*;
   import javax.crypto.spec.*;
   import java.io.*;

   /**
   * This program generates a AES key, retrieves its raw bytes, and
   * then reinstantiates a AES key from the key bytes.
   * The reinstantiated key is used to initialize a AES cipher for
   * encryption and decryption.
   */

   public class AES {

     /**
     * Turns array of bytes into string
     *
     * @param buf   Array of bytes to convert to hex string
     * @return  Generated hex string
     */
     public static String asHex (byte buf[]) {
      StringBuffer strbuf = new StringBuffer(buf.length * 2);
      int i;

      for (i = 0; i < buf.length; i++) {
       if (((int) buf[i] & 0xff) < 0x10)
        strbuf.append(""0"");

       strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
      }

      return strbuf.toString();
     }

     public static void main(String[] args) throws Exception {

       String message=""This is just an example"";

       // Get the KeyGenerator

       KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
       kgen.init(128); // 192 and 256 bits may not be available


       // Generate the secret key specs.
       SecretKey skey = kgen.generateKey();
       byte[] raw = skey.getEncoded();

       SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");


       // Instantiate the cipher

       Cipher cipher = Cipher.getInstance(""AES"");

       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

       byte[] encrypted =
         cipher.doFinal((args.length == 0 ?
          ""This is just an example"" : args[0]).getBytes());
       System.out.println(""encrypted string: "" + asHex(encrypted));

       cipher.init(Cipher.DECRYPT_MODE, skeySpec);
       byte[] original =
         cipher.doFinal(encrypted);
       String originalString = new String(original);
       System.out.println(""Original string: "" +
         originalString + "" "" + asHex(original));
     }
   }
","
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import javax.crypto.Cipher;
import javax.crypto.CipherOutputStream;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncryptor {
    // Change these values as per your needs
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
    private static final String KEY_DERIVATION = ""PBKDF2WithHmacSHA256"";
    private static final int KEY_SIZE = 128;
    private static final int ITERATION_COUNT = 65536;
    private static final byte[] SALT = new byte[] { 0x01, 0x23, 0x45, 0x67, (byte) 0x89, (byte) 0xAB, (byte) 0xCD, (byte) 0xEF };

    public static void encryptFolder(File folder, String encryptedFolder) throws Exception {
        if (!folder.isDirectory()) {
            throw new IllegalArgumentException(""Input folder is not a directory"");
        }
        
        File[] files = folder.listFiles();
        if (files == null) {
            throw new IllegalStateException(""Failed to list files in input folder"");
        }
        
        for (File inputFile : files) {
            if (inputFile.isFile()) {
                File outputFile = new File(encryptedFolder, inputFile.getName() + "".enc"");
                encryptFile(inputFile, outputFile);
            }
        }
    }

    public static void decryptFolder(String encryptedFolder, File folder) throws Exception {
        if (!folder.isDirectory()) {
            throw new IllegalArgumentException(""Output folder is not a directory"");
        }
        
        File[] files = new File(encryptedFolder).listFiles();
        if (files == null) {
            throw new IllegalStateException(""Failed to list files in encrypted folder"");
        }
        
        for (File inputFile : files) {
            if (inputFile.isFile()) {
                String outputFileName = inputFile.getName().substring(0, inputFile.getName().lastIndexOf("".enc""));
                File outputFile = new File(folder, outputFileName);
                decryptFile(inputFile, outputFile);
            }
        }
    }

    private static void encryptFile(File inputFile, File outputFile) throws Exception {
        try (FileInputStream fileInputStream = new FileInputStream(inputFile);
                FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            byte[] key = generateKey();
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
            
            byte[] iv = cipher.getIV();
            fileOutputStream.write(iv.length);
            fileOutputStream.write(iv);
            
            try (CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher)) {
                copyStream(fileInputStream, cipherOutputStream);
            }
        }
    }

    private static void decryptFile(File inputFile, File outputFile) throws Exception {
        try (FileInputStream fileInputStream = new FileInputStream(inputFile);
                FileOutputStream fileOutputStream = new FileOutputStream(outputFile)) {
            int ivLength = fileInputStream.read();
            byte[] iv = new byte[ivLength];
            fileInputStream.read(iv);
            
            byte[] key = generateKey();
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher cipher = Cipher.getInstance(TRANSFORMATION);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new javax.crypto.spec.IvParameterSpec(iv));
            
            try (CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher)) {
                copyStream(fileInputStream, cipherOutputStream);
            }
        }
    }

    private static void copyStream(InputStream input, OutputStream output) throws IOException {
        byte[] buffer = new byte[8192];
        int length;
        while ((length = input.read(buffer)) != -1) {
            output.write(buffer, 0, length);
        }
    }

    private static byte[] generateKey() throws Exception {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_DERIVATION);
        SecretKey key = factory.generateSecret(
                new PBEKeySpec(""your_password"".toCharArray(), SALT, ITERATION_COUNT, KEY_SIZE));
        return key.getEncoded();
    }

    public static void main(String[] args) {
        try {
            String inputFolderPath = ""C:/InputFolder"";
            String encryptedFolderPath = ""C:/EncryptedFolder"";
            String outputFolderPath = ""C:/OutputFolder"";
            
            encryptFolder(new File(inputFolderPath), encryptedFolderPath);
            decryptFolder(encryptedFolderPath, new File(outputFolderPath));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
11683946,12475859,"import java.util.StringTokenizer;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


public class AES {
    public static String asHex(byte[] buf) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;

        for (i = 0; i < buf.length; i++) {
            if (((int)buf[i] & 0xff) < 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int)buf[i] & 0xff, 16));
        }

        return strbuf.toString();
    }

    public static void main(String[] args) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128); // 192 and 256 bits may not be available
        // Generate the secret key specs.
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        String target = ""This is just an example"";
        StringTokenizer token = new StringTokenizer(target);
        while(token.hasMoreTokens()) {
            String temp = token.nextToken();
            byte[] encrypted = cipher.doFinal((args.length == 0 ?  temp : args[0]).getBytes());
            System.out.println(asHex(encrypted) + "" "");
        }
    }
}
","
import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;

public class AESEncrypt {

    /**
     * Turns array of bytes into string
     * 
     * @param buf
     *            Array of bytes to convert to hex string
     * @return Generated hex string
     */
    public static String asHex(byte buf[]) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;

        for (i = 0; i < buf.length; i++) {
            if (((int) buf[i] & 0xff) < 0x10)
                strbuf.append(""0"");

            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));
        }

        return strbuf.toString();
    }

    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character
                    .digit(s.charAt(i + 1), 16));
        }
        return data;
    }

    public static void main(String[] args) throws Exception {

        String message = ""Test text!"";

        // Get the KeyGenerator
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128); // 192 and 256 bits may not be available

        // Generate the secret key specs.
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        System.out.println(""Key: "" + asHex(raw));

        // Instantiate the cipher
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        // Split the message into words
        String[] words = message.split("" "");

        System.out.println(""Original string -> "" + message);
        System.out.print(""Encrypted string -> "");
        
        // Encrypt and print each word separately
        for (String word : words) {
            byte[] encrypted = cipher.doFinal(word.getBytes());
            System.out.print(asHex(encrypted) + "" "");
        }
        System.out.println();
    }
}
"
3208160,11102291,"import org.apache.commons.codec.binary.Hex;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class HashingUtility {
    public static String HMAC_MD5_encode(String key, String message) throws Exception {

        SecretKeySpec keySpec = new SecretKeySpec(
                key.getBytes(),
                ""HmacMD5"");

        Mac mac = Mac.getInstance(""HmacMD5"");
        mac.init(keySpec);
        byte[] rawHmac = mac.doFinal(message.getBytes());

        return Hex.encodeHexString(rawHmac);
    }
}
","
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class Main {
    public static void main(String[] args) {
        String key = ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50"";
        String message = ""foo"";

        try {
            Mac hmacSha1 = Mac.getInstance(""HmacSHA1"");
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ""HmacSHA1"");
            hmacSha1.init(secretKey);

            byte[] digest = hmacSha1.doFinal(message.getBytes());
            String encodedDigest = Base64.getEncoder().encodeToString(digest);

            System.out.println(encodedDigest);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            e.printStackTrace();
        }
    }
}
"
10357630,10358882,"import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class SimpleCrypto {

    private static final int KEY_SIZE = 128;

    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = encrypt(rawKey, cleartext.getBytes());
        return bin2hex(result);
    }

    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] enc = toByte(encrypted);
        final byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static String decrypt(String seed, byte[] encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = decrypt(rawKey, encrypted);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {
        final KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        final SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(KEY_SIZE, sr); // 192 and 256 bits may not be available
        final SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    public static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        final byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    public static byte[] decrypt(byte[] raw, byte[] encrypted) throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        final byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return bin2hex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        final int len = hexString.length() / 2;
        final byte[] result = new byte[len];
        for (int i = 0; i < len; i++) {
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        }
        return result;
    }

    public static byte[] getHash(String str) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance(""SHA-256"");
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        digest.reset();
        return digest.digest(str.getBytes());
    }

    static String bin2hex(byte[] data) {
        return String.format(""%0"" + (data.length * 2) + ""X"", new BigInteger(1, data));
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class DecryptExample {
    public static void main(String[] args) throws Exception {
        byte[] sessionKey = null; // Where you get this from is beyond the scope of this post
        byte[] iv = null; // Ditto
        String encryptedPassword = """"; // The password retrieved from the server and encrypted
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        
        // Decrypt the password
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(sessionKey, ""AES""), new IvParameterSpec(iv));
        byte[] decryptedPassword = cipher.doFinal(Base64.getDecoder().decode(encryptedPassword));
        String password = new String(decryptedPassword, ""UTF-8"");
        
        System.out.println(""Decrypted Password: "" + password);
    }
}
"
10283637,10291282,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {
    public static CipherOutputStream appendAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        return appendAES(file, key, null);
    }

    public static CipherOutputStream appendAES(File file, SecretKeySpec key, SecureRandom sr) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            if (sr == null) sr = new SecureRandom();
            sr.nextBytes(iv);
            rfile.write(iv);
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32);
            rfile.read(iv);
            byte[] lastBlockEnc = new byte[16];
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16);
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) {
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(rfile.getFD()),cipher);
        return cos;
    }

    public static CipherInputStream decryptAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) < 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        CipherInputStream cis = new CipherInputStream(fin,cipher);
        return cis;
    }

    public static void main(String[] args) throws Exception {
        byte[] keyBytes = new byte[]{
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
        };
        SecretKeySpec key = new SecretKeySpec(keyBytes,""AES"");

        for (int i = 0; i<100; i++) {
            CipherOutputStream cos = appendAES(new File(""log.aes""),key);
            cos.write(""All work and no play "".getBytes(""UTF-8""));
            cos.write(""makes Jack a dull boy.  \n"".getBytes(""UTF-8""));
            cos.close();
        }

        CipherInputStream cis = decryptAES(new File(""log.aes""), key);
        BufferedReader bread = new BufferedReader(new InputStreamReader(cis,""UTF-8""));
        System.out.println(bread.readLine());
        cis.close();
    }

}
","
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;

public class EncryptedFileWriter {

    private static final String AES_ALGORITHM = ""AES"";
    private static final String CIPHER_ALGORITHM = ""AES/ECB/NoPadding"";
    private static final String KEY = ""0123456789abcdef"";

    public static void main(String[] args) {
        String filePath = ""encrypted_log_file.txt"";

        try {
            // Generate a secret key for encryption
            SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), AES_ALGORITHM);

            // Create a cipher instance
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            // Open the file in append mode
            FileOutputStream fileOutputStream = new FileOutputStream(filePath, true);
            CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher);

            // Write messages to the file
            writeToEncryptedFile(cipherOutputStream, ""Message 1"");
            writeToEncryptedFile(cipherOutputStream, ""Message 2"");

            // Close the cipher output stream
            cipherOutputStream.close();

            // Decrypt and print the contents of the file
            decryptAndPrintFile(filePath);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IOException ex) {
            ex.printStackTrace();
        }
    }

    private static void writeToEncryptedFile(CipherOutputStream cipherOutputStream, String message) throws IOException {
        cipherOutputStream.write(message.getBytes());
        cipherOutputStream.write('\n'); // Add a newline character as a delimiter
    }

    private static void decryptAndPrintFile(String filePath) throws IOException {
        try {
            // Read the encrypted file
            byte[] encryptedData = Files.readAllBytes(Paths.get(filePath));

            // Create a cipher instance for decryption
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY.getBytes(), AES_ALGORITHM));

            // Decrypt the data
            byte[] decryptedData = cipher.doFinal(encryptedData);

            // Print the decrypted message
            System.out.println(new String(decryptedData));

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex) {
            ex.printStackTrace();
        }
    }
}
"
10283637,10291282,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {

    public static void appendAES(File file, byte[] data, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            new SecureRandom().nextBytes(iv);
            rfile.write(iv);
            // we have our iv, and there's no prior data to reencrypt
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32); // second to last block
            rfile.read(iv); // get iv
            byte[] lastBlockEnc = new byte[16]; 
                // last block
                // it's padded, so we'll decrypt it and 
                // save it for the beginning of our data
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16); 
                // position ourselves to overwrite the last block
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) { // lastBlock is null if we're starting a new file
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        out = cipher.doFinal(data);
        rfile.write(out);
        rfile.close();
    }

    public static void decryptAES(File file, OutputStream out, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        // nothing special here, decrypt as usual
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) < 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] buff = new byte[1<<13]; //8kiB
        while (true) {
            int count = fin.read(buff);
            if (count == buff.length) {
                out.write(cipher.update(buff));
            } else {
                out.write(cipher.doFinal(buff,0,count));
                break;
            }
        }
        fin.close();
    }

    public static void main(String[] args) throws Exception {
        byte[] key = new byte[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        for (int i = 0; i<1000; i++) {
            appendAES(new File(""log.aes""),""All work and no play makes Jack a dull boy. "".getBytes(""UTF-8""),key);
        }
        decryptAES(new File(""log.aes""), new FileOutputStream(""plain.txt""), key);
    }

}
","
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;

public class EncryptedFileWriter {

    private static final String AES_ALGORITHM = ""AES"";
    private static final String CIPHER_ALGORITHM = ""AES/ECB/NoPadding"";
    private static final String KEY = ""0123456789abcdef"";

    public static void main(String[] args) {
        String filePath = ""encrypted_log_file.txt"";

        try {
            // Generate a secret key for encryption
            SecretKeySpec secretKey = new SecretKeySpec(KEY.getBytes(), AES_ALGORITHM);

            // Create a cipher instance
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);

            // Open the file in append mode
            FileOutputStream fileOutputStream = new FileOutputStream(filePath, true);
            CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher);

            // Write messages to the file
            writeToEncryptedFile(cipherOutputStream, ""Message 1"");
            writeToEncryptedFile(cipherOutputStream, ""Message 2"");

            // Close the cipher output stream
            cipherOutputStream.close();

            // Decrypt and print the contents of the file
            decryptAndPrintFile(filePath);

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IOException ex) {
            ex.printStackTrace();
        }
    }

    private static void writeToEncryptedFile(CipherOutputStream cipherOutputStream, String message) throws IOException {
        cipherOutputStream.write(message.getBytes());
        cipherOutputStream.write('\n'); // Add a newline character as a delimiter
    }

    private static void decryptAndPrintFile(String filePath) throws IOException {
        try {
            // Read the encrypted file
            byte[] encryptedData = Files.readAllBytes(Paths.get(filePath));

            // Create a cipher instance for decryption
            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY.getBytes(), AES_ALGORITHM));

            // Decrypt the data
            byte[] decryptedData = cipher.doFinal(encryptedData);

            // Print the decrypted message
            System.out.println(new String(decryptedData));

        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex) {
            ex.printStackTrace();
        }
    }
}
"
10283637,10291282,"import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {
    public static CipherOutputStream appendAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        return appendAES(file, key, null);
    }

    public static CipherOutputStream appendAES(File file, SecretKeySpec key, SecureRandom sr) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            if (sr == null) sr = new SecureRandom();
            sr.nextBytes(iv);
            rfile.write(iv);
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32);
            rfile.read(iv);
            byte[] lastBlockEnc = new byte[16];
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16);
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) {
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(rfile.getFD()),cipher);
        return cos;
    }

    public static CipherInputStream decryptAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) < 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        CipherInputStream cis = new CipherInputStream(fin,cipher);
        return cis;
    }

    public static void main(String[] args) throws Exception {
        byte[] keyBytes = new byte[]{
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
        };
        SecretKeySpec key = new SecretKeySpec(keyBytes,""AES"");

        for (int i = 0; i<100; i++) {
            CipherOutputStream cos = appendAES(new File(""log.aes""),key);
            cos.write(""All work and no play "".getBytes(""UTF-8""));
            cos.write(""makes Jack a dull boy.  \n"".getBytes(""UTF-8""));
            cos.close();
        }

        CipherInputStream cis = decryptAES(new File(""log.aes""), key);
        BufferedReader bread = new BufferedReader(new InputStreamReader(cis,""UTF-8""));
        System.out.println(bread.readLine());
        cis.close();
    }

}
","
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;

public class EncryptedLogger {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/ECB/NoPadding"";
    private static final byte[] KEY = ""0123456789abcdef"".getBytes(); // Your secret key
    private static final int BLOCK_SIZE = 16; // Size of the encryption block in bytes

    public static void main(String[] args) throws Exception {
        String logFileName = ""encrypted_log.log"";

        // Append some messages to the encrypted log file
        appendToEncryptedLog(logFileName, ""First message"");
        appendToEncryptedLog(logFileName, ""Second message"");

        // Decrypt and print the contents of the log file
        System.out.println(decryptLogFile(logFileName));
    }

    public static void appendToEncryptedLog(String logFileName, String message) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY, ALGORITHM));

        byte[] encryptedMessage = cipher.doFinal(padMessage(message).getBytes());

        try (OutputStream outputStream = new FileOutputStream(logFileName, true)) {
            outputStream.write(encryptedMessage);
            outputStream.flush();
        }
    }

    public static String decryptLogFile(String logFileName) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY, ALGORITHM));

        try (InputStream inputStream = new FileInputStream(logFileName)) {
            byte[] encryptedMessage = inputStream.readAllBytes();
            byte[] decryptedMessage = cipher.doFinal(encryptedMessage);

            return stripPadding(new String(decryptedMessage));
        }
    }

    private static String padMessage(String message) {
        int remainder = message.length() % BLOCK_SIZE;
        int paddingLength = remainder == 0 ? BLOCK_SIZE : BLOCK_SIZE - remainder;
        StringBuilder paddedMessage = new StringBuilder(message);
        for (int i = 0; i < paddingLength; i++) {
            paddedMessage.append("" "");
        }
        return paddedMessage.toString();
    }

    private static String stripPadding(String message) {
        return message.trim();
    }
}
"
10283637,10291282,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {

    public static void appendAES(File file, byte[] data, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            new SecureRandom().nextBytes(iv);
            rfile.write(iv);
            // we have our iv, and there's no prior data to reencrypt
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32); // second to last block
            rfile.read(iv); // get iv
            byte[] lastBlockEnc = new byte[16]; 
                // last block
                // it's padded, so we'll decrypt it and 
                // save it for the beginning of our data
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16); 
                // position ourselves to overwrite the last block
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) { // lastBlock is null if we're starting a new file
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        out = cipher.doFinal(data);
        rfile.write(out);
        rfile.close();
    }

    public static void decryptAES(File file, OutputStream out, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        // nothing special here, decrypt as usual
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) < 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] buff = new byte[1<<13]; //8kiB
        while (true) {
            int count = fin.read(buff);
            if (count == buff.length) {
                out.write(cipher.update(buff));
            } else {
                out.write(cipher.doFinal(buff,0,count));
                break;
            }
        }
        fin.close();
    }

    public static void main(String[] args) throws Exception {
        byte[] key = new byte[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        for (int i = 0; i<1000; i++) {
            appendAES(new File(""log.aes""),""All work and no play makes Jack a dull boy. "".getBytes(""UTF-8""),key);
        }
        decryptAES(new File(""log.aes""), new FileOutputStream(""plain.txt""), key);
    }

}
","
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;

public class EncryptedLogger {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/ECB/NoPadding"";
    private static final byte[] KEY = ""0123456789abcdef"".getBytes(); // Your secret key
    private static final int BLOCK_SIZE = 16; // Size of the encryption block in bytes

    public static void main(String[] args) throws Exception {
        String logFileName = ""encrypted_log.log"";

        // Append some messages to the encrypted log file
        appendToEncryptedLog(logFileName, ""First message"");
        appendToEncryptedLog(logFileName, ""Second message"");

        // Decrypt and print the contents of the log file
        System.out.println(decryptLogFile(logFileName));
    }

    public static void appendToEncryptedLog(String logFileName, String message) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY, ALGORITHM));

        byte[] encryptedMessage = cipher.doFinal(padMessage(message).getBytes());

        try (OutputStream outputStream = new FileOutputStream(logFileName, true)) {
            outputStream.write(encryptedMessage);
            outputStream.flush();
        }
    }

    public static String decryptLogFile(String logFileName) throws Exception {
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY, ALGORITHM));

        try (InputStream inputStream = new FileInputStream(logFileName)) {
            byte[] encryptedMessage = inputStream.readAllBytes();
            byte[] decryptedMessage = cipher.doFinal(encryptedMessage);

            return stripPadding(new String(decryptedMessage));
        }
    }

    private static String padMessage(String message) {
        int remainder = message.length() % BLOCK_SIZE;
        int paddingLength = remainder == 0 ? BLOCK_SIZE : BLOCK_SIZE - remainder;
        StringBuilder paddedMessage = new StringBuilder(message);
        for (int i = 0; i < paddingLength; i++) {
            paddedMessage.append("" "");
        }
        return paddedMessage.toString();
    }

    private static String stripPadding(String message) {
        return message.trim();
    }
}
"
10303767,34098587,"import java.util.Base64;    
import javax.crypto.Cipher;  
import javax.crypto.KeyGenerator;   
import javax.crypto.SecretKey;  
public class EncryptionDecryptionAES {  
    static Cipher cipher;  

    public static void main(String[] args) throws Exception {
        /* 
         create key 
         If we need to generate a new key use a KeyGenerator
         If we have existing plaintext key use a SecretKeyFactory
        */ 
        KeyGenerator keyGenerator = KeyGenerator.getInstance(""AES"");
        keyGenerator.init(128); // block size is 128bits
        SecretKey secretKey = keyGenerator.generateKey();
        
        /*
          Cipher Info
          Algorithm : for the encryption of electronic data
          mode of operation : to avoid repeated blocks encrypt to the same values.
          padding: ensuring messages are the proper length necessary for certain ciphers 
          mode/padding are not used with stream cyphers.  
         */
        cipher = Cipher.getInstance(""AES""); //SunJCE provider AES algorithm, mode(optional) and padding schema(optional)  

        String plainText = ""AES Symmetric Encryption Decryption"";
        System.out.println(""Plain Text Before Encryption: "" + plainText);

        String encryptedText = encrypt(plainText, secretKey);
        System.out.println(""Encrypted Text After Encryption: "" + encryptedText);

        String decryptedText = decrypt(encryptedText, secretKey);
        System.out.println(""Decrypted Text After Decryption: "" + decryptedText);
    }

    public static String encrypt(String plainText, SecretKey secretKey)
            throws Exception {
        byte[] plainTextByte = plainText.getBytes();
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedByte = cipher.doFinal(plainTextByte);
        Base64.Encoder encoder = Base64.getEncoder();
        String encryptedText = encoder.encodeToString(encryptedByte);
        return encryptedText;
    }

    public static String decrypt(String encryptedText, SecretKey secretKey)
            throws Exception {
        Base64.Decoder decoder = Base64.getDecoder();
        byte[] encryptedTextByte = decoder.decode(encryptedText);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] decryptedByte = cipher.doFinal(encryptedTextByte);
        String decryptedText = new String(decryptedByte);
        return decryptedText;
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

public class PasswordEncryptionExample {

    private static final String ALGORITHM = ""AES"";
    private static final String KEY_FILE = ""key.txt"";
    private static final String PASSWORD_FILE = ""encrypted_password.txt"";
    private static final String PRIVATE_KEY = ""your_private_key_here""; // Replace with your own private key

    public static void main(String[] args) {
        // Generate and store the key
        Key key = generateKey(PRIVATE_KEY);
        storeKey(key, KEY_FILE);

        // Encrypt and store the password
        String password = ""your_password_here""; // Replace with the password to be encrypted
        encryptAndStorePassword(password, key);
        
        // Decrypt the password
        String decryptedPassword = decryptPassword(key);
        System.out.println(""Decrypted Password: "" + decryptedPassword);
    }

    private static Key generateKey(String privateKey) {
        try {
            byte[] keyBytes = privateKey.getBytes(StandardCharsets.UTF_8);
            MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
            keyBytes = sha.digest(keyBytes);
            return new SecretKeySpec(keyBytes, ALGORITHM);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }

    private static void storeKey(Key key, String fileName) {
        try (FileOutputStream fos = new FileOutputStream(fileName)) {
            byte[] keyBytes = key.getEncoded();
            fos.write(keyBytes);
            System.out.println(""Key stored successfully!"");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void encryptAndStorePassword(String password, Key key) {
        try (FileOutputStream fos = new FileOutputStream(PASSWORD_FILE)) {
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] encryptedPassword = cipher.doFinal(password.getBytes(StandardCharsets.UTF_8));
            fos.write(Base64.getEncoder().encode(encryptedPassword));
            System.out.println(""Password encrypted and stored successfully!"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static String decryptPassword(Key key) {
        try (FileInputStream fis = new FileInputStream(PASSWORD_FILE)) {
            byte[] encryptedPasswordBytes = fis.readAllBytes();
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, key);
            byte[] decryptedPasswordBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedPasswordBytes));
            return new String(decryptedPasswordBytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
"
13102788,22445904,"import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Encryptor {
    public static String encrypt(String key1, String key2, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string:""
                    + Base64.encodeBase64String(encrypted));
            return Base64.encodeBase64String(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String key1, String key2, String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {

        String key1 = ""Bar12345Bar12345""; // 128 bit key
        String key2 = ""ThisIsASecretKet"";
        System.out.println(decrypt(key1, key2,
                encrypt(key1, key2, ""Hello World"")));
    }
}
","
import org.bouncycastle.crypto.*;
import org.bouncycastle.crypto.engines.*;
import org.bouncycastle.crypto.modes.*;
import org.bouncycastle.crypto.paddings.*;
import org.bouncycastle.crypto.params.*;

public class AesEncryptionExample {
    public static void main(String[] args) {
        String keyInHex = ""00000000000000000000000000123456"";
        String plainTextInHex = ""00000000000000000000000000000000"";
        
        byte[] keyBytes = hexToBytes(keyInHex);
        byte[] plainTextBytes = hexToBytes(plainTextInHex);
        
        try {        
            CipherParameters cipherParams = new KeyParameter(keyBytes);
            BlockCipherPadding padding = new PKCS7Padding();
            BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()), padding);
            
            cipher.reset();
            cipher.init(true, cipherParams);
            
            byte[] encryptedBytes = new byte[cipher.getOutputSize(plainTextBytes.length)];
            int len = cipher.processBytes(plainTextBytes, 0, plainTextBytes.length, encryptedBytes, 0);
            cipher.doFinal(encryptedBytes, len);
            
            String encryptedHex = bytesToHex(encryptedBytes);
            System.out.println(""Encrypted Hex: "" + encryptedHex);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // Utility methods for converting hexadecimal strings to/from byte arrays
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format(""%02x"", b));
        }
        return sb.toString();
    }
    
    private static byte[] hexToBytes(String hex) {
        int len = hex.length();
        byte[] bytes = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                                 + Character.digit(hex.charAt(i+1), 16));
        }
        return bytes;
    }
}
"
995514,21245900,"package com.example.fakessl;

import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;

import android.util.Log;

public class CertificadoAceptar {
    private static TrustManager[] trustManagers;

    public static class _FakeX509TrustManager implements
            javax.net.ssl.X509TrustManager {
        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

        public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public boolean isClientTrusted(X509Certificate[] chain) {
            return (true);
        }

        public boolean isServerTrusted(X509Certificate[] chain) {
            return (true);
        }

        public X509Certificate[] getAcceptedIssuers() {
            return (_AcceptedIssuers);
        }
    }

    public static void allowAllSSL() {

        javax.net.ssl.HttpsURLConnection
                .setDefaultHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                });

        javax.net.ssl.SSLContext context = null;

        if (trustManagers == null) {
            trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };
        }

        try {
            context = javax.net.ssl.SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""allowAllSSL"", e.toString());
        } catch (KeyManagementException e) {
            Log.e(""allowAllSSL"", e.toString());
        }
        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }
}
","
import java.net.HttpURLConnection;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

public class Main {

    // Create a custom TrustManager to trust all certificates
    private static final TrustManager[] ALL_TRUST_MANAGER = new TrustManager[] {
        new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) {}
            public void checkServerTrusted(X509Certificate[] chain, String authType) {}
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        }
    };

    public static void main(String[] args) {
        try {
            // Create SSL context
            SSLContext sslContext = SSLContext.getInstance(""SSL"");
            sslContext.init(null, ALL_TRUST_MANAGER, new java.security.SecureRandom());

            // Set the default SSL context
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            // Disable hostname verification
            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);

            // Make the HTTPS request
            URL url = new URL(""https://example.com"");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            connection.setRequestMethod(""POST"");

            // Print the response
            int responseCode = connection.getResponseCode();
            System.out.println(""Response code: "" + responseCode);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
995514,24013606,"import org.apache.http.conn.ssl.SSLSocketFactory;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class MySSLSocketFactory extends SSLSocketFactory {
         SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
","
import javax.net.ssl.*;
import java.io.*;
import java.net.*;

public class Main {
    public static void main(String[] args) {
        try {
            // Create a trust manager that trusts all server certificates
            TrustManager[] trustAllCerts = new TrustManager[]{
                    new X509TrustManager() {
                        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                            return null;
                        }
                        public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                        public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                        }
                    }
            };

            // Activate the custom trust manager
            SSLContext sslContext = SSLContext.getInstance(""SSL"");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            // Create your HTTPS connection
            URL url = new URL(""https://your-url.com"");
            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
           
            // Read the response
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String line;
            StringBuilder response = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                response.append(line);
            }
            reader.close();

            // Print the response
            System.out.println(response.toString());

            // Close the connection
            connection.disconnect();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
20579539,20579770,"    package com.example.model;


    import java.security.AccessController;
    import java.security.Provider;

    public final class JSSEProvider extends Provider {

        public JSSEProvider() {
            super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
            AccessController.doPrivileged(new java.security.PrivilegedAction<Void>() {
                public Void run() {
                    put(""SSLContext.TLS"",
                            ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                    put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                    put(""KeyManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                    put(""TrustManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                    return null;
                }
            });
        }

 }
","
import android.os.AsyncTask;
import android.util.Log;

import java.util.Properties;

import javax.mail.Message;
import javax.mail.Session;
import javax.mail.Transport;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

public class SendEmailTask extends AsyncTask<Void, Void, Void> {
    private static final String TAG = ""SendEmailTask"";
    
    private final String username;
    private final String password;
    private final String recipient;
    private final String subject;
    private final String message;

    public SendEmailTask(String username, String password, String recipient, String subject, String message) {
        this.username = username;
        this.password = password;
        this.recipient = recipient;
        this.subject = subject;
        this.message = message;
    }

    @Override
    protected Void doInBackground(Void... voids) {
        try {
            Properties props = new Properties();
            props.put(""mail.smtp.auth"", ""true"");
            props.put(""mail.smtp.starttls.enable"", ""true"");
            props.put(""mail.smtp.host"", ""smtp.gmail.com"");
            props.put(""mail.smtp.port"", ""587"");

            Session session = Session.getInstance(props, new javax.mail.Authenticator() {
                protected javax.mail.PasswordAuthentication getPasswordAuthentication() {
                    return new javax.mail.PasswordAuthentication(username, password);
                }
            });

            Message email = new MimeMessage(session);
            email.setFrom(new InternetAddress(username));
            email.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipient));
            email.setSubject(subject);
            email.setText(message);

            Transport.send(email);
        } catch (Exception e) {
            Log.e(TAG, ""Failed to send email"", e);
        }
        
        return null;
    }
}
"
19698272,19723454,"// Java code - Cipher mode CBC version.
// CBC version need Initialization vector IV.
// Reference from https://stackoverflow.com/questions/6669181/why-does-my-aes-encryption-throws-an-invalidkeyexception/6669812#6669812

import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class CryptoSecurity {

    public static String key = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    public static byte[] key_Array = Base64.decodeBase64(key);

    public static String encrypt(String strToEncrypt)
    {       
        try
        {   
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");        

            // Initialization vector.   
            // It could be any value or generated using a random number generator.
            byte[] iv = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");    
            _Cipher.init(Cipher.ENCRYPT_MODE, SecretKey, ivspec);       

            return Base64.encodeBase64String(_Cipher.doFinal(strToEncrypt.getBytes()));     
        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());
        }
        return null;
    }

    public static String decrypt(String EncryptedMessage)
    {
        try
        {
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");            

            // Initialization vector.   
            // It could be any value or generated using a random number generator.
            byte[] iv = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");
            _Cipher.init(Cipher.DECRYPT_MODE, SecretKey, ivspec);           

            byte DecodedMessage[] = Base64.decodeBase64(EncryptedMessage);
            return new String(_Cipher.doFinal(DecodedMessage));

        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());          

        }
        return null;
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        StringBuilder sb = new StringBuilder();

        sb.append(""xml file string ..."");

        String outputOfEncrypt = encrypt(sb.toString());        
        System.out.println(""[CryptoSecurity.outputOfEncrypt]:""+outputOfEncrypt);

        String outputOfDecrypt = decrypt(outputOfEncrypt);        
        //String outputOfDecrypt = decrypt(sb.toString());        
        System.out.println(""[CryptoSecurity.outputOfDecrypt]:""+outputOfDecrypt);
    }

}
","
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class Crypt {
    public static String key = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    public static byte[] key_Array = Base64.decodeBase64(key);
    
    public static String encrypt(String strToEncrypt) {
        try {
            Key secretKey = new SecretKeySpec(key_Array, ""AES"");
    
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    
            return Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes()));
        } catch (Exception e) {
            System.out.println(""[Exception]:"" + e.getMessage());
        }
        return null;
    }
    
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        sb.append(""xml file string ..."");
    
        String encryptedString = encrypt(sb.toString());
        System.out.println(""[EncryptedString]:"" + encryptedString);
    }
}
"
19053470,19053733,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public class MD5Encode {
   private static String convertedToHex(byte[] data) {
    StringBuffer buf = new StringBuffer();

    for (int i = 0; i < data.length; i++) {
        int halfOfByte = (data[i] >>> 4) & 0x0F;
        int twoHalfBytes = 0;

        do {
            if ((0 <= halfOfByte) && (halfOfByte <= 9)) {
                buf.append((char) ('0' + halfOfByte));
            } else {
                buf.append((char) ('a' + (halfOfByte - 10)));
            }

            halfOfByte = data[i] & 0x0F;

        } while (twoHalfBytes++ < 1);
    }
    return buf.toString();
    }

    public static String MD5(String text) throws NoSuchAlgorithmException,
        UnsupportedEncodingException {
    MessageDigest md;
    md = MessageDigest.getInstance(""MD5"");
    byte[] md5 = new byte[64];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    md5 = md.digest();
    return convertedToHex(md5);
   }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5Calculator {
    public static void main(String[] args) {
        String cadena = ""109370"";
        try {
            MessageDigest di = MessageDigest.getInstance(""MD5"");
            di.update(cadena.getBytes());
            byte[] mdi = di.digest();

            StringBuffer md5 = new StringBuffer();
            for (byte b : mdi) {
                String hex = Integer.toHexString(0xFF & b);
                if (hex.length() == 1) {
                    md5.append(""0"");
                }
                md5.append(hex);
            }

            System.out.println(md5.toString());
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
    }
}
"
29224892,29228916,"package mypackage;

import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Main {

    public static void main(String[] args) throws Exception {

        String text = ""neeraj"";

        String codedtext = new Main().encrypt(text);

        String decodedtext = new Main().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""neeraj""
    }

    public String encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j < 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS7Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return Base64.encodeBase64String(cipherText);
    }

    public String decrypt(String input) throws Exception {

        byte[] message = Base64.decodeBase64(input);

        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j < 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DES/ECB/PKCS7Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
","
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class EncryptionUtils {

    private static final String KEY = ""KEY"";

    public static String encrypt(String toEncrypt) {
        try {
            byte[] keyBytes = getKeyBytes();
            byte[] toEncryptBytes = toEncrypt.getBytes(StandardCharsets.UTF_8);

            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""DESede"");
            Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

            byte[] encryptedBytes = cipher.doFinal(toEncryptBytes);

            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            e.printStackTrace();
            return ""Invalid"";
        }
    }

    public static String decrypt(String cipherString) {
        try {
            byte[] keyBytes = getKeyBytes();
            byte[] encryptedBytes = Base64.getDecoder().decode(cipherString);

            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""DESede"");
            Cipher cipher = Cipher.getInstance(""DESede/ECB/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);

            byte[] decryptedBytes = cipher.doFinal(encryptedBytes);

            return new String(decryptedBytes, StandardCharsets.UTF_8);
        } catch (Exception e) {
            e.printStackTrace();
            return ""Invalid"";
        }
    }

    private static byte[] getKeyBytes() throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        byte[] keyBytes = md.digest(KEY.getBytes(StandardCharsets.UTF_8));
        return keyBytes;
    }
}
"
13626965,24501156,"package com.beingjavaguys.testftp;

import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

/**
 * Fix for Exception in thread ""main"" javax.net.ssl.SSLHandshakeException:
 * sun.security.validator.ValidatorException: PKIX path building failed:
 * sun.security.provider.certpath.SunCertPathBuilderException: unable to find
 * valid certification path to requested target
 */
public class ConnectToHttpsUrl {
    public static void main(String[] args) throws Exception {
        /* Start of Fix */
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
            public void checkClientTrusted(X509Certificate[] certs, String authType) { }
            public void checkServerTrusted(X509Certificate[] certs, String authType) { }

        } };

        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) { return true; }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        /* End of the fix*/

        URL url = new URL(""https://nameofthesecuredurl.com"");
        URLConnection con = url.openConnection();
        Reader reader = new InputStreamReader(con.getInputStream());
        while (true) {
            int ch = reader.read();
            if (ch == -1) 
                break;
            System.out.print((char) ch);
        }
    }
}
","
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class Main {

    public static void main(String[] args) throws Exception {
        // Create a TrustManager that accepts all certificates
        TrustManager[] trustAllCerts = new TrustManager[]{
                new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }

                    public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }

                    public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
                    }
                }
        };

        // Install the TrustManager
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        URL url = new URL(""https://www.abc.com"");
        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
        conn.setRequestMethod(""GET"");
        conn.setDoOutput(true);

        DataOutputStream wr = new DataOutputStream(conn.getOutputStream());
        wr.flush();
        wr.close();

        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }

        br.close();
        conn.disconnect();
    }
}
"
28233303,28233537," package com.telpoo.frame.net;

import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    public static  HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

}
","
import org.apache.http.HttpResponse;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Vector;

public class HttpClientExample {
    public static void main(String[] args) {
        try {
            HttpClient httpClient = HttpClients.createDefault();
            HttpPost httpPost = new HttpPost(""https://example.com/api/endpoint"");

            // Set request parameters
            StringEntity params = new StringEntity(""param1=value1&param2=value2"");
            httpPost.setEntity(params);

            // Execute the request
            HttpResponse response = httpClient.execute(httpPost);

            // Read the response
            BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent()));
            String line;
            Vector<String> result = new Vector<>();
            while ((line = reader.readLine()) != null) {
                result.addElement(line);
            }

            // Close the reader and HttpClient
            reader.close();
            ((CloseableHttpClient) httpClient).close();

            // Process the result
            for (String res : result) {
                System.out.println(res);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
"
28115035,28154780,"package test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class TestCrypt{

    private static final String salt = ""t784"";
    private static final String cryptPassword = ""873147cbn9x5'2 79'79314"";
    private static final String fileToBeCrypted = ""c:\\Temp\\sampleFile.conf"";
    private static final String fileToBeDecrypted = ""c:\\Temp\\sampleFile.conf.crypt"";
    private static final String fileDecryptedOutput = ""c:\\Temp\\sampleFile.conf.decrypted"";

    public static void main(String[] args) throws Exception
    {
        for (int i=0; i<100; i++)
        {
            encryptfile(fileToBeCrypted, cryptPassword);
            decrypt(fileToBeDecrypted, cryptPassword, fileDecryptedOutput);
            System.out.println(i);
        }
    }

    public static void encryptfile(String path,String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(path.concat("".crypt""));
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        cos.flush();
        cos.close();
        fis.close();
    }

    public static void decrypt(String path,String password, String outPath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(outPath);
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }

}
","
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class FileEncryption {
    private static final String SALT = ""SomeSalt"";

    public static void encryptFile(String path, String pass) throws IOException, NoSuchAlgorithmException,
            NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(path.concat("".crypt""));
        byte[] key = (SALT + pass).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        cos.flush();
        cos.close();
        fis.close();
    }

    public static void decrypt(String path, String pass) throws IOException, NoSuchAlgorithmException,
            NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(path.replace("".crypt"", """"));
        byte[] key = (SALT + pass).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while ((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }

    public static void main(String[] args) {
        try {
            encryptFile(""path/to/input/file"", ""password"");
            decrypt(""path/to/input/file.crypt"", ""password"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
27993890,27994236,"/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
class Ideone
{
    public static void main (String[] args) throws java.lang.Exception
    {
        String salt = ""363"";
        String password = ""password"";
        String md5 = MD5(MD5(salt) + MD5(password));

        System.out.println(""MD5: "" + md5);
    }

    public static String MD5(String md5) {
           try {
                java.security.MessageDigest md = java.security.MessageDigest.getInstance(""MD5"");
                byte[] array = md.digest(md5.getBytes());
                StringBuffer sb = new StringBuffer();
                for (int i = 0; i < array.length; ++i) {
                  sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
               }
                return sb.toString();
            } catch (java.security.NoSuchAlgorithmException e) {
            }
            return null;
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Main {
    public static void main(String[] args) {
        String salt = ""*nzFC"";
        String password = ""your_password_here"";

        String hashedPassword = MD5(MD5(salt) + MD5(password));

        System.out.println(""Hashed password: "" + hashedPassword);
    }

    public static String MD5(String md5) {
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] array = md.digest(md5.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : array) {
                sb.append(Integer.toHexString((b & 0xFF) | 0x100).substring(1, 3));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            // Handle the exception
        }
        return null;
    }
}
"
27706853,27706920,"import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
","
import javax.net.ssl.*;

public class SSLUtils {

    public static void trustSelfSignedSSL() throws Exception {
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(java.security.cert.X509Certificate[] certs, String authType) {
            }
        }};

        // Create a SSL context instance
        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());

        // Get the default HttpsURLConnection and set the SSL context
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Bypass hostname verification
        HostnameVerifier allHostsValid = (hostname, session) -> true;
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
    }
}
"
27284478,27284757,"package test.md5;

import java.security.MessageDigest;

public class MD5Util {
    public final static String MD5(String s) {
        char hexDigits[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};       

        try {
            byte[] btInput = s.getBytes();
            // get MD5 MessageDigest obj
            MessageDigest mdInst = MessageDigest.getInstance(""MD5"");
            // update
            mdInst.update(btInput);
            // get encryption string
            byte[] md = mdInst.digest();
            // change to hexadecimal
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
                str[k++] = hexDigits[byte0 & 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        System.out.println(MD5Util.MD5(""20121221""));
        System.out.println(MD5Util.MD5(""encrypt""));
    }
}
","
import java.util.Arrays;

public class PasswordDemo {
    public static void main(String[] args) {
        String password = ""super_password"";
        
        // Convert password to byte array
        byte[] passByte = password.getBytes();
        
        // Clear the original password String from memory
        password = null;
        
        // Access the password from the byte array
        String retrievedPassword = new String(passByte);
        
        // Clear the password byte array from memory
        Arrays.fill(passByte, (byte) 0);
        
        System.out.println(retrievedPassword);
    }
}
"
26920068,26984009,"package com.adamiworks.commonutils.ldap;

import java.util.Hashtable;
import java.util.Properties;

import javax.naming.AuthenticationException;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;

/**
 * Authenticates with LDAP Servers. Just using a single UID this class goes deep
 * inside the user's tree and find the full DN for the given UID. It also allows
 * to connect to servers when you don't have the certificate yet... but use this
 * feature at your own risk!
 * 
 * @author Tiago J. Adami
 *
 */
public class LdapUtils {
    private InitialDirContext ldap;
    private String host;
    private int port;
    private boolean useSSL;
    private boolean ignoreCertificates;
    private String basedn;

    public InitialDirContext getLdap() {
        return ldap;
    }

    public boolean isIgnoreCertificates() {
        return ignoreCertificates;
    }

    public void setIgnoreCertificates(boolean ignoreCertificates) {
        this.ignoreCertificates = ignoreCertificates;
    }

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public String getBasedn() {
        return basedn;
    }

    public boolean isUseSSL() {
        return useSSL;
    }

    public void setUseSSL(boolean useSSL) {
        this.useSSL = useSSL;
    }

    /**
     * Default constructor
     * 
     * @param host
     * @param port
     * @param basedn
     * @param useSSL
     * @param ignoreCertificates
     */
    public LdapUtils(String host, int port, String basedn, boolean useSSL, boolean ignoreCertificates) {
        super();
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.basedn = basedn;
        this.ignoreCertificates = ignoreCertificates;
    }

    /**
     * Authenticates an user and password from LDAP credentials;
     * 
     * @param uid
     * @param password
     * @return
     * @throws NamingException
     */
    public boolean authenticate(String uid, String password) {
        try {
            String url = getUrl();
            String dn = this.getDnByUid(uid);

            Properties env = new Properties();
            env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
            env.put(Context.PROVIDER_URL, url);

            env.put(Context.SECURITY_AUTHENTICATION, ""simple"");

            env.put(Context.SECURITY_PRINCIPAL, dn);
            env.put(Context.SECURITY_CREDENTIALS, password);

            if (this.useSSL) {
                env.put(Context.SECURITY_PROTOCOL, ""ssl"");
            }

            if (this.useSSL && this.ignoreCertificates) {
                env.put(""java.naming.ldap.factory.socket"", ""com.adamiworks.commonutils.ldap.TrustAllCertificatesSSLSocketFactory"");
            }

            ldap = new InitialDirContext(env);
        } catch (AuthenticationException e) {
            e.printStackTrace();
            return false;
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrl() {
        StringBuilder url = new StringBuilder();

        url.append(this.useSSL ? ""ldaps://"" : ""ldap://"");
        url.append(host);
        url.append("":"");
        url.append(port);
        return url.toString();
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrlWithoutSsl() {
        StringBuilder url = new StringBuilder();
        url.append(""ldap://"");
        url.append(host);
        return url.toString();
    }

    /**
     * Return LDAP authentication modes allowed by the server
     * 
     * @param url
     * @return
     * @throws NamingException
     */
    public Attributes getLdapAuths() throws NamingException {

        // Create initial context
        DirContext ctx = new InitialDirContext();

        // Read supportedSASLMechanisms from root DSE
        Attributes attrs = ctx.getAttributes(this.getUrl(), new String[] { ""supportedSASLMechanisms"" });

        System.out.println(attrs);

        return attrs;

    }

    /**
     * Returns the full DN (distinct name) for a given UID
     * 
     * @param uid
     *            the UID name of the user
     * @return full tree path of LDAP
     * @throws NamingException
     */
    @SuppressWarnings(""rawtypes"")
    public String getDnByUid(String uid) throws NamingException {
        String url = this.getUrlWithoutSsl() + ""/"" + this.basedn;

        Hashtable<String, Object> env = new Hashtable<String, Object>(11);
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url);

        String ret = ""uid="" + uid;
        DirContext ctx = null;

        try {
            // Create initial context
            ctx = new InitialDirContext(env);

            SearchControls controls = new SearchControls();
            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);

            NamingEnumeration answer = ctx.search("""", ""(uid="" + uid + "")"", controls);

            while (answer.hasMore()) {
                SearchResult sr = (SearchResult) answer.next();
                ret = sr.getNameInNamespace();
                break;
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // Close the context when we're done
            ctx.close();
        }

        System.out.println(""FULL DN:  "" + ret);

        return ret;
    }

}
","
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.directory.InitialDirContext;

import java.util.Hashtable;

public class LDAPAuthentication {

    public static void main(String[] args) {
        String user = ""tiagoadami"";
        String password = ""your_password"";

        LDAPAuthentication ldapAuth = new LDAPAuthentication();
        if (ldapAuth.authenticate(user, password)) {
            System.out.println(""Authentication successful"");
        } else {
            System.out.println(""Authentication failed"");
        }
    }

    public boolean authenticate(String user, String password) {
        StringBuilder url = new StringBuilder(""ldap://"");
        url.append(""10.0.0.1"");
        url.append("":"");
        url.append(389);

        StringBuilder securityPrincipal = new StringBuilder(""uid="");
        securityPrincipal.append(user);
        securityPrincipal.append("","");
        securityPrincipal.append(""dc=XXXXX,dc=YYY,dc=ZZ"");

        Hashtable<String, String> env;
        env = new Hashtable<String, String>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url.toString());
        env.put(Context.SECURITY_AUTHENTICATION, ""simple"");
        env.put(Context.SECURITY_PRINCIPAL, securityPrincipal.toString());

        env.put(Context.SECURITY_CREDENTIALS, password);

        System.out.println(url);
        System.out.println(securityPrincipal.toString());

        try {
            InitialDirContext context = new InitialDirContext(env);
            return true;
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }
    }
}
"
26920068,26984009,"package com.adamiworks.commonutils.ldap;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

/**
 * This class accept all SSL Certificates even if it can assure its
 * Certification Institute.
 * 
 * DO NOT USE AT PRODUCTION ENVIRONMENTS
 * 
 * @author Tiago J. Adami
 *
 */
public class TrustAllCertificatesSSLSocketFactory extends SocketFactory {
    private SocketFactory socketFactory;

    public TrustAllCertificatesSSLSocketFactory() {
        try {
            SSLContext ctx = SSLContext.getInstance(""SSL"");
            ctx.init(null, new TrustManager[] { new AllCertificatesTrustManager() }, new SecureRandom());
            socketFactory = ctx.getSocketFactory();
        } catch (Exception ex) {
            ex.printStackTrace(System.err); /* handle exception */
        }
    }

    public static SocketFactory getDefault() {
        return new TrustAllCertificatesSSLSocketFactory();
    }

    @Override
    public Socket createSocket(String string, int i) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i);
    }

    @Override
    public Socket createSocket(String string, int i, InetAddress ia, int i1) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i, ia, i1);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i) throws IOException {
        return socketFactory.createSocket(ia, i);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i, InetAddress ia1, int i1) throws IOException {
        return socketFactory.createSocket(ia, i, ia1, i1);
    }

    private class AllCertificatesTrustManager implements X509TrustManager {
        public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[0];
        }
    }
}
","
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.directory.InitialDirContext;

import java.util.Hashtable;

public class LDAPAuthentication {

    public static void main(String[] args) {
        String user = ""tiagoadami"";
        String password = ""your_password"";

        LDAPAuthentication ldapAuth = new LDAPAuthentication();
        if (ldapAuth.authenticate(user, password)) {
            System.out.println(""Authentication successful"");
        } else {
            System.out.println(""Authentication failed"");
        }
    }

    public boolean authenticate(String user, String password) {
        StringBuilder url = new StringBuilder(""ldap://"");
        url.append(""10.0.0.1"");
        url.append("":"");
        url.append(389);

        StringBuilder securityPrincipal = new StringBuilder(""uid="");
        securityPrincipal.append(user);
        securityPrincipal.append("","");
        securityPrincipal.append(""dc=XXXXX,dc=YYY,dc=ZZ"");

        Hashtable<String, String> env;
        env = new Hashtable<String, String>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url.toString());
        env.put(Context.SECURITY_AUTHENTICATION, ""simple"");
        env.put(Context.SECURITY_PRINCIPAL, securityPrincipal.toString());

        env.put(Context.SECURITY_CREDENTIALS, password);

        System.out.println(url);
        System.out.println(securityPrincipal.toString());

        try {
            InitialDirContext context = new InitialDirContext(env);
            return true;
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }
    }
}
"
26920068,26984009,"package com.adamiworks.commonutils.ldap;

import java.util.Hashtable;
import java.util.Properties;

import javax.naming.AuthenticationException;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;

/**
 * Authenticates with LDAP Servers. Just using a single UID this class goes deep
 * inside the user's tree and find the full DN for the given UID. It also allows
 * to connect to servers when you don't have the certificate yet... but use this
 * feature at your own risk!
 * 
 * @author Tiago J. Adami
 *
 */
public class LdapUtils {
    private InitialDirContext ldap;
    private String host;
    private int port;
    private boolean useSSL;
    private boolean ignoreCertificates;
    private String basedn;

    public InitialDirContext getLdap() {
        return ldap;
    }

    public boolean isIgnoreCertificates() {
        return ignoreCertificates;
    }

    public void setIgnoreCertificates(boolean ignoreCertificates) {
        this.ignoreCertificates = ignoreCertificates;
    }

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public String getBasedn() {
        return basedn;
    }

    public boolean isUseSSL() {
        return useSSL;
    }

    public void setUseSSL(boolean useSSL) {
        this.useSSL = useSSL;
    }

    /**
     * Default constructor
     * 
     * @param host
     * @param port
     * @param basedn
     * @param useSSL
     * @param ignoreCertificates
     */
    public LdapUtils(String host, int port, String basedn, boolean useSSL, boolean ignoreCertificates) {
        super();
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.basedn = basedn;
        this.ignoreCertificates = ignoreCertificates;
    }

    /**
     * Authenticates an user and password from LDAP credentials;
     * 
     * @param uid
     * @param password
     * @return
     * @throws NamingException
     */
    public boolean authenticate(String uid, String password) {
        try {
            String url = getUrl();
            String dn = this.getDnByUid(uid);

            Properties env = new Properties();
            env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
            env.put(Context.PROVIDER_URL, url);

            env.put(Context.SECURITY_AUTHENTICATION, ""simple"");

            env.put(Context.SECURITY_PRINCIPAL, dn);
            env.put(Context.SECURITY_CREDENTIALS, password);

            if (this.useSSL) {
                env.put(Context.SECURITY_PROTOCOL, ""ssl"");
            }

            if (this.useSSL && this.ignoreCertificates) {
                env.put(""java.naming.ldap.factory.socket"", ""com.adamiworks.commonutils.ldap.TrustAllCertificatesSSLSocketFactory"");
            }

            ldap = new InitialDirContext(env);
        } catch (AuthenticationException e) {
            e.printStackTrace();
            return false;
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrl() {
        StringBuilder url = new StringBuilder();

        url.append(this.useSSL ? ""ldaps://"" : ""ldap://"");
        url.append(host);
        url.append("":"");
        url.append(port);
        return url.toString();
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrlWithoutSsl() {
        StringBuilder url = new StringBuilder();
        url.append(""ldap://"");
        url.append(host);
        return url.toString();
    }

    /**
     * Return LDAP authentication modes allowed by the server
     * 
     * @param url
     * @return
     * @throws NamingException
     */
    public Attributes getLdapAuths() throws NamingException {

        // Create initial context
        DirContext ctx = new InitialDirContext();

        // Read supportedSASLMechanisms from root DSE
        Attributes attrs = ctx.getAttributes(this.getUrl(), new String[] { ""supportedSASLMechanisms"" });

        System.out.println(attrs);

        return attrs;

    }

    /**
     * Returns the full DN (distinct name) for a given UID
     * 
     * @param uid
     *            the UID name of the user
     * @return full tree path of LDAP
     * @throws NamingException
     */
    @SuppressWarnings(""rawtypes"")
    public String getDnByUid(String uid) throws NamingException {
        String url = this.getUrlWithoutSsl() + ""/"" + this.basedn;

        Hashtable<String, Object> env = new Hashtable<String, Object>(11);
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url);

        String ret = ""uid="" + uid;
        DirContext ctx = null;

        try {
            // Create initial context
            ctx = new InitialDirContext(env);

            SearchControls controls = new SearchControls();
            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);

            NamingEnumeration answer = ctx.search("""", ""(uid="" + uid + "")"", controls);

            while (answer.hasMore()) {
                SearchResult sr = (SearchResult) answer.next();
                ret = sr.getNameInNamespace();
                break;
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // Close the context when we're done
            ctx.close();
        }

        System.out.println(""FULL DN:  "" + ret);

        return ret;
    }

}
","
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.naming.directory.DirContext;
import javax.naming.ldap.InitialLdapContext;
import java.util.Hashtable;

public class LDAPConnection {
    private DirContext ldap;

    public boolean authenticate(String user, String password) {
        StringBuilder url = new StringBuilder(""ldap://"");
        url.append(""10.0.0.1"");
        url.append("":"");
        url.append(389);

        StringBuilder securityPrincipal = new StringBuilder(""uid="");
        securityPrincipal.append(user);
        securityPrincipal.append("","");
        securityPrincipal.append(""dc=XXXXX,dc=YYY,dc=ZZ"");

        Hashtable<String, String> env = new Hashtable<>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url.toString());
        env.put(Context.SECURITY_AUTHENTICATION, ""simple"");
        env.put(Context.SECURITY_PRINCIPAL, securityPrincipal.toString());
        env.put(Context.SECURITY_CREDENTIALS, password);

        System.out.println(url);
        System.out.println(securityPrincipal.toString());

        try {
            ldap = new InitialLdapContext(env, null);
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    public static void main(String[] args) {
        LDAPConnection ldapConnection = new LDAPConnection();
        boolean authenticated = ldapConnection.authenticate(""tiagoadami"", ""password"");

        if (authenticated) {
            System.out.println(""Authentication successful"");
        } else {
            System.out.println(""Authentication failed"");
        }
    }
}
"
26920068,26984009,"package com.adamiworks.commonutils.ldap;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

/**
 * This class accept all SSL Certificates even if it can assure its
 * Certification Institute.
 * 
 * DO NOT USE AT PRODUCTION ENVIRONMENTS
 * 
 * @author Tiago J. Adami
 *
 */
public class TrustAllCertificatesSSLSocketFactory extends SocketFactory {
    private SocketFactory socketFactory;

    public TrustAllCertificatesSSLSocketFactory() {
        try {
            SSLContext ctx = SSLContext.getInstance(""SSL"");
            ctx.init(null, new TrustManager[] { new AllCertificatesTrustManager() }, new SecureRandom());
            socketFactory = ctx.getSocketFactory();
        } catch (Exception ex) {
            ex.printStackTrace(System.err); /* handle exception */
        }
    }

    public static SocketFactory getDefault() {
        return new TrustAllCertificatesSSLSocketFactory();
    }

    @Override
    public Socket createSocket(String string, int i) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i);
    }

    @Override
    public Socket createSocket(String string, int i, InetAddress ia, int i1) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i, ia, i1);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i) throws IOException {
        return socketFactory.createSocket(ia, i);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i, InetAddress ia1, int i1) throws IOException {
        return socketFactory.createSocket(ia, i, ia1, i1);
    }

    private class AllCertificatesTrustManager implements X509TrustManager {
        public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[0];
        }
    }
}
","
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.naming.directory.DirContext;
import javax.naming.ldap.InitialLdapContext;
import java.util.Hashtable;

public class LDAPConnection {
    private DirContext ldap;

    public boolean authenticate(String user, String password) {
        StringBuilder url = new StringBuilder(""ldap://"");
        url.append(""10.0.0.1"");
        url.append("":"");
        url.append(389);

        StringBuilder securityPrincipal = new StringBuilder(""uid="");
        securityPrincipal.append(user);
        securityPrincipal.append("","");
        securityPrincipal.append(""dc=XXXXX,dc=YYY,dc=ZZ"");

        Hashtable<String, String> env = new Hashtable<>();
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url.toString());
        env.put(Context.SECURITY_AUTHENTICATION, ""simple"");
        env.put(Context.SECURITY_PRINCIPAL, securityPrincipal.toString());
        env.put(Context.SECURITY_CREDENTIALS, password);

        System.out.println(url);
        System.out.println(securityPrincipal.toString());

        try {
            ldap = new InitialLdapContext(env, null);
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    public static void main(String[] args) {
        LDAPConnection ldapConnection = new LDAPConnection();
        boolean authenticated = ldapConnection.authenticate(""tiagoadami"", ""password"");

        if (authenticated) {
            System.out.println(""Authentication successful"");
        } else {
            System.out.println(""Authentication failed"");
        }
    }
}
"
24968466,24968616,"import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class stackoverflow_test {
    private byte[] encrypted;

    private String encryptedtext;
    private String decrypted;

    public String Encrypt(String pInput) {

        try {

            String Input = pInput;
            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(Input.getBytes());
            //encryptedtext = new String(encrypted);
            encryptedtext = DatatypeConverter.printBase64Binary(encrypted);
            System.err.println(""encrypted:"" + encryptedtext);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return encryptedtext;
    }

    public String Decrypt(String pInput) {

        try {

            String Input = pInput;

            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            encrypted = DatatypeConverter.parseBase64Binary(encryptedtext);
            decrypted = new String(cipher.doFinal(encrypted)); 
            System.err.println(""decrypted: "" + decrypted);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return pInput;
    }

    public static void main(String[] ag){
        stackoverflow_test test = new stackoverflow_test();
        String a = test.Encrypt(""Byte cannot directly convert to string"");
        String b = test.Decrypt(a);
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class Test {

    private byte[] encrypted;
    private String encryptedtext;
    private String decrypted;

    public String encrypt(String pInput) {
        try {
            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            // Create key and cipher
            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            // Encryption
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(pInput.getBytes());
            encryptedtext = new String(encrypted);
            System.err.println(""encrypted: "" + encryptedtext);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedtext;
    }

    public String decrypt(String pInput) {
        try {
            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            // Create key and cipher
            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            // Decryption
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            byte[] decryptedBytes = cipher.doFinal(pInput.getBytes());
            decrypted = new String(decryptedBytes);
            System.err.println(""decrypted: "" + decrypted);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return decrypted;
    }

    public static void main(String[] args) {
        Test test = new Test();
        String encryptedText = test.encrypt(""Hello World"");
        test.decrypt(encryptedText);
    }
}
"
24668843,24671967,"import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AES {
     public void run() {
         try {
             String text = ""Hello World"";
             String key = ""1234567891234567"";
             // Create key and cipher
             Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
             Cipher cipher = Cipher.getInstance(""AES"");

         // encrypt the text
         cipher.init(Cipher.ENCRYPT_MODE, aesKey);
         byte[] encrypted = cipher.doFinal(text.getBytes());
         System.out.println(""Encrypted text: "" + new String(encrypted));

         // decrypt the text
         cipher.init(Cipher.DECRYPT_MODE, aesKey);
         String decrypted = new String(cipher.doFinal(encrypted));
         System.out.println(""Decrypted text: "" + decrypted);
      }catch(Exception e) {
         e.printStackTrace();
      }
    }

    public static void main(String[] args) {
        AES app = new AES();
       app.run();
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class AESExample {
    private static final String AES_ALGORITHM = ""AES"";

    public static String encrypt(String input, String key) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedBytes = cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }

    public static String decrypt(String cipherText, String key) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] encryptedBytes = Base64.getDecoder().decode(cipherText);
        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) throws Exception {
        String input = ""Hello World"";
        String key = ""ThisIsASecretKey"";

        String encrypted = encrypt(input, key);
        System.out.println(""Encrypted: "" + encrypted);

        String decrypted = decrypt(encrypted, key);
        System.out.println(""Decrypted: "" + decrypted);
    }
}
"
15920739,23795194,"package com.infovale.cripto;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

public class RSA {


static String kPublic = """";
static String kPrivate = """";

public RSA()
{

}


public String Encrypt(String plain) throws NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {

    String encrypted;
    byte[] encryptedBytes;      

    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    KeyPair kp = kpg.genKeyPair();

    PublicKey publicKey = kp.getPublic();
    PrivateKey privateKey = kp.getPrivate();

    byte[] publicKeyBytes = publicKey.getEncoded();
    byte[] privateKeyBytes = privateKey.getEncoded();

    kPublic = bytesToString(publicKeyBytes);
    kPrivate = bytesToString(privateKeyBytes);

    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    encryptedBytes = cipher.doFinal(plain.getBytes());

    encrypted = bytesToString(encryptedBytes);
    return encrypted;

}

public String Decrypt(String result) throws NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {

    byte[] decryptedBytes;

    byte[] byteKeyPrivate = stringToBytes(kPrivate);

    KeyFactory kf = KeyFactory.getInstance(""RSA"");

    PrivateKey privateKey = null;
    try {

        privateKey = kf.generatePrivate(new PKCS8EncodedKeySpec(byteKeyPrivate));

    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    }

    String decrypted;

    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    decryptedBytes = cipher.doFinal(stringToBytes(result));
    decrypted = new String(decryptedBytes);
    return decrypted;

}

public String bytesToString(byte[] b) {
    byte[] b2 = new byte[b.length + 1];
    b2[0] = 1;
    System.arraycopy(b, 0, b2, 1, b.length);
    return new BigInteger(b2).toString(36);
}

public byte[] stringToBytes(String s) {
    byte[] b2 = new BigInteger(s, 36).toByteArray();
    return Arrays.copyOfRange(b2, 1, b2.length);
}
}
","
import java.io.IOException;
import java.math.BigInteger;
import java.util.Random;

public class RSA {
    private BigInteger p, q;
    private BigInteger n;
    private BigInteger phi;
    private BigInteger e, d;

    public RSA() {
        initialize();
    }

    public void initialize() {
        int size = 512;
        p = new BigInteger(size, 15, new Random());
        q = new BigInteger(size, 15, new Random());
        n = p.multiply(q);
        phi = p.subtract(BigInteger.valueOf(1)).multiply(q.subtract(BigInteger.valueOf(1)));
        do {
            e = new BigInteger(2 * size, new Random());
        } while (e.compareTo(phi) != 1 || e.gcd(phi).compareTo(BigInteger.valueOf(1)) != 0);
        d = e.modInverse(phi);
    }

    public BigInteger encrypt(BigInteger plaintext) {
        return plaintext.modPow(e, n);
    }

    public BigInteger decrypt(BigInteger ciphertext) {
        return ciphertext.modPow(d, n);
    }

    public static void main(String[] args) throws IOException {
        RSA rsa = new RSA();
        int plaintext;
        System.out.println(""Enter any character: "");
        plaintext = System.in.read();
        BigInteger bplaintext, bciphertext;
        bplaintext = BigInteger.valueOf((long) plaintext);
        bciphertext = rsa.encrypt(bplaintext);
        System.out.println(""Plaintext: "" + bplaintext.toString());
        System.out.println(""Ciphertext: "" + bciphertext.toString());
        bplaintext = rsa.decrypt(bciphertext);
        System.out.println(""After Decryption Plaintext: "" + bplaintext.toString());
    }
}
"
23482145,23482556,"import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Test003 {

    public static void main(String[] args) throws Exception {
        System.out.println(getPseudoUniqueString(""test1@test.com""));
        System.out.println(getPseudoUniqueString(""test2@test.com""));            
    }

    private static String getPseudoUniqueString(String str) 
        throws NoSuchAlgorithmException 
    {
        MessageDigest md1 = MessageDigest.getInstance(""MD5"");
        md1.update(str.getBytes());
        byte[] bd1 = md1.digest();

        StringBuffer hexString = new StringBuffer();
        for (int i=0;i<bd1.length;i++) {
            String hex=Integer.toHexString(0xff & bd1[i]);
            if(hex.length()==1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }

        return hexString.toString().substring(0,11);
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class UniqueIdentifierGenerator {
    
    public static void main(String[] args) {
        String email = ""example@example.com"";
        String uniqueIdentifier = generateUniqueIdentifier(email);
        System.out.println(uniqueIdentifier);
    }

    public static String generateUniqueIdentifier(String email) {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String identifierSeed = email + timestamp;
        
        // Generating MD5 hash
        String uniqueIdentifier = null;
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] hash = md.digest(identifierSeed.getBytes());
            
            // Converting hash bytes to alphanumeric string
            StringBuilder sb = new StringBuilder();
            for (byte b : hash) {
                sb.append(String.format(""%02x"", b & 0xff));
            }
            uniqueIdentifier = sb.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        
        // Trimming to 11 characters
        return uniqueIdentifier.substring(0, 11);
    }
}
"
23561104,32583766,"import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
public class StrongAES 
{
    public void run() 
    {
        try 
        {
            String text = ""Hello World"";
            String key = ""Bar12345Bar12345""; // 128 bit key
            // Create key and cipher
            Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(text.getBytes());

            StringBuilder sb = new StringBuilder();
            for (byte b: encrypted) {
                sb.append((char)b);
            }

            // the encrypted String
            String enc = sb.toString();
            System.out.println(""encrypted:"" + enc);

            // now convert the string to byte array
            // for decryption
            byte[] bb = new byte[enc.length()];
            for (int i=0; i<enc.length(); i++) {
                bb[i] = (byte) enc.charAt(i);
            }

            // decrypt the text
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(bb));
            System.err.println(""decrypted:"" + decrypted);

        }
        catch(Exception e) 
        {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) 
    {
        StrongAES app = new StrongAES();
        app.run();
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.util.Arrays;

public class EncryptionExample {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/ECB/PKCS5Padding"";

    public static String encrypt(String strToEncrypt, String secretKey) throws Exception {
        SecretKeySpec secretKeySpec = generateKey(secretKey);

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);

        byte[] encryptedBytes = cipher.doFinal(strToEncrypt.getBytes());

        return bytesToHex(encryptedBytes);
    }

    public static String decrypt(String strToDecrypt, String secretKey) throws Exception {
        SecretKeySpec secretKeySpec = generateKey(secretKey);

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);

        byte[] decryptedBytes = cipher.doFinal(hexToBytes(strToDecrypt));

        return new String(decryptedBytes);
    }

    private static SecretKeySpec generateKey(String secretKey) throws Exception {
        byte[] key = secretKey.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16); // AES-128
        return new SecretKeySpec(key, ALGORITHM);
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format(""%02X"", b));
        }
        return sb.toString();
    }

    private static byte[] hexToBytes(String hexString) {
        int len = hexString.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) +
                    Character.digit(hexString.charAt(i + 1), 16));
        }
        return data;
    }

    public static void main(String[] args) throws Exception {
        String secretKey = ""mySecretKey"";
        String originalString = ""Hello World!"";

        String encryptedString = encrypt(originalString, secretKey);
        System.out.println(""Encrypted String: "" + encryptedString);

        String decryptedString = decrypt(encryptedString, secretKey);
        System.out.println(""Decrypted String: "" + decryptedString);
    }
}
"
23561104,30591269,"package com.example;
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
public class StrongAES 
{
    public void run() 
    {
        try 
        {
            String text = ""Hello World"";
            String key = ""Bar12345Bar12345""; // 128 bit key
            // Create key and cipher
            Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(text.getBytes());
            System.err.println(new String(encrypted));
            // decrypt the text
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(encrypted));
            System.err.println(decrypted);
        }
        catch(Exception e) 
        {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) 
    {
        StrongAES app = new StrongAES();
        app.run();
    }
}
","

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class EncryptionExample {

    public static final String AES_KEY = ""ThisIsASecretKey"";
    
    public static String encrypt(String plaintext) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }

    public static String decrypt(String encryptedText) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(AES_KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedText);
        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) {
        try {
            String plaintext = ""Hello World!"";
            System.out.println(""Original: "" + plaintext);

            String encryptedText = encrypt(plaintext);
            System.out.println(""Encrypted: "" + encryptedText);

            String decryptedText = decrypt(encryptedText);
            System.out.println(""Decrypted: "" + decryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
26649389,29946540,"/*Copyright 2015 Bhavit Singh Sengar
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.*/

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;


public class NoSSLv3SocketFactory extends SSLSocketFactory{
    private final SSLSocketFactory delegate;

public NoSSLv3SocketFactory() {
    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
}

public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}

private class NoSSLv3SSLSocket extends DelegateSSLSocket {

    private NoSSLv3SSLSocket(SSLSocket delegate) {
        super(delegate);

    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        if (protocols != null && protocols.length == 1 && ""SSLv3"".equals(protocols[0])) {

            List<String> enabledProtocols = new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
            if (enabledProtocols.size() > 1) {
                enabledProtocols.remove(""SSLv3"");
                System.out.println(""Removed SSLv3 from enabled protocols"");
            } else {
                System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
            }
            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
        }

        super.setEnabledProtocols(protocols);
    }
}

public class DelegateSSLSocket extends SSLSocket {

    protected final SSLSocket delegate;

    DelegateSSLSocket(SSLSocket delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    @Override
    public String[] getEnabledCipherSuites() {
        return delegate.getEnabledCipherSuites();
    }

    @Override
    public void setEnabledCipherSuites(String[] suites) {
        delegate.setEnabledCipherSuites(suites);
    }

    @Override
    public String[] getSupportedProtocols() {
        return delegate.getSupportedProtocols();
    }

    @Override
    public String[] getEnabledProtocols() {
        return delegate.getEnabledProtocols();
    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        delegate.setEnabledProtocols(protocols);
    }

    @Override
    public SSLSession getSession() {
        return delegate.getSession();
    }

    @Override
    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.addHandshakeCompletedListener(listener);
    }

    @Override
    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.removeHandshakeCompletedListener(listener);
    }

    @Override
    public void startHandshake() throws IOException {
        delegate.startHandshake();
    }

    @Override
    public void setUseClientMode(boolean mode) {
        delegate.setUseClientMode(mode);
    }

    @Override
    public boolean getUseClientMode() {
        return delegate.getUseClientMode();
    }

    @Override
    public void setNeedClientAuth(boolean need) {
        delegate.setNeedClientAuth(need);
    }

    @Override
    public void setWantClientAuth(boolean want) {
        delegate.setWantClientAuth(want);
    }

    @Override
    public boolean getNeedClientAuth() {
        return delegate.getNeedClientAuth();
    }

    @Override
    public boolean getWantClientAuth() {
        return delegate.getWantClientAuth();
    }

    @Override
    public void setEnableSessionCreation(boolean flag) {
        delegate.setEnableSessionCreation(flag);
    }

    @Override
    public boolean getEnableSessionCreation() {
        return delegate.getEnableSessionCreation();
    }

    @Override
    public void bind(SocketAddress localAddr) throws IOException {
        delegate.bind(localAddr);
    }

    @Override
    public synchronized void close() throws IOException {
        delegate.close();
    }

    @Override
    public void connect(SocketAddress remoteAddr) throws IOException {
        delegate.connect(remoteAddr);
    }

    @Override
    public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
        delegate.connect(remoteAddr, timeout);
    }

    @Override
    public SocketChannel getChannel() {
        return delegate.getChannel();
    }

    @Override
    public InetAddress getInetAddress() {
        return delegate.getInetAddress();
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return delegate.getInputStream();
    }

    @Override
    public boolean getKeepAlive() throws SocketException {
        return delegate.getKeepAlive();
    }

    @Override
    public InetAddress getLocalAddress() {
        return delegate.getLocalAddress();
    }

    @Override
    public int getLocalPort() {
        return delegate.getLocalPort();
    }

    @Override
    public SocketAddress getLocalSocketAddress() {
        return delegate.getLocalSocketAddress();
    }

    @Override
    public boolean getOOBInline() throws SocketException {
        return delegate.getOOBInline();
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        return delegate.getOutputStream();
    }

    @Override
    public int getPort() {
        return delegate.getPort();
    }

    @Override
    public synchronized int getReceiveBufferSize() throws SocketException {
        return delegate.getReceiveBufferSize();
    }

    @Override
    public SocketAddress getRemoteSocketAddress() {
        return delegate.getRemoteSocketAddress();
    }

    @Override
    public boolean getReuseAddress() throws SocketException {
        return delegate.getReuseAddress();
    }

    @Override
    public synchronized int getSendBufferSize() throws SocketException {
        return delegate.getSendBufferSize();
    }

    @Override
    public int getSoLinger() throws SocketException {
        return delegate.getSoLinger();
    }

    @Override
    public synchronized int getSoTimeout() throws SocketException {
        return delegate.getSoTimeout();
    }

    @Override
    public boolean getTcpNoDelay() throws SocketException {
        return delegate.getTcpNoDelay();
    }

    @Override
    public int getTrafficClass() throws SocketException {
        return delegate.getTrafficClass();
    }

    @Override
    public boolean isBound() {
        return delegate.isBound();
    }

    @Override
    public boolean isClosed() {
        return delegate.isClosed();
    }

    @Override
    public boolean isConnected() {
        return delegate.isConnected();
    }

    @Override
    public boolean isInputShutdown() {
        return delegate.isInputShutdown();
    }

    @Override
    public boolean isOutputShutdown() {
        return delegate.isOutputShutdown();
    }

    @Override
    public void sendUrgentData(int value) throws IOException {
        delegate.sendUrgentData(value);
    }

    @Override
    public void setKeepAlive(boolean keepAlive) throws SocketException {
        delegate.setKeepAlive(keepAlive);
    }

    @Override
    public void setOOBInline(boolean oobinline) throws SocketException {
        delegate.setOOBInline(oobinline);
    }

    @Override
    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
    }

    @Override
    public synchronized void setReceiveBufferSize(int size) throws SocketException {
        delegate.setReceiveBufferSize(size);
    }

    @Override
    public void setReuseAddress(boolean reuse) throws SocketException {
        delegate.setReuseAddress(reuse);
    }

    @Override
    public synchronized void setSendBufferSize(int size) throws SocketException {
        delegate.setSendBufferSize(size);
    }

    @Override
    public void setSoLinger(boolean on, int timeout) throws SocketException {
        delegate.setSoLinger(on, timeout);
    }

    @Override
    public synchronized void setSoTimeout(int timeout) throws SocketException {
        delegate.setSoTimeout(timeout);
    }

    @Override
    public void setTcpNoDelay(boolean on) throws SocketException {
        delegate.setTcpNoDelay(on);
    }

    @Override
    public void setTrafficClass(int value) throws SocketException {
        delegate.setTrafficClass(value);
    }

    @Override
    public void shutdownInput() throws IOException {
        delegate.shutdownInput();
    }

    @Override
    public void shutdownOutput() throws IOException {
        delegate.shutdownOutput();
    }

    @Override
    public String toString() {
        return delegate.toString();
    }

    @Override
    public boolean equals(Object o) {
        return delegate.equals(o);
    }
}
}
","
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Arrays;

public class TLSSocketFactory extends SSLSocketFactory {

    private final SSLSocketFactory delegate;

    public TLSSocketFactory() throws IOException {
        try {
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, null, null);
            delegate = context.getSocketFactory();
        } catch (Exception e) {
            throw new IOException(""Failed to create TLSSocketFactory"", e);
        }
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return delegate.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(delegate.createSocket(socket, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return enableTLSOnSocket(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(delegate.createSocket(host, port, localAddress, localPort));
    }

    @Override
    public Socket createSocket(InetAddress address, int port) throws IOException {
        return enableTLSOnSocket(delegate.createSocket(address, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
    }

    private static Socket enableTLSOnSocket(Socket socket) {
        if (socket instanceof SSLSocket) {
            // Enable only TLSv1 protocol
            ((SSLSocket) socket).setEnabledProtocols(new String[]{""TLSv1""});
        }
        return socket;
    }
}
"
26649389,40886791,"import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class HttpsTrustManager implements X509TrustManager {

private static TrustManager[] trustManagers;
private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

@Override
public void checkClientTrusted(
        java.security.cert.X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {

}

@Override
public void checkServerTrusted(
        java.security.cert.X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {

}

public boolean isClientTrusted(X509Certificate[] chain) {
    return true;
}

public boolean isServerTrusted(X509Certificate[] chain) {
    return true;
}

@Override
public X509Certificate[] getAcceptedIssuers() {
    return _AcceptedIssuers;
}

public static void allowAllSSL() {
    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

        @Override
        public boolean verify(String arg0, SSLSession arg1) {
            return true;
        }

    });

    SSLContext context = null;
    if (trustManagers == null) {
        trustManagers = new TrustManager[]{new HttpsTrustManager()};
    }

    try {
        context = SSLContext.getInstance(""TLS"");
        context.init(null, trustManagers, new SecureRandom());
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (KeyManagementException e) {
        e.printStackTrace();
    }

    HttpsURLConnection.setDefaultSSLSocketFactory(context
            .getSocketFactory());
}

}
","
import android.os.Build;
import android.util.Log;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLEngine;

public class SSLv3Compat {

    public static void disableSSLv3() {
        try {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN && Build.VERSION.SDK_INT <= Build.VERSION_CODES.KITKAT) {
                SSLContext context = SSLContext.getInstance(""TLSv1"");
                context.init(null, null, null);
                SSLEngine engine = context.createSSLEngine();
                Method method = engine.getClass().getMethod(""setEnabledProtocols"", String[].class);
                method.invoke(engine, new Object[]{new String[]{""TLSv1""}});
                Log.d(""SSLv3Compat"", ""SSLv3 has been disabled."");
            }
        } catch (Exception e) {
            Log.d(""SSLv3Compat"", ""Failed to disable SSLv3: "" + e.getMessage());
        }
    }
}
"
32508961,32565922,"import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Base64;
import java.util.Base64.Decoder;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TestAesDecrypt {

    public static void main(final String[] args) throws Exception {
        final byte[] pass = ""testpass"".getBytes(StandardCharsets.US_ASCII);
        final byte[] magic = ""Salted__"".getBytes(StandardCharsets.US_ASCII);
        final String inFile = ""e:/t/e.txt"";

        String source = new String(Files.readAllBytes(Paths.get(inFile)),
                StandardCharsets.US_ASCII);
        source = source.replaceAll(""\\s"", """");
        final Decoder decoder = Base64.getDecoder();
        final byte[] inBytes = decoder.decode(source);

        final byte[] shouldBeMagic = Arrays.copyOfRange(inBytes, 0,
                magic.length);
        if (!Arrays.equals(shouldBeMagic, magic)) {
            System.out.println(""Bad magic number"");
            return;
        }

        final byte[] salt = Arrays.copyOfRange(inBytes, magic.length,
                magic.length + 8);

        final byte[] passAndSalt = concat(pass, salt);

        byte[] hash = new byte[0];
        byte[] keyAndIv = new byte[0];
        for (int i = 0; i < 3; i++) {
            final byte[] data = concat(hash, passAndSalt);
            final MessageDigest md = MessageDigest.getInstance(""MD5"");
            hash = md.digest(data);
            keyAndIv = concat(keyAndIv, hash);
        }

        final byte[] keyValue = Arrays.copyOfRange(keyAndIv, 0, 32);
        final byte[] iv = Arrays.copyOfRange(keyAndIv, 32, 48);
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final SecretKeySpec key = new SecretKeySpec(keyValue, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        final byte[] clear = cipher.doFinal(inBytes, 16, inBytes.length - 16);
        final String clearText = new String(clear, StandardCharsets.ISO_8859_1);
        System.out.println(clearText);
    }

    private static byte[] concat(final byte[] a, final byte[] b) {
        final byte[] c = new byte[a.length + b.length];
        System.arraycopy(a, 0, c, 0, a.length);
        System.arraycopy(b, 0, c, a.length, b.length);
        return c;
    }
}
","
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.spec.KeySpec;
import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Main {
    public static void main(String[] args) throws Exception {
        String password = ""testpass"";
        String salt = ""15charRandomSalt"";
        int iterations = 1;

        /* Derive the key, given password and salt. */
        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt.getBytes(StandardCharsets.UTF_8), iterations, 256);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        /* Encrypt the message. */
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] cipherText = cipher.doFinal(getToBeEncrypted().getBytes(StandardCharsets.UTF_8));

        String base64CipherText = Base64.getEncoder().encodeToString(cipherText);
        String base64IV = Base64.getEncoder().encodeToString(iv);


        System.out.println(base64CipherText);
        System.out.println(base64IV);
    }
    
    private static String getToBeEncrypted() {
        return ""AMOUNT=10&TID=#19:23&CURRENCY=EUR&LANGUAGE=DE&SUCCESS_URL=http://some.url/success&ERROR_URL=http://some.url/error&CONFIRMATION_URL=http://some.url/confirm&NAME=customer full name"";
    }
}
"
9210514,36874647,"/*
 * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Sun Microsystems nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



import java.io.*;
import java.net.URL;

import java.security.*;
import java.security.cert.*;

import javax.net.ssl.*;

public class InstallCert {

    public static void main(String[] args) throws Exception {
    String host;
    int port;
    char[] passphrase;
    if ((args.length == 1) || (args.length == 2)) {
        String[] c = args[0].split("":"");
        host = c[0];
        port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);
        String p = (args.length == 1) ? ""changeit"" : args[1];
        passphrase = p.toCharArray();
    } else {
        System.out.println(""Usage: java InstallCert <host>[:port] [passphrase]"");
        return;
    }

    File file = new File(""jssecacerts"");
    if (file.isFile() == false) {
        char SEP = File.separatorChar;
        File dir = new File(System.getProperty(""java.home"") + SEP
            + ""lib"" + SEP + ""security"");
        file = new File(dir, ""jssecacerts"");
        if (file.isFile() == false) {
        file = new File(dir, ""cacerts"");
        }
    }
    System.out.println(""Loading KeyStore "" + file + ""..."");
    InputStream in = new FileInputStream(file);
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
    ks.load(in, passphrase);
    in.close();

    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManagerFactory tmf =
        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);
    X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];
    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
    context.init(null, new TrustManager[] {tm}, null);
    SSLSocketFactory factory = context.getSocketFactory();

    System.out.println(""Opening connection to "" + host + "":"" + port + ""..."");
    SSLSocket socket = (SSLSocket)factory.createSocket(host, port);
    socket.setSoTimeout(10000);
    try {
        System.out.println(""Starting SSL handshake..."");
        socket.startHandshake();
        socket.close();
        System.out.println();
        System.out.println(""No errors, certificate is already trusted"");
    } catch (SSLException e) {
        System.out.println();
        e.printStackTrace(System.out);
    }

    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader =
        new BufferedReader(new InputStreamReader(System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i < chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println
            ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);

    OutputStream out = new FileOutputStream(""jssecacerts"");
    ks.store(out, passphrase);
    out.close();

    System.out.println();
    System.out.println(cert);
    System.out.println();
    System.out.println
        (""Added certificate to keystore 'jssecacerts' using alias '""
        + alias + ""'"");
    }

    private static final char[] HEXDIGITS = ""0123456789abcdef"".toCharArray();

    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

    private final X509TrustManager tm;
    private X509Certificate[] chain;

    SavingTrustManager(X509TrustManager tm) {
        this.tm = tm;
    }

    public X509Certificate[] getAcceptedIssuers() {
        throw new UnsupportedOperationException();
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }
    }

}
","
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class Main {
    public static void main(String[] args) throws Exception {
        // Create a custom TrustManager to trust all certificates
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }

            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        }};

        // Create an SSLContext with the custom TrustManager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());

        // Set the default SSL socket factory to use the SSLContext
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

        // Create a URL object of the server's endpoint
        URL url = new URL(""https://yourserver.com/api/endpoint"");

        // Open a connection to the server
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();

        // Set the request method to POST
        connection.setRequestMethod(""POST"");
        
        // ... add your request headers and data ...

        // Send the request
        int responseCode = connection.getResponseCode();

        // Print the response
        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line;
        StringBuilder response = new StringBuilder();
        while ((line = reader.readLine()) != null) {
            response.append(line);
        }
        reader.close();

        System.out.println(""Response code: "" + responseCode);
        System.out.println(""Response: "" + response.toString());
        
        // Close the connection
        connection.disconnect();
    }
}
"
40123319,42153463,"import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESHelper {

public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}

private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"",""Crypto"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt) {
    return toHex(txt.getBytes());
}
public static String fromHex(String hex) {
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i < len; i++)
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
    return result;
}

public static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2*buf.length);
    for (int i = 0; i < buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
}
}
","
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class EncryptionExample {

    public static void main(String[] args) throws Exception {
        String AndroidId = ""00:00:00:00:00:00""; // Replace with actual MAC address

        String key = ""0123456789abcdef""; // 16-byte encryption key (can be any value)
        String encrypted = encrypt(AndroidId, key);
        System.out.println(""Encrypted: "" + encrypted);
    }

    public static String encrypt(String data, String key) throws Exception {
        byte[] keyBytes = key.getBytes(StandardCharsets.UTF_8);
        SecretKey secretKey = new SecretKeySpec(keyBytes, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        byte[] encryptedBytes = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }
}
"
43418958,43426890,"package nl.owlstead.stackoverflow;

import java.nio.ByteBuffer;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * A well-defined pseudo-random generator that is based on a stream cipher.
 * <p>
 * This class mimics the {@link Random} class method signatures; it however does currently not provide:
 * <ul>
 * <li>operations returning floats or doubles including returning a Gaussian value in the range [0, 1.0) </li>
 * <li>streams of integers or longs</li>
 * </ul>
 * due to laziness of the developer.
 * It does not allow for re-seeding as re-seeding is not defined for a stream cipher;
 * the same goes from retrieving a seed from the underlying entropy source as it hasn't got one.
 * <p>
 * It is assumed that most significant (leftmost) bytes are taken from the stream cipher first.
 * All the algorithms used to return the random values are well defined, so that compatible implementations can be generated.
 * <p>
 * Instances of this class are stateful and not thread safe.
 * 
 * @author Maarten Bodewes
 */
public class StreamCipherPseudoRandom {

    private static final long TWO_POW_48 = 1L << 48;

    private final Cipher streamCipher;

    // must be a buffer of at least 6 bytes
    // a buffer that is x times 16 is probably most efficient for AES/CTR mode encryption within getBytes(byte[])
    private final ByteBuffer zeros = ByteBuffer.allocate(64);

    /**
     * Creates a SecureRandom from a stream cipher.
     * 
     * @param streamCipher an initialized stream cipher
     * @throws NullPointerException if the cipher is <code>null</code>
     * @throws IllegalStateException if the cipher is not initialized
     * @throws IllegalArgumentException if the cipher is not a stream cipher
     */
    public StreamCipherPseudoRandom(final Cipher streamCipher) {
        if (streamCipher.getOutputSize(1) != 1) {
            throw new IllegalArgumentException(""Not a stream cipher"");
        }
        this.streamCipher = streamCipher;
    }

    /**
     * Generates a pseudo-random number of bytes by taking exactly the required number of bytes from the stream cipher.
     * 
     * @param data the buffer to be randomized
     */
    public void nextBytes(final byte[] data) {
        generateRandomInBuffer(ByteBuffer.wrap(data));
    }

    /**
     * Generates a pseudo-random boolean value by taking exactly 1 byte from the stream cipher,
     * returning true if and only if the returned value is odd (i.e. if the least significant bit is set to 1), false otherwise.
     * 
     * @return the random boolean
     */
    public boolean nextBoolean() {
        return (generateRandomInBuffer(ByteBuffer.allocate(Byte.BYTES)).get() & 1) == 1;
    }

    /**
     * Generates a pseudo-random <code>int</code> value by taking exactly 4 bytes from the stream cipher.
     * 
     * @return the random <code>int</code> value
     */
    public int nextInt() {
        return generateRandomInBuffer(ByteBuffer.allocate(Integer.BYTES)).getInt();
    }

    /**
     * Generates a pseudo-random <code>long</code> value by taking exactly 8 bytes from the stream cipher.
     * 
     * @return the random <code>long</code> value
     */
    public long nextLong() {
        return generateRandomInBuffer(ByteBuffer.allocate(Long.BYTES)).getLong();
    }

    /**
     * Generates a pseudo-random <code>int</code> value with <code>bits</code> random bits in the lower part of the returned integer.
     * This method takes the minimum number of bytes required to hold the required number of bits from the stream cipher (e.g. 13 bits requires 2 bytes to hold them).
     * 
     * @param bits the number of bits in the integer, between 0 and 32 
     * @return the random <code>int</code> value in the range [0, 2^n) where n is the number of bits
     */
    public int next(final int bits) {
        final int bytes = (bits + Byte.SIZE - 1) / Byte.SIZE;
        final ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES);
        buf.position(Integer.BYTES - bytes);
        generateRandomInBuffer(buf);
        final long l = buf.getInt(0);
        final long m = (1L << bits) - 1;
        return (int) (l & m);
    }

    /**
     * Generates a pseudo-random <code>int</code> value in a range [0, n) by:
     * 
     * <ol>
     * <li>taking 6 bytes from the stream cipher and converting it into a number y</li>
     * <li>restart the procedure if y is larger than x * n where x is the largest value such that x * n <= 2^48
     * <li>return y % n
     * </ol>
     * 
     * An exception to this rule is for n is 1 in which case this method direct returns 0, without taking any bytes from the stream cipher.

     * @param n the maximum value (exclusive) - n must be a non-zero positive number
     * @return the random <code>int</code> value in the range [0, n)
     * @throws IllegalArgumentException if n is zero or negative 
     */
    public int nextInt(final int n) {
        if (n <= 0) {
            throw new IllegalArgumentException(""max cannot be negative"");
        } else if (n == 1) {
            // only one choice
            return 0;
        }

        final ByteBuffer buf = ByteBuffer.allocate(48 / Byte.SIZE);
        long maxC = TWO_POW_48 - TWO_POW_48 % n;

        long l;
        do {
            buf.clear();
            generateRandomInBuffer(buf);
            // put 16 bits into position 32 to 47
            l = (buf.getShort() & 0xFFFFL) << Integer.SIZE;
            // put 32 bits into position 0 to 31
            l |= buf.getInt() & 0xFFFFFFFFL;
        } while (l > maxC);

       return (int) (l % n);
    }

    /**
     * Retrieves random bytes from the underlying stream cipher.
     * All methods that affect the stream cipher should use this method.
     * The bytes between the position and the limit will contain the random bytes; position and limit are left unchanged.
     * <p>
     * The buffer may not be read only and must support setting a mark; previous marks are discarded.
     * 
     * @param buf the buffer to receive the bytes between the position and limit 
     * @return the same buffer, to allow for 
     */
    protected ByteBuffer generateRandomInBuffer(final ByteBuffer buf) {
        while (buf.hasRemaining()) {
            // clear the zeros buffer
            zeros.clear();
            // set the number of zeros to process
            zeros.limit(Math.min(buf.remaining(), zeros.capacity()));
            try {
                // process the zero's into buf (note that the input size is leading)
                buf.mark();
                streamCipher.update(zeros, buf);
            } catch (ShortBufferException e) {
                // not enough output size, which cannot be true for a stream cipher
                throw new IllegalStateException(
                        String.format(""Cipher %s not behaving as a stream cipher"", streamCipher.getAlgorithm()));
            }
        }
        buf.reset();
        return buf;
    }

    public static void main(String[] args) throws Exception {
        Cipher streamCipher = Cipher.getInstance(""AES/CTR/NoPadding"");
        // zero key and iv for demo purposes only
        SecretKey aesKey = new SecretKeySpec(new byte[24], ""AES"");
        IvParameterSpec iv = new IvParameterSpec(new byte[16]);
        streamCipher.init(Cipher.ENCRYPT_MODE, aesKey, iv);

        StreamCipherPseudoRandom rng = new StreamCipherPseudoRandom(streamCipher);
        // chosen by fair dice roll, guaranteed to be random
        System.out.println(rng.nextInt(6) + 1);
    }
}
","
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

public class RandomGenerator {
    private static final String HMAC_ALGORITHM = ""HmacSHA256"";
    private static final String SECRET_KEY = ""mySecretKey"";

    public static void main(String[] args) throws Exception {
        // Generate a random initialization vector (IV)
        SecureRandom random = new SecureRandom();
        byte[] iv = new byte[16];
        random.nextBytes(iv);

        // Generate the same random number series on two different devices
        long[] randomSeries = generateRandomSeries(iv);

        // Print the random numbers
        for (long randomNumber : randomSeries) {
            System.out.println(randomNumber);
        }
    }

    private static long[] generateRandomSeries(byte[] iv) throws Exception {
        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"");

        // Generate a shared secret key using a cryptographic algorithm
        SecretKeySpec secretKey = new SecretKeySpec(SECRET_KEY.getBytes(), HMAC_ALGORITHM);
        Mac hmac = Mac.getInstance(HMAC_ALGORITHM);
        hmac.init(secretKey);

        byte[] currentIV = iv.clone();
        long[] randomSeries = new long[10];

        // Generate 10 random numbers
        for (int i = 0; i < 10; i++) {
            // Generate a random byte array using the current IV
            byte[] randomBytes = new byte[8];
            random.nextBytes(randomBytes);

            // Apply HMAC to the random byte array, using the shared secret key
            hmac.reset();
            hmac.update(currentIV);
            byte[] hmacResult = hmac.doFinal(randomBytes);

            // Convert the HMAC result bytes to a long value
            long randomNumber = bytesToLong(hmacResult);
            randomSeries[i] = randomNumber;

            // Update the current IV with the HMAC result
            currentIV = hmacResult;
        }

        return randomSeries;
    }

    private static long bytesToLong(byte[] bytes) {
        long value = 0;
        for (int i = 0; i < 8; i++) {
            value = (value << 8) + (bytes[i] & 0xff);
        }
        return value;
    }
}
"
42805652,42805905,"import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import cz.msebera.android.httpclient.HttpVersion;
import cz.msebera.android.httpclient.conn.ClientConnectionManager;
import cz.msebera.android.httpclient.conn.scheme.PlainSocketFactory;
import cz.msebera.android.httpclient.conn.scheme.Scheme;
import cz.msebera.android.httpclient.conn.scheme.SchemeRegistry;
import cz.msebera.android.httpclient.conn.ssl.SSLSocketFactory;
import cz.msebera.android.httpclient.impl.client.DefaultHttpClient;
import cz.msebera.android.httpclient.impl.conn.tsccm.ThreadSafeClientConnManager;
import cz.msebera.android.httpclient.params.BasicHttpParams;
import cz.msebera.android.httpclient.params.HttpParams;
import cz.msebera.android.httpclient.params.HttpProtocolParams;
import cz.msebera.android.httpclient.protocol.HTTP;


/**
 * Created by prerak on 15/03/2017.
 */

public class MyCustomSSLFactory extends SSLSocketFactory {
    final SSLContext sslContext = SSLContext.getInstance(""TLS"");

    /**
     * Creates a new SSL Socket Factory with the given KeyStore.
     *
     * @param truststore A KeyStore to create the SSL Socket Factory in context of
     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
     * @throws KeyManagementException    KeyManagementException
     * @throws KeyStoreException         KeyStoreException
     * @throws UnrecoverableKeyException UnrecoverableKeyException
     */
    public MyCustomSSLFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        X509TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                try {
                    chain[0].checkValidity();
                } catch (Exception e) {
                    throw new CertificateException(""Certificate not valid or trusted."");
                }
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[]{tm}, null);
    }

    /**
     * Gets a KeyStore containing the Certificate
     *
     * @param cert InputStream of the Certificate
     * @return KeyStore
     */
    public static KeyStore getKeystoreOfCA(InputStream cert) {

        // Load CAs from an InputStream
        InputStream caInput = null;
        Certificate ca = null;
        try {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            caInput = new BufferedInputStream(cert);
            ca = cf.generateCertificate(caInput);
        } catch (CertificateException e1) {
            e1.printStackTrace();
        } finally {
            try {
                if (caInput != null) {
                    caInput.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = null;
        try {
            keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return keyStore;
    }

    /**
     * Gets a Default KeyStore
     *
     * @return KeyStore
     */
    public static KeyStore getKeystore() {
        KeyStore trustStore = null;
        try {
            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        return trustStore;
    }

    /**
     * Returns a SSlSocketFactory which trusts all certificates
     *
     * @return SSLSocketFactory
     */
    public static SSLSocketFactory getFixedSocketFactory() {
        SSLSocketFactory socketFactory;
        try {
            socketFactory = new MyCustomSSLFactory(getKeystore());
            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        } catch (Throwable t) {
            t.printStackTrace();
            socketFactory = SSLSocketFactory.getSocketFactory();
        }
        return socketFactory;
    }

    /**
     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
     *
     * @param keyStore custom provided KeyStore instance
     * @return DefaultHttpClient
     */
    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {

        try {
            SSLSocketFactory sf = new MyCustomSSLFactory(keyStore);
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    /**
     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
     */
    public void fixHttpsURLConnection() {
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    }
}
","
import com.loopj.android.http.AsyncHttpClient;
import com.loopj.android.http.AsyncHttpResponseHandler;

import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.InputStream;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;

import cz.msebera.android.httpclient.Header;
import cz.msebera.android.httpclient.conn.ssl.SSLSocketFactory;

public class Main {
    public static void main(String[] args) throws Exception {
        // Load CAs from an InputStream
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        InputStream caInput = new BufferedInputStream(new FileInputStream(""load-der.crt""));
        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ca);
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create an SSLSocketFactory that uses our KeyStore
        SSLSocketFactory socketFactory = new SSLSocketFactory(keyStore);
        
        // Create an AsyncHttpClient instance
        AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
        
        // Set the SSLSocketFactory for the AsyncHttpClient
        asyncHttpClient.setSSLSocketFactory(socketFactory);

        // Make an HTTPS request
        String url = ""https://example.com/api"";
        asyncHttpClient.get(url, new AsyncHttpResponseHandler() {
            @Override
            public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {
                // Handle successful response
            }

            @Override
            public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {
                // Handle failure
            }
        });
    }
}
"
42416313,42417725,"import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class Md5Encryption 
{
    private static final String ALGORITHM = ""md5"";
    private static final String DIGEST_STRING = ""HG58YZ3CR9"";
    private static final String CHARSET_UTF_8 = ""utf-8"";
    private static final String SECRET_KEY_ALGORITHM = ""DESede"";
    private static final String TRANSFORMATION_PADDING = ""DESede/CBC/PKCS5Padding"";

    /* Encryption Method */
    public byte[] encrypt(String message) throws Exception 
    { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        cipher.init(Cipher.ENCRYPT_MODE, key, iv); 

        final byte[] plainTextBytes = message.getBytes(CHARSET_UTF_8); 
        final byte[] cipherText = cipher.doFinal(plainTextBytes); 

        return cipherText; 
    } 

   /* Decryption Method */
    public String decrypt(byte[]  message) throws Exception { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        decipher.init(Cipher.DECRYPT_MODE, key, iv); 

        final byte[] plainText = decipher.doFinal(message); 

        return new String(plainText, CHARSET_UTF_8); 
    }

    public static void main(String[] args) throws Exception {


        String text = ""TEST STRING TO ENCRYPT"";
        byte[] codedtext = new Md5Encryption().encrypt(text);
//        String codedtext = "".U$LU`8?"";
        String decodedtext = new Md5Encryption().decrypt(codedtext); 

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array 
        System.out.println(decodedtext); // This correctly shows ""TEST STRING TO ENCRYPT"" 
    } 


}
","
import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Md5Encryption {
    private static final String ALGORITHM = ""md5"";
    private static final String DIGEST_STRING = ""HG58YZ3CR9"";
    private static final String CHARSET_UTF_8 = ""utf-8"";
    private static final String SECRET_KEY_ALGORITHM = ""DESede"";
    private static final String TRANSFORMATION_PADDING = ""DESede/CBC/PKCS5Padding"";

    /* Encryption Method */
    public String encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM);
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j < 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM);
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING);
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(CHARSET_UTF_8);
        final byte[] cipherText = cipher.doFinal(plainTextBytes);

        return new String(cipherText);
    }

    /* Decryption Method */
    public String decrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM);
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j < 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM);
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING);
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        final byte[] cipherText = message.getBytes(CHARSET_UTF_8);
        final byte[] plainText = decipher.doFinal(cipherText);

        return new String(plainText, CHARSET_UTF_8);
    }

    public static void main(String[] args) throws Exception {
        String text = ""TEST STRING TO ENCRYPT"";
        String codedtext = new Md5Encryption().encrypt(text);
        String decodedtext = new Md5Encryption().decrypt(codedtext);

        System.out.println(codedtext);
        System.out.println(decodedtext);
    }
}
"
41270781,41270878,"import java.math.BigInteger;
import java.security.MessageDigest;

public class MDTest {
    public static void main(String args[]) throws Exception {
       String s=""This is 'a' test"";
       MessageDigest m=MessageDigest.getInstance(""MD5"");
       m.update(s.getBytes(),0,s.length());
       System.out.println(""MD5: ""+new BigInteger(1,m.digest()).toString(16));
   }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import org.apache.commons.codec.digest.DigestUtils;

public class MD5HashExample {

    public static void main(String[] args) {
        String input = ""string with special characters like '"";
        try {
            String md5Hash = getMD5(input);
            System.out.println(""MD5 hash: "" + md5Hash);
        } catch (NoSuchAlgorithmException e) {
            System.out.println(""MD5 algorithm not available."");
        }
    }

    private static String getMD5(String input) throws NoSuchAlgorithmException {
        MessageDigest md5Digest = MessageDigest.getInstance(""MD5"");
        byte[] hashBytes = md5Digest.digest(input.getBytes());
        return DigestUtils.md5Hex(hashBytes);
    }
}
"
13022717,39851163,"    package javaapplication8;

    import java.io.InputStream;
    import java.net.Socket;
    import java.net.URL;
    import java.net.URLConnection;
    import java.security.cert.CertificateException;
    import java.security.cert.X509Certificate;
    import javax.net.ssl.HostnameVerifier;
    import javax.net.ssl.HttpsURLConnection;
    import javax.net.ssl.SSLContext;
    import javax.net.ssl.SSLEngine;
    import javax.net.ssl.SSLSession;
    import javax.net.ssl.TrustManager;
    import javax.net.ssl.X509ExtendedTrustManager;

    /**
     *
     * @author hoshantm
     */
    public class JavaApplication8 {

        /**
         * @param args the command line arguments
         * @throws java.lang.Exception
         */
        public static void main(String[] args) throws Exception {
            /*
             *  fix for
             *    Exception in thread ""main"" javax.net.ssl.SSLHandshakeException:
             *       sun.security.validator.ValidatorException:
             *           PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:
             *               unable to find valid certification path to requested target
             */
            TrustManager[] trustAllCerts = new TrustManager[]{
                new X509ExtendedTrustManager() {
                    @Override
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] xcs, String string, Socket socket) throws CertificateException {

                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] xcs, String string, Socket socket) throws CertificateException {

                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] xcs, String string, SSLEngine ssle) throws CertificateException {

                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] xcs, String string, SSLEngine ssle) throws CertificateException {

                    }

                }
            };

            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Create all-trusting host name verifier
            HostnameVerifier allHostsValid = new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            };
            // Install the all-trusting host verifier
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
            /*
             * end of the fix
             */

            URL url = new URL(""https://10.52.182.224/cgi-bin/dynamic/config/panel.bmp"");
            URLConnection con = url.openConnection();
            //Reader reader = new ImageStreamReader(con.getInputStream());

            InputStream is = new URL(url.toString()).openStream();

            // Whatever you may want to do next

        }

    }
","
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class TestSSL {

    public static void main(String[] args) throws Exception {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(X509Certificate[] certs, String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs, String authType) {
            }
        } };

        // Install the all-trusting trust manager
        final SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        URL url = new URL(""https://www.google.com"");
        URLConnection con = url.openConnection();
        final Reader reader = new InputStreamReader(con.getInputStream());
        final BufferedReader br = new BufferedReader(reader);
        String line = """";
        while ((line = br.readLine()) != null) {
            System.out.println(line);
        }
        br.close();
    }
}
"
38179237,38181016,"package sample;

import java.io.FileInputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
 import java.io.File;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
public class MD5 {
    public static String getMD5(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] messageDigest = md.digest(input.getBytes());
            BigInteger number = new BigInteger(1, messageDigest);
            String hashtext = number.toString(16);
            // Now we need to zero pad it if you actually want the full 32 chars.
            while (hashtext.length() < 32) {
                hashtext = ""0"" + hashtext;
            }
            return hashtext;
        }
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
     public static void main(String[] args) throws Exception{
         if (args.length != 3) {
             System.out.println(""Usage: java XSLTransformer inputfile.xml inputfile.xsl outputfile"");
             System.exit(1);
         }
         Transformer transformer =
             TransformerFactory.newInstance().newTransformer(new StreamSource(new File(args[1])));
         transformer.transform(new StreamSource(new File(args[0])),
                               new StreamResult(new File(args[2])));
         }
 }","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class MD5Util {
    
    public static String generateMD5(String input) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance(""MD5"");
        md.update(input.getBytes());
        byte[] digest = md.digest();
        StringBuilder sb = new StringBuilder();
        for (byte b : digest) {
            sb.append(String.format(""%02x"", b & 0xff));
        }
        return sb.toString();
    }
}
"
37562926,37563509,"import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public class DownloadFileExample
{
    public static void download(String downloadURL) throws IOException
    {
        URL website = new URL(downloadURL);
        String fileName = ""downloaded.zip"";

        try (InputStream inputStream = website.openStream())
        {
            Files.copy(inputStream, Paths.get(fileName), StandardCopyOption.REPLACE_EXISTING);
        }
    }

    private static void trustAllCertificates() throws NoSuchAlgorithmException, KeyManagementException
    {
        TrustManager[] trustManagers = new TrustManager[]{new X509TrustManager()
        {
            public X509Certificate[] getAcceptedIssuers()
            {
                return new X509Certificate[0];
            }

            public void checkClientTrusted(
                    X509Certificate[] certs, String authType)
            {
            }

            public void checkServerTrusted(
                    X509Certificate[] certs, String authType)
            {
            }
        }};

        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        sslContext.init(null, trustManagers, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    }

    public static void main(String[] arguments) throws IOException, NoSuchAlgorithmException, KeyManagementException
    {
        trustAllCertificates();

        String downloadURL = ""https://mh-nexus.de/downloads/HxDSetupEN.zip"";
        download(downloadURL);
    }
}
","
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import javax.net.ssl.HttpsURLConnection;

public class DownloadFileExample {
    public static void download(String downloadURL) throws IOException {
        URL website = new URL(downloadURL);
        String fileName = ""downloaded.zip"";

        // Create a new instance of HttpsURLConnection
        HttpsURLConnection.setDefaultHostnameVerifier((hostname, sslSession) -> true);
        HttpsURLConnection conn = (HttpsURLConnection) website.openConnection();

        // Trust the SSL certificate of the server by adding it to the Java keystore
        conn.setSSLSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());

        try (InputStream inputStream = conn.getInputStream()) {
            Files.copy(inputStream, Paths.get(fileName), StandardCopyOption.REPLACE_EXISTING);
        }
    }

    public static void main(String[] arguments) throws IOException {
        String downloadURL = ""https://mh-nexus.de/downloads/HxDSetupEN.zip"";
        download(downloadURL);
    }
}
"
1709441,1710112,"import java.security.*;
public class Test {
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();
        retString.append(""["");
        for (int i = 0; i < publicKey.length; ++i) {
            retString.append(publicKey[i]);
            retString.append("", "");
        }
        retString = retString.delete(retString.length()-2,retString.length());
        retString.append(""]"");
        System.out.println(retString); //e.g. [48, 92, 48, .... , 0, 1]
    }
}
","
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class Main {
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException {
        // Generate RSA keypair with 512 bits
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(512);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Get the public key as a byte array
        PublicKey publicKey = keyPair.getPublic();
        byte[] publicKeyBytes = publicKey.getEncoded();

        // Encode the public key as a string
        String encodedPublicKey = Base64.getEncoder().encodeToString(publicKeyBytes);

        // Print the encoded public key
        System.out.println(""Encoded Public Key: "" + encodedPublicKey);
    }
}
"
1709441,1710112,"import java.security.*;
public class Test {
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();
        for (int i = 0; i < publicKey.length; ++i) {
            retString.append(Integer.toHexString(0x0100 + (publicKey[i] & 0x00FF)).substring(1));
        }
        System.out.println(retString);
    }
}
","
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class Main {
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException {
        // Generate RSA keypair with 512 bits
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(512);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Get the public key as a byte array
        PublicKey publicKey = keyPair.getPublic();
        byte[] publicKeyBytes = publicKey.getEncoded();

        // Encode the public key as a string
        String encodedPublicKey = Base64.getEncoder().encodeToString(publicKeyBytes);

        // Print the encoded public key
        System.out.println(""Encoded Public Key: "" + encodedPublicKey);
    }
}
"
25122287,46465836,"import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

/**
 * A custom X509TrustManager implementation that trusts a specified server certificate in addition
 * to those that are in the system TrustStore.
 * Also handles an out-of-order certificate chain, as is often produced by Apache's mod_ssl
 */
public class CustomTrustManager implements X509TrustManager {

  private final TrustManager[] originalTrustManagers;
  private final KeyStore trustStore;

  /**
   * @param trustStore A KeyStore containing the server certificate that should be trusted
   * @throws NoSuchAlgorithmException
   * @throws KeyStoreException
   */
  public CustomTrustManager(KeyStore trustStore) throws NoSuchAlgorithmException, KeyStoreException {
    this.trustStore = trustStore;

    final TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory.getInstance(""X509"");
    originalTrustManagerFactory.init(trustStore);

    originalTrustManagers = originalTrustManagerFactory.getTrustManagers();
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public X509Certificate[] getAcceptedIssuers() {
    return new X509Certificate[0];
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
  }


  /**
   * Given the partial or complete certificate chain provided by the peer,
   * build a certificate path to a trusted root and return if it can be validated and is trusted
   * for client SSL authentication based on the authentication type. The authentication type is
   * determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be ""RSA"".
   * Checking is case-sensitive.
   * Defers to the default trust manager first, checks the cert supplied in the ctor if that fails.
   * @param chain the server's certificate chain
   * @param authType the authentication type based on the client certificate
   * @throws java.security.cert.CertificateException
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
    try {
      for (TrustManager originalTrustManager : originalTrustManagers) {
        ((X509TrustManager) originalTrustManager).checkServerTrusted(chain, authType);
      }
    } catch(CertificateException originalException) {
      try {
        // Ordering issue?
        X509Certificate[] reorderedChain = reorderCertificateChain(chain);
        if (! Arrays.equals(chain, reorderedChain)) {
          checkServerTrusted(reorderedChain, authType);
          return;
        }
        for (int i = 0; i < chain.length; i++) {
          if (validateCert(reorderedChain[i])) {
            return;
          }
        }
        throw originalException;
      } catch(Exception ex) {
        ex.printStackTrace();
        throw originalException;
      }
    }

  }

  /**
   * Checks if we have added the certificate in the trustStore, if that's the case we trust the certificate
   * @param x509Certificate the certificate to check
   * @return true if we know the certificate, false otherwise
   * @throws KeyStoreException on problems accessing the key store
   */
  private boolean validateCert(final X509Certificate x509Certificate) throws KeyStoreException {
    return trustStore.getCertificateAlias(x509Certificate) != null;
  }

  /**
   * Puts the certificate chain in the proper order, to deal with out-of-order
   * certificate chains as are sometimes produced by Apache's mod_ssl
   * @param chain the certificate chain, possibly with bad ordering
   * @return the re-ordered certificate chain
   */
  private X509Certificate[] reorderCertificateChain(X509Certificate[] chain) {

    X509Certificate[] reorderedChain = new X509Certificate[chain.length];
    List<X509Certificate> certificates = Arrays.asList(chain);

    int position = chain.length - 1;
    X509Certificate rootCert = findRootCert(certificates);
    reorderedChain[position] = rootCert;

    X509Certificate cert = rootCert;
    while((cert = findSignedCert(cert, certificates)) != null && position > 0) {
      reorderedChain[--position] = cert;
    }

    return reorderedChain;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the root certificate in a possibly out-of-order certificate chain.
   * @param certificates the certificate change, possibly out-of-order
   * @return the root certificate, if any, that was found in the list of certificates
   */
  private X509Certificate findRootCert(List<X509Certificate> certificates) {
    X509Certificate rootCert = null;

    for(X509Certificate cert : certificates) {
      X509Certificate signer = findSigner(cert, certificates);
      if(signer == null || signer.equals(cert)) { // no signer present, or self-signed
        rootCert = cert;
        break;
      }
    }

    return rootCert;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the first certificate in the list of certificates that is signed by the sigingCert.
   */
  private X509Certificate findSignedCert(X509Certificate signingCert, List<X509Certificate> certificates) {
    X509Certificate signed = null;

    for(X509Certificate cert : certificates) {
      Principal signingCertSubjectDN = signingCert.getSubjectDN();
      Principal certIssuerDN = cert.getIssuerDN();
      if(certIssuerDN.equals(signingCertSubjectDN) && !cert.equals(signingCert)) {
        signed = cert;
        break;
      }
    }

    return signed;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the certificate in the list of certificates that signed the signedCert.
   */
  private X509Certificate findSigner(X509Certificate signedCert, List<X509Certificate> certificates) {
    X509Certificate signer = null;

    for(X509Certificate cert : certificates) {
      Principal certSubjectDN = cert.getSubjectDN();
      Principal issuerDN = signedCert.getIssuerDN();
      if(certSubjectDN.equals(issuerDN)) {
        signer = cert;
        break;
      }
    }

    return signer;
  }
}
","
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class SSLHandshakeExceptionExample {

    public static void main(String[] args) {
        try {
            // Create a custom Trust Manager that trusts all certificates
            TrustManager[] trustAllCerts = new TrustManager[] {
                new X509TrustManager() {
                    public void checkClientTrusted(X509Certificate[] certs, String authType) throws CertificateException { }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) throws CertificateException { }
                    public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
                }
            };

            // Install the custom Trust Manager
            SSLContext sslContext = SSLContext.getInstance(""TLS"");
            sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());

            // Make the request to the server
            URL url = new URL(""https://your-api-endpoint.com"");
            HttpURLConnection connection = (HttpURLConnection) url.openConnection();
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            String response = reader.readLine();
            reader.close();

            System.out.println(""Response: "" + response);
        } catch (SSLHandshakeException e) {
            System.out.println(""SSLHandshakeException occurred."");
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
29559215,45719212,"import javax.net.ssl.*;
import java.io.*;
import java.security.*;
import java.security.cert.*;

public class FetchCert {

    public static void main(String[] args) throws Exception {
        //REPLACE THIS WITH YOUR TARGET HOST NAME
        String hostname = ""example.com"";
        SSLSocketFactory factory = HttpsURLConnection.getDefaultSSLSocketFactory();

        SSLSocket socket = (SSLSocket) factory.createSocket(hostname, 443);
        try {
            socket.startHandshake();
            socket.close();
            System.out.println(""No errors, certificate is already trusted"");
            return;
        } catch (SSLException e) {
            System.out.println(""cert likely not found in keystore, will pull cert..."");
        }


        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        char[] password = ""changeit"".toCharArray();
        ks.load(null, password);

        SSLContext context = SSLContext.getInstance(""TLS"");
        TrustManagerFactory tmf =
                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(ks);
        X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];
        SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
        context.init(null, new TrustManager[]{tm}, null);
        factory = context.getSocketFactory();

        socket = (SSLSocket) factory.createSocket(hostname, 443);
        try {
            socket.startHandshake();
        } catch (SSLException e) {
            //we should get to here
        }
        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println(""Could not obtain server certificate chain"");
            return;
        }

        X509Certificate cert = chain[0];
        String alias = hostname;
        ks.setCertificateEntry(alias, cert);

        System.out.println(""saving file jssecacerts to working dir"");
        System.out.println(""copy this file to your jre/lib/security folder"");
        FileOutputStream fos = new FileOutputStream(""jssecacerts"");
        ks.store(fos, password);
        fos.close();
    }
    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {

        return new X509Certificate[0];  
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
}
","
import java.io.BufferedInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.net.URL;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;

import javax.net.ssl.HttpsURLConnection;

public class ImportCertificate {
    public static void main(String[] args) throws Exception {
        String hostname = ""bctcl-parasuram.bctchn.local"";
        int port = 8443;

        // Create a URL object for the website
        URL url = new URL(""https://"" + hostname + "":"" + port);

        // Open a connection to the website
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();

        // Get the SSL certificate from the website
        Certificate certificate = connection.getServerCertificates()[0];

        // Create a keystore object
        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());

        // Load the default truststore
        keystore.load(null, null);

        // Add the SSL certificate to the keystore
        keystore.setCertificateEntry(hostname, certificate);

        // Save the keystore to a file
        try (FileOutputStream fos = new FileOutputStream(""truststore.jks"")) {
            keystore.store(fos, ""changeit"".toCharArray());
        }

        System.out.println(""SSL certificate imported successfully"");
    }
}
"
44047862,44048146,"import javax.crypto.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class Gen_DESAES_key {

    public static void main(String[] args) throws NoSuchAlgorithmException,
                                                  NoSuchPaddingException,
                                                  BadPaddingException,
                                                  IllegalBlockSizeException,
                                                  InvalidKeyException {

        byte[] message = ""Hello World"".getBytes();

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey desKey = keygenerator.generateKey();

        Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        desCipher.init(Cipher.ENCRYPT_MODE, desKey);

        byte[] encryptedMessage = desCipher.doFinal(message);
        System.out.println(new String(encryptedMessage));
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;

public class Gen_DESAES_key {

    public static void main(String[] args) throws Exception {
        byte[] message = ""Hello World"".getBytes();

        KeyGenerator keyGenerator = KeyGenerator.getInstance(""DES"");
        SecretKey desKey = keyGenerator.generateKey();

        Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        desCipher.init(Cipher.ENCRYPT_MODE, desKey);

        byte[] encryptedMessage = desCipher.doFinal(message);
    }
}
"
5980658,5980789,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class AeSimpleSHA1 {
    private static String convertToHex(byte[] data) {
        StringBuilder buf = new StringBuilder();
        for (byte b : data) {
            int halfbyte = (b >>> 4) & 0x0F;
            int two_halfs = 0;
            do {
                buf.append((0 <= halfbyte) && (halfbyte <= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
                halfbyte = b & 0x0F;
            } while (two_halfs++ < 1);
        }
        return buf.toString();
    }

    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] textBytes = text.getBytes(""iso-8859-1"");
        md.update(textBytes, 0, textBytes.length);
        byte[] sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Main {

    public static void main(String[] args) {
        String stringToHash = ""Hello World"";
        String hashedString = sha1(stringToHash);
        System.out.println(hashedString);
    }

    public static String sha1(String stringToHash) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance(""SHA-1"");
            byte[] bytes = messageDigest.digest(stringToHash.getBytes());
            StringBuilder stringBuilder = new StringBuilder();

            for (byte b : bytes) {
                stringBuilder.append(String.format(""%02X"", b));
            }
            return stringBuilder.toString();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
}
"
2383322,6229899,"  import org.bouncycastle.util.encoders.UrlBase64;
  import org.bouncycastle.crypto.engines.BlowfishEngine;
  import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
  import org.bouncycastle.crypto.params.KeyParameter;
  import org.bouncycastle.util.Strings;

  public class EncryptString
  {
public static void main(String[] args) throws Exception
{
String plain = ""UserName=\'pgupta\'&Channel=\'1\'&LevelID=\'1\'&LevelName=\'Super Star colony\'"";
     String key = ""x-392kla%3$*1f"";
//To getBytes in UTF8 Encoding
byte[] inBytes = plain.getBytes(""UTF8"");
byte[] keyByte = key.getBytes(""UTF8""); 

PaddedBufferedBlockCipher _cipher = new PaddedBufferedBlockCipher(new BlowfishEngine());

try
{
_cipher.init(true, new KeyParameter(keyByte));

           // Determine the minimum output buffer size
byte[] outBytes = new byte[_cipher.getOutputSize(inBytes.length)];

        // 'len' is the actual size returned
     int len = _cipher.processBytes(inBytes, 0, inBytes.length, outBytes, 0);

_cipher.doFinal(outBytes,len);

         System.out.println(""encrypted: "" + new String(UrlBase64.encode(outBytes)));
}
catch(Exception e)
     {
         System.out.println(""Exception: "" + e.toString());
     }

}
  }
","
import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Security;

import javax.crypto.Cipher;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Base64;

public class EncryptionExample {
    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        // Load the keystore
        KeyStore ks = KeyStore.getInstance(""PKCS12"");
        InputStream is = new FileInputStream(""KEYSTORE.p12"");
        ks.load(is, ""AppTest"".toCharArray());
        is.close();

        // Get the private key
        PrivateKey privateKey = (PrivateKey) ks.getKey(""AppTest"", ""AppTest"".toCharArray());

        // Encrypt the string
        String stamp = ""123456"";
        byte[] bytesStampUtf8Unencrypted = stamp.getBytes(Charset.forName(""UTF-8""));
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, privateKey);
        byte[] bytesTimestampUtf8Encrypted = cipher.doFinal(bytesStampUtf8Unencrypted);
        String encrypted = new String(Base64.encode(bytesTimestampUtf8Encrypted));

        System.out.println(""Encrypted String: "" + encrypted);
    }
}
"
6547214,6553036,"import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt()
    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

public class MCrypt {
    private static final String HEXINDEX = ""0123456789abcdef"";
    private static final byte[] KEY = ""0123456789abcdef"".getBytes(StandardCharsets.UTF_8);
    private static final byte[] IV = ""abcdef9876543210"".getBytes(StandardCharsets.UTF_8);

    public static String encrypt(String text) throws Exception {
        if (text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        Cipher cipher;
        byte[] encrypted;

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY, ""AES""), new IvParameterSpec(IV));

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e) {
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return bytesToHex(encrypted);
    }

    public static String decrypt(String code) throws Exception {
        if (code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        Cipher cipher;
        byte[] decrypted;

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY, ""AES""), new IvParameterSpec(IV));
            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e) {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return new String(decrypted).trim();
    }

    private static byte[] hexToBytes(String hex) {
        int length = hex.length() / 2;
        byte[] data = new byte[length];

        for (int i = 0; i < length; i++) {
            int index = HEXINDEX.indexOf(hex.charAt(i * 2)) << 4 | HEXINDEX.indexOf(hex.charAt(i * 2 + 1));
            data[i] = (byte) index;
        }

        return data;
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder(bytes.length * 2);

        for (byte b : bytes) {
            result.append(HEXINDEX.charAt((b >> 4) & 0xf)).append(HEXINDEX.charAt(b & 0xf));
        }

        return result.toString();
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i < padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
"
5520640,5520786,"import java.security.MessageDigest;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class EncryptDecrypt {
    public static void main(String[] args) throws Exception {
        // here are your inputs
        String keyString = ""averylongtext!@$@#$#@$#*&(*&}{23432432432dsfsdf"";
        String input = ""john doe"";

        // setup AES cipher in CBC mode with PKCS #5 padding
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        // setup an IV (initialization vector) that should be
        // randomly generated for each input that's encrypted
        byte[] iv = new byte[cipher.getBlockSize()];
        new SecureRandom().nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        // hash keyString with SHA-256 and crop the output to 128-bit for key
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(keyString.getBytes());
        byte[] key = new byte[16];
        System.arraycopy(digest.digest(), 0, key, 0, key.length);
        SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");

        // encrypt
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
        byte[] encrypted = cipher.doFinal(input.getBytes(""UTF-8""));
        System.out.println(""encrypted: "" + new String(encrypted));

        // include the IV with the encrypted bytes for transport, you'll
        // need the same IV when decrypting (it's safe to send unencrypted)

        // decrypt
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        System.out.println(""decrypted: "" + new String(decrypted, ""UTF-8""));
    }
}
","
import javax.crypto.*;
import javax.crypto.spec.DESKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;
import java.util.Arrays;

public class EncryptionExample {

    public static void main(String[] args) {
        try {
            String algorithm = ""DES"";
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);

            byte[] encBytes = ""12345678"".getBytes(""UTF8"");
            byte[] decBytes = ""56781234"".getBytes(""UTF8"");

            DESKeySpec keySpecEncrypt = new DESKeySpec(encBytes);
            DESKeySpec keySpecDecrypt = new DESKeySpec(decBytes);

            SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);
            SecretKey keyDecrypt = keyFactory.generateSecret(keySpecDecrypt);

            Cipher cipherEncrypt = Cipher.getInstance(algorithm);
            Cipher cipherDecrypt = Cipher.getInstance(algorithm);

            String input = ""john doe"";

            cipherEncrypt.init(Cipher.ENCRYPT_MODE, keyEncrypt);
            byte[] inputBytes = cipherEncrypt.doFinal(input.getBytes());
            System.out.println(""Encrypted Bytes: "" + Arrays.toString(inputBytes));

            cipherDecrypt.init(Cipher.DECRYPT_MODE, keyDecrypt);
            byte[] outputBytes = cipherDecrypt.doFinal(inputBytes);
            System.out.println(""Decrypted Bytes: "" + new String(outputBytes));

        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }
    }
}
"
3483582,4897062,"import java.security.InvalidKeyException;

import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;

import javax.crypto.spec.SecretKeySpec;

import com.caucho.util.Base64;

import com.caucho.quercus.module.AbstractQuercusModule;

public class HmacSHA256 extends AbstractQuercusModule {

    public String compute(String baseString, String key) throws InvalidKeyException, NoSuchAlgorithmException {
        Mac mac;
        mac = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
        mac.init(secret);
        byte[] digest = mac.doFinal(baseString.getBytes());
        return Base64.encode(digest);
    }
}
","
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class HmacSha1Example {

    public static String hmacSha1(String baseString, String key) {
        try {
            Mac mac = Mac.getInstance(""HmacSHA1"");
            SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), ""HmacSHA1"");
            mac.init(secretKeySpec);
            byte[] rawHmac = mac.doFinal(baseString.getBytes());
            StringBuilder result = new StringBuilder();
            for (byte b : rawHmac) {
                result.append(String.format(""%02x"", b));
            }
            return result.toString();
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        String baseString = ""your base string"";
        String key = ""your key"";
        String signature = hmacSha1(baseString, key);
        System.out.println(""HMAC-SHA1 Signature: "" + signature);
    }
}
"
11783062,11786924,"import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.List;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.util.encoders.Base64;

public class OpenSSLDecryptor {
    private static final Charset ASCII = Charset.forName(""ASCII"");
    private static final int INDEX_KEY = 0;
    private static final int INDEX_IV = 1;
    private static final int ITERATIONS = 1;

    private static final int ARG_INDEX_FILENAME = 0;
    private static final int ARG_INDEX_PASSWORD = 1;

    private static final int SALT_OFFSET = 8;
    private static final int SALT_SIZE = 8;
    private static final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;

    private static final int KEY_SIZE_BITS = 256;

    /**
     * Thanks go to Ola Bini for releasing this source on his blog.
     * The source was obtained from <a href=""http://olabini.com/blog/tag/evp_bytestokey/"">here</a> .
     */
    public static byte[][] EVP_BytesToKey(int key_len, int iv_len, MessageDigest md,
            byte[] salt, byte[] data, int count) {
        byte[][] both = new byte[2][];
        byte[] key = new byte[key_len];
        int key_ix = 0;
        byte[] iv = new byte[iv_len];
        int iv_ix = 0;
        both[0] = key;
        both[1] = iv;
        byte[] md_buf = null;
        int nkey = key_len;
        int niv = iv_len;
        int i = 0;
        if (data == null) {
            return both;
        }
        int addmd = 0;
        for (;;) {
            md.reset();
            if (addmd++ > 0) {
                md.update(md_buf);
            }
            md.update(data);
            if (null != salt) {
                md.update(salt, 0, 8);
            }
            md_buf = md.digest();
            for (i = 1; i < count; i++) {
                md.reset();
                md.update(md_buf);
                md_buf = md.digest();
            }
            i = 0;
            if (nkey > 0) {
                for (;;) {
                    if (nkey == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    key[key_ix++] = md_buf[i];
                    nkey--;
                    i++;
                }
            }
            if (niv > 0 && i != md_buf.length) {
                for (;;) {
                    if (niv == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    iv[iv_ix++] = md_buf[i];
                    niv--;
                    i++;
                }
            }
            if (nkey == 0 && niv == 0) {
                break;
            }
        }
        for (i = 0; i < md_buf.length; i++) {
            md_buf[i] = 0;
        }
        return both;
    }


    public static void main(String[] args) {
        try {
            // --- read base 64 encoded file ---

            File f = new File(args[ARG_INDEX_FILENAME]);
            List<String> lines = Files.readAllLines(f.toPath(), ASCII);
            StringBuilder sb = new StringBuilder();
            for (String line : lines) {
                sb.append(line.trim());
            }
            String dataBase64 = sb.toString();
            byte[] headerSaltAndCipherText = Base64.decode(dataBase64);

            // --- extract salt & encrypted ---

            // header is ""Salted__"", ASCII encoded, if salt is being used (the default)
            byte[] salt = Arrays.copyOfRange(
                    headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);
            byte[] encrypted = Arrays.copyOfRange(
                    headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);

            // --- specify cipher and digest for EVP_BytesToKey method ---

            Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            MessageDigest md5 = MessageDigest.getInstance(""MD5"");

            // --- create key and IV  ---

            // the IV is useless, OpenSSL might as well have use zero's
            final byte[][] keyAndIV = EVP_BytesToKey(
                    KEY_SIZE_BITS / Byte.SIZE,
                    aesCBC.getBlockSize(),
                    md5,
                    salt,
                    args[ARG_INDEX_PASSWORD].getBytes(ASCII),
                    ITERATIONS);
            SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], ""AES"");
            IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);

            // --- initialize cipher instance and decrypt ---

            aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
            byte[] decrypted = aesCBC.doFinal(encrypted);

            String answer = new String(decrypted, ASCII);
            System.out.println(answer);
        } catch (BadPaddingException e) {
            // AKA ""something went wrong""
            throw new IllegalStateException(
                    ""Bad password, algorithm, mode or padding;"" +
                    "" no salt, wrong number of iterations or corrupted ciphertext."");
        } catch (IllegalBlockSizeException e) {
            throw new IllegalStateException(
                    ""Bad algorithm, mode or corrupted (resized) ciphertext."");
        } catch (GeneralSecurityException e) {
            throw new IllegalStateException(e);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }        
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.spec.AlgorithmParameterSpec;

public class FileDecryptor {

    public static void main(String[] args) throws Exception {
        String inputFile = ""password.txt.enc"";
        String outputFile = ""password.txt.new"";
        String password = ""mypass"";

        // Read the encrypted file
        FileInputStream fileInputStream = new FileInputStream(inputFile);
        byte[] inputBytes = new byte[(int) inputFile.length()];
        fileInputStream.read(inputBytes);

        // Decrypt the file
        byte[] decryptedBytes = decrypt(inputBytes, password);

        // Write the decrypted file
        FileOutputStream fileOutputStream = new FileOutputStream(outputFile);
        fileOutputStream.write(decryptedBytes);

        // Close the file streams
        fileInputStream.close();
        fileOutputStream.close();
    }

    public static byte[] decrypt(byte[] encryptedBytes, String password) throws Exception {
        // Set the encryption algorithm and key
        String algorithm = ""AES"";
        String transformation = ""AES/CBC/PKCS5Padding"";
        byte[] keyBytes = password.getBytes();
        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, algorithm);

        // Set the initialization vector
        byte[] ivBytes = new byte[16];
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);

        // Perform the decryption
        Cipher cipher = Cipher.getInstance(transformation);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);

        return decryptedBytes;
    }
}
"
992019,10128606,"import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

public class Crypto
{
    String mPassword = null;
    public final static int SALT_LEN = 8;
    byte [] mInitVec = null;
    byte [] mSalt = null;
    Cipher mEcipher = null;
    Cipher mDecipher = null;
    private final int KEYLEN_BITS = 128; // see notes below where this is used.
    private final int ITERATIONS = 65536;
    private final int MAX_FILE_BUF = 1024;

    /**
     * create an object with just the passphrase from the user. Don't do anything else yet 
     * @param password
     */
    public Crypto (String password)
    {
        mPassword = password;
    }

    /**
     * return the generated salt for this object
     * @return
     */
    public byte [] getSalt ()
    {
        return (mSalt);
    }

    /**
     * return the initialization vector created from setupEncryption
     * @return
     */
    public byte [] getInitVec ()
    {
        return (mInitVec);
    }

    /**
     * debug/print messages
     * @param msg
     */
    private void Db (String msg)
    {
        System.out.println (""** Crypt ** "" + msg);
    }

    /**
     * this must be called after creating the initial Crypto object. It creates a salt of SALT_LEN bytes
     * and generates the salt bytes using secureRandom().  The encryption secret key is created 
     * along with the initialization vectory. The member variable mEcipher is created to be used
     * by the class later on when either creating a CipherOutputStream, or encrypting a buffer
     * to be written to disk.
     *  
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidParameterSpecException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     * @throws UnsupportedEncodingException
     * @throws InvalidKeyException
     */
    public void setupEncrypt () throws NoSuchAlgorithmException, 
                                                           InvalidKeySpecException, 
                                                           NoSuchPaddingException, 
                                                           InvalidParameterSpecException, 
                                                           IllegalBlockSizeException, 
                                                           BadPaddingException, 
                                                           UnsupportedEncodingException, 
                                                           InvalidKeyException
    {
        SecretKeyFactory factory = null;
        SecretKey tmp = null;

        // crate secureRandom salt and store  as member var for later use
         mSalt = new byte [SALT_LEN];
        SecureRandom rnd = new SecureRandom ();
        rnd.nextBytes (mSalt);
        Db (""generated salt :"" + Hex.encodeHexString (mSalt));

        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

        /* Derive the key, given password and salt. 
         * 
         * in order to do 256 bit crypto, you have to muck with the files for Java's ""unlimted security""
         * The end user must also install them (not compiled in) so beware. 
         * see here:  http://www.javamex.com/tutorials/cryptography/unrestricted_policy_files.shtml
         */
        KeySpec spec = new PBEKeySpec (mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);
        tmp = factory.generateSecret (spec);
        SecretKey secret = new SecretKeySpec (tmp.getEncoded(), ""AES"");

        /* Create the Encryption cipher object and store as a member variable
         */
        mEcipher = Cipher.getInstance (""AES/CBC/PKCS5Padding"");
        mEcipher.init (Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = mEcipher.getParameters ();

        // get the initialization vectory and store as member var 
        mInitVec = params.getParameterSpec (IvParameterSpec.class).getIV();

        Db (""mInitVec is :"" + Hex.encodeHexString (mInitVec));
    }



    /**
     * If a file is being decrypted, we need to know the pasword, the salt and the initialization vector (iv). 
     * We have the password from initializing the class. pass the iv and salt here which is
     * obtained when encrypting the file initially.
     *   
     * @param initvec
     * @param salt
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws InvalidAlgorithmParameterException
     * @throws DecoderException
     */
    public void setupDecrypt (String initvec, String salt) throws NoSuchAlgorithmException, 
                                                                                       InvalidKeySpecException, 
                                                                                       NoSuchPaddingException, 
                                                                                       InvalidKeyException, 
                                                                                       InvalidAlgorithmParameterException, 
                                                                                       DecoderException
    {
        SecretKeyFactory factory = null;
        SecretKey tmp = null;
        SecretKey secret = null;

        // since we pass it as a string of input, convert to a actual byte buffer here
        mSalt = Hex.decodeHex (salt.toCharArray ());
       Db (""got salt "" + Hex.encodeHexString (mSalt));

        // get initialization vector from passed string
        mInitVec = Hex.decodeHex (initvec.toCharArray ());
        Db (""got initvector :"" + Hex.encodeHexString (mInitVec));


        /* Derive the key, given password and salt. */
        // in order to do 256 bit crypto, you have to muck with the files for Java's ""unlimted security""
        // The end user must also install them (not compiled in) so beware. 
        // see here: 
      // http://www.javamex.com/tutorials/cryptography/unrestricted_policy_files.shtml
        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);

        tmp = factory.generateSecret(spec);
        secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        /* Decrypt the message, given derived key and initialization vector. */
        mDecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec));
    }


    /**
     * This is where we write out the actual encrypted data to disk using the Cipher created in setupEncrypt().
     * Pass two file objects representing the actual input (cleartext) and output file to be encrypted.
     * 
     * there may be a way to write a cleartext header to the encrypted file containing the salt, but I ran
     * into uncertain problems with that. 
     *  
     * @param input - the cleartext file to be encrypted
     * @param output - the encrypted data file
     * @throws IOException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    public void WriteEncryptedFile (File input, File output) throws 
                                                                                          IOException, 
                                                                                          IllegalBlockSizeException, 
                                                                                          BadPaddingException
    {
        FileInputStream fin;
        FileOutputStream fout;
        long totalread = 0;
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        fout = new FileOutputStream (output);
        fin = new FileInputStream (input);

        while ((nread = fin.read (inbuf)) > 0 )
        {
            Db (""read "" + nread + "" bytes"");
            totalread += nread;

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            // and results in full blocks of MAX_FILE_BUF being written. 
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i < nread; i++)
                trimbuf[i] = inbuf[i];

            // encrypt the buffer using the cipher obtained previosly
            byte [] tmp = mEcipher.update (trimbuf);

            // I don't think this should happen, but just in case..
            if (tmp != null)
                fout.write (tmp);
        }

        // finalize the encryption since we've done it in blocks of MAX_FILE_BUF
        byte [] finalbuf = mEcipher.doFinal ();
        if (finalbuf != null)
            fout.write (finalbuf);

        fout.flush();
        fin.close();
        fout.close();

        Db (""wrote "" + totalread + "" encrypted bytes"");
    }


    /**
     * Read from the encrypted file (input) and turn the cipher back into cleartext. Write the cleartext buffer back out
     * to disk as (output) File.
     * 
     * I left CipherInputStream in here as a test to see if I could mix it with the update() and final() methods of encrypting
     *  and still have a correctly decrypted file in the end. Seems to work so left it in.
     *  
     * @param input - File object representing encrypted data on disk 
     * @param output - File object of cleartext data to write out after decrypting
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     * @throws IOException
     */
    public void ReadEncryptedFile (File input, File output) throws 
                                                                                                                                            IllegalBlockSizeException, 
                                                                                                                                            BadPaddingException, 
                                                                                                                                            IOException
    {
        FileInputStream fin; 
        FileOutputStream fout;
        CipherInputStream cin;
        long totalread = 0;
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        fout = new FileOutputStream (output);
        fin = new FileInputStream (input);

        // creating a decoding stream from the FileInputStream above using the cipher created from setupDecrypt()
        cin = new CipherInputStream (fin, mDecipher);

        while ((nread = cin.read (inbuf)) > 0 )
        {
            Db (""read "" + nread + "" bytes"");
            totalread += nread;

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i < nread; i++)
                trimbuf[i] = inbuf[i];

            // write out the size-adjusted buffer
            fout.write (trimbuf);
        }

        fout.flush();
        cin.close();
        fin.close ();       
        fout.close();   

        Db (""wrote "" + totalread + "" encrypted bytes"");
    }


    /**
     * adding main() for usage demonstration. With member vars, some of the locals would not be needed
     */
    public static void main(String [] args)
    {

        // create the input.txt file in the current directory before continuing
        File input = new File (""input.txt"");
        File eoutput = new File (""encrypted.aes"");
        File doutput = new File (""decrypted.txt"");
        String iv = null;
        String salt = null;
        Crypto en = new Crypto (""mypassword"");

        /*
         * setup encryption cipher using password. print out iv and salt
         */
        try
      {
          en.setupEncrypt ();
          iv = Hex.encodeHexString (en.getInitVec ()).toUpperCase ();
          salt = Hex.encodeHexString (en.getSalt ()).toUpperCase ();
      }
      catch (InvalidKeyException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchAlgorithmException e)
      {
          e.printStackTrace();
      }
      catch (InvalidKeySpecException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchPaddingException e)
      {
          e.printStackTrace();
      }
      catch (InvalidParameterSpecException e)
      {
          e.printStackTrace();
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (UnsupportedEncodingException e)
      {
          e.printStackTrace();
      }

        /*
         * write out encrypted file
         */
        try
      {
          en.WriteEncryptedFile (input, eoutput);
          System.out.printf (""File encrypted to "" + eoutput.getName () + ""\niv:"" + iv + ""\nsalt:"" + salt + ""\n\n"");
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (IOException e)
      {
          e.printStackTrace();
      }


        /*
         * decrypt file
         */
        Crypto dc = new Crypto (""mypassword"");
        try
      {
          dc.setupDecrypt (iv, salt);
      }
      catch (InvalidKeyException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchAlgorithmException e)
      {
          e.printStackTrace();
      }
      catch (InvalidKeySpecException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchPaddingException e)
      {
          e.printStackTrace();
      }
      catch (InvalidAlgorithmParameterException e)
      {
          e.printStackTrace();
      }
      catch (DecoderException e)
      {
          e.printStackTrace();
      }

        /*
         * write out decrypted file
         */
        try
      {
          dc.ReadEncryptedFile (eoutput, doutput);
          System.out.println (""decryption finished to "" + doutput.getName ());
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (IOException e)
      {
          e.printStackTrace();
      }
   }


}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AESExample {

    public static void main(String[] args) {
        String passkey = ""your-passkey""; // Replace with your own passkey
        
        byte[] key = generateKey(passkey); 
        
        byte[] input = ""Hello, World!"".getBytes(); // Replace with your input data
        
        byte[] output = encrypt(key, input);
        
        System.out.println(""Encrypted: "" + Arrays.toString(output));
    }
    
    public static byte[] generateKey(String passkey) {
        try {
            MessageDigest sha = MessageDigest.getInstance(""SHA-256"");
            byte[] passkeyBytes = passkey.getBytes();
            byte[] digest = sha.digest(passkeyBytes);
            
            // Truncate the digest to 256 bits (32 bytes)
            byte[] key = Arrays.copyOf(digest, 32);
            
            return key;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        }
        return null;
    }
    
    public static byte[] encrypt(byte[] key, byte[] input) {
        try {
            SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            
            return cipher.doFinal(input);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
"
10842350,10843168,"import java.nio.charset.Charset;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

public class AESToy3 {

    private static final Charset ASCII = Charset.forName(""US-ASCII"");

    public static void main(String[] args) throws Exception {
        String base64Cipher = ""iz1qFlQJfs6Ycp+gcc2z4w=="";
        byte [] cipherBytes = Base64.decodeBase64(base64Cipher);
        byte [] iv = ""1234567812345678"".getBytes(ASCII);
        byte [] keyBytes = ""1234567812345678"".getBytes(ASCII);

        SecretKey aesKey = new SecretKeySpec(keyBytes, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));

        byte[] result = cipher.doFinal(cipherBytes);
        System.out.println(Hex.encodeHexString(result));
    }

}
","
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Main {

    public static void main(String[] args) throws Exception {
        String base64EncodedText = ""iz1qFlQJfs6Ycp+gcc2z4w=="";
        String key = ""1234567812345678"";
        String iv = ""1234567812345678"";

        byte[] decodedText = Base64.getDecoder().decode(base64EncodedText);

        SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), ""AES"");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes());

        Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);
        byte[] decrypted = cipher.doFinal(decodedText);

        String str = new String(decrypted).trim();

        System.out.println(str);  // Output: Test string
    }
}
"
11864696,11886011,"import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.RSAPublicKeySpec;

import javax.crypto.Cipher;
import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class DecodePKCS8 {

    /**
     * @param args
     * @throws IOException 
     * @throws NoSuchPaddingException When file is corrupted
     * @throws NoSuchAlgorithmException When no BC provider has been loaded 
     * @throws InvalidKeySpecException When decryption of file failed
     * @throws InvalidAlgorithmParameterException When file is corrupted
     * @throws InvalidKeyException When Unlimited cryptography extensions are not installed
     */
    public static void main(String[] args) throws
    IOException, NoSuchAlgorithmException, NoSuchPaddingException,
    InvalidKeySpecException, InvalidKeyException, InvalidAlgorithmParameterException
    {
        // before we can do anything with BouncyCastle we have to register its provider
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

        String password = ""Very long and complex password"";

        // read DER encoded key from files
        byte[] encodedprivkey = getFileBytes(""privkey.p8"");

        // this is a encoded PKCS#8 encrypted private key
        EncryptedPrivateKeyInfo ePKInfo = new EncryptedPrivateKeyInfo(encodedprivkey);

        // first we have to read algorithm name and parameters (salt, iterations) used
        // to encrypt the file
        Cipher cipher = Cipher.getInstance(ePKInfo.getAlgName());
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());

        SecretKeyFactory skFac = SecretKeyFactory.getInstance(ePKInfo
                .getAlgName());
        Key pbeKey = skFac.generateSecret(pbeKeySpec);

        // Extract the iteration count and the salt
        AlgorithmParameters algParams = ePKInfo.getAlgParameters();
        cipher.init(Cipher.DECRYPT_MODE, pbeKey, algParams);

        // Decrypt the encryped private key into a PKCS8EncodedKeySpec
        KeySpec pkcs8KeySpec = ePKInfo.getKeySpec(cipher);

        // Now retrieve the RSA Public and private keys by using an
        // RSA key factory.
        KeyFactory rsaKeyFac = KeyFactory.getInstance(""RSA"");
        // First get the private key
        PrivateKey rsaPriv = rsaKeyFac.generatePrivate(pkcs8KeySpec);
        // Now derive the RSA public key from the private key
        RSAPublicKeySpec rsaPubKeySpec = new RSAPublicKeySpec(((RSAKey) rsaPriv).getModulus(),
                ((RSAPrivateCrtKey) rsaPriv).getPublicExponent());
        PublicKey rsaPubKey = (RSAPublicKey) rsaKeyFac.generatePublic(rsaPubKeySpec);

    System.out.println(""Key extracted, public part: "" + rsaPubKey);
    }

    private static byte[] getFileBytes(String path)
    {
        File f = new File(path);
        int sizecontent = ((int) f.length()); // no key file will ever be bigger than 4GiB...
        byte[] data = new byte[sizecontent];
        try 
            {
            FileInputStream freader = new FileInputStream(f);
            freader.read(data, 0, sizecontent) ;
            freader.close();
            return data;
            }
        catch(IOException ioe)
        {
            System.out.println(ioe.toString());
            return null;
        }
    }
}
","
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.KeyStore;
import java.security.Security;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class KeyStoreEncryption {
    private static final String KEYSTORE_TYPE = ""JKS"";
    private static final String KEYSTORE_PATH = ""keystore.jks"";
    private static final String KEYSTORE_PASS = ""password"";
    private static final String KEY_ALIAS = ""secretKeyAlias"";
    private static final String SECRET_KEY_ALG = ""PBEWithSHA256And128bitAES-CBC-BC"";

    public static void main(String[] args) {
        try {
            Security.addProvider(new BouncyCastleProvider());

            // Generate secret key
            KeyGenerator keyGenerator = KeyGenerator.getInstance(SECRET_KEY_ALG, ""BC"");
            SecretKey secretKey = keyGenerator.generateKey();

            // Create keystore
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
            keyStore.load(null, KEYSTORE_PASS.toCharArray());
            keyStore.setKeyEntry(KEY_ALIAS, secretKey, KEYSTORE_PASS.toCharArray(), null);

            // Save keystore to a file
            FileOutputStream fos = new FileOutputStream(KEYSTORE_PATH);
            keyStore.store(fos, KEYSTORE_PASS.toCharArray());
            fos.close();

            // Load keystore from file
            FileInputStream fis = new FileInputStream(KEYSTORE_PATH);
            keyStore.load(fis, KEYSTORE_PASS.toCharArray());
            fis.close();

            // Retrieve secret key from keystore
            SecretKey retrievedSecretKey = (SecretKey) keyStore.getKey(KEY_ALIAS, KEYSTORE_PASS.toCharArray());
            System.out.println(""Retrieved secret key: "" + retrievedSecretKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
11864696,11886011,"import java.io.FileOutputStream;
import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

import org.bouncycastle.asn1.bc.BCObjectIdentifiers;

public class EncodePKCS8 {

/**
 * @param args
 * @throws NoSuchAlgorithmException 
 * @throws InvalidKeySpecException 
 * @throws NoSuchPaddingException 
 * @throws InvalidAlgorithmParameterException 
 * @throws InvalidKeyException 
 * @throws BadPaddingException 
 * @throws IllegalBlockSizeException 
 * @throws InvalidParameterSpecException 
 * @throws IOException 
 * @throws NoSuchProviderException 
 */
public static void main(String[] args) throws NoSuchAlgorithmException,
InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException,
InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException,
InvalidParameterSpecException, IOException, NoSuchProviderException
{
    // before we can do anything with BouncyCastle we have to register its provider
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

    String password = ""Very long and complex password"";

    // generate RSA key pair
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    keyPairGenerator.initialize(2048);
    KeyPair keyPair = keyPairGenerator.genKeyPair();

    byte[] encryptedPkcs8 = encryptPrivateKey(password, keyPair);

    FileOutputStream fos = new FileOutputStream(""privkey.p8"");
    fos.write(encryptedPkcs8);
    fos.close();

    return;
}

private static byte[] encryptPrivateKey(String password, KeyPair keyPair)
    throws InvalidKeyException, NoSuchAlgorithmException, NoSuchProviderException,
    InvalidKeySpecException, NoSuchPaddingException,
    InvalidAlgorithmParameterException, IllegalBlockSizeException,
    BadPaddingException, InvalidParameterSpecException, IOException
{
    int count = 100000; // hash iteration count, best to leave at default or increase
    return encryptPrivateKey(password, keyPair, count);
}

/**
 * 
 * @param password
 * @param keyPair
 * @param count
 * @return PKCS#8 encoded, encrypted keyPair
 * @throws NoSuchAlgorithmException
 * @throws NoSuchProviderException
 * @throws InvalidKeySpecException
 * @throws NoSuchPaddingException
 * @throws InvalidKeyException
 * @throws InvalidAlgorithmParameterException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 * @throws InvalidParameterSpecException
 * @throws IOException
 */
private static byte[] encryptPrivateKey(String password, 
        KeyPair keyPair, int count) throws NoSuchAlgorithmException,
        NoSuchProviderException, InvalidKeySpecException,
        NoSuchPaddingException, InvalidKeyException,
        InvalidAlgorithmParameterException, IllegalBlockSizeException,
        BadPaddingException, InvalidParameterSpecException, IOException
{
    // extract the encoded private key, this is an unencrypted PKCS#8 private key
        byte[] encodedprivkey = keyPair.getPrivate().getEncoded();

        // Use a PasswordBasedEncryption (PBE) algorithm, OID of this algorithm will be saved
        // in the PKCS#8 file, so changing it (when more standard algorithm or safer
        // algorithm is available) doesn't break backwards compatibility.
        // In other words, decryptor doesn't need to know the algorithm before it will be
        // able to decrypt the PKCS#8 object.
        String encAlg = BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc.getId();

        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Create PBE parameter set
        PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory keyFac = SecretKeyFactory.getInstance(encAlg, ""BC"");
        SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

        Cipher pbeCipher = Cipher.getInstance(encAlg, ""BC"");

        // Initialize PBE Cipher with key and parameters
        pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

        // Encrypt the encoded Private Key with the PBE key
        byte[] ciphertext = pbeCipher.doFinal(encodedprivkey);

        // Now construct  PKCS #8 EncryptedPrivateKeyInfo object
        AlgorithmParameters algparms = AlgorithmParameters.getInstance(encAlg, ""BC"");
        algparms.init(pbeParamSpec);
        EncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);

        // DER encoded PKCS#8 encrypted key
        byte[] encryptedPkcs8 = encinfo.getEncoded();

        return encryptedPkcs8;
    }
}
","
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.KeyStore;
import java.security.Security;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class KeyStoreEncryption {
    private static final String KEYSTORE_TYPE = ""JKS"";
    private static final String KEYSTORE_PATH = ""keystore.jks"";
    private static final String KEYSTORE_PASS = ""password"";
    private static final String KEY_ALIAS = ""secretKeyAlias"";
    private static final String SECRET_KEY_ALG = ""PBEWithSHA256And128bitAES-CBC-BC"";

    public static void main(String[] args) {
        try {
            Security.addProvider(new BouncyCastleProvider());

            // Generate secret key
            KeyGenerator keyGenerator = KeyGenerator.getInstance(SECRET_KEY_ALG, ""BC"");
            SecretKey secretKey = keyGenerator.generateKey();

            // Create keystore
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
            keyStore.load(null, KEYSTORE_PASS.toCharArray());
            keyStore.setKeyEntry(KEY_ALIAS, secretKey, KEYSTORE_PASS.toCharArray(), null);

            // Save keystore to a file
            FileOutputStream fos = new FileOutputStream(KEYSTORE_PATH);
            keyStore.store(fos, KEYSTORE_PASS.toCharArray());
            fos.close();

            // Load keystore from file
            FileInputStream fis = new FileInputStream(KEYSTORE_PATH);
            keyStore.load(fis, KEYSTORE_PASS.toCharArray());
            fis.close();

            // Retrieve secret key from keystore
            SecretKey retrievedSecretKey = (SecretKey) keyStore.getKey(KEY_ALIAS, KEYSTORE_PASS.toCharArray());
            System.out.println(""Retrieved secret key: "" + retrievedSecretKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
11116143,11119059,"import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;

import org.apache.commons.codec.binary.Base64;

public class RsaVerify {

    public static void main(String args[]){
        String publicKey = 
//              ""-----BEGIN PUBLIC KEY-----""+
                ""MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANDiE2+Xi/WnO+s120NiiJhNyIButVu6""+
                ""zxqlVzz0wy2j4kQVUC4ZRZD80IY+4wIiX2YxKBZKGnd2TtPkcJ/ljkUCAwEAAQ=="";
//              ""-----END PUBLIC KEY-----"";

        byte[] data = ""For my current project I have to send a signature from PHP to Java application. I am using Crypt/RSA right now for signing my data."".getBytes();
        byte[] signature = Base64.decodeBase64(""OnqiWnFQ2nAjOa1S57Du9jDpVr4Wp2nLdMk2FX+/qX1+SAHpVsW1JvQYqQUDlxvbTOE9vg6dlU6i3omR7KipLw=="");

        try {
            System.out.println(verify(data, signature, publicKey));
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        }

    }

    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(Base64.decodeBase64(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }
}
","
import java.nio.charset.Charset;
import java.security.PublicKey;
import java.security.Signature;

public class JCEProvider {

    public boolean verify(byte[] signature, byte[] verifier, PublicKey publicKey) throws Exception {
        Signature rsaSignature = Signature.getInstance(""SHA256withRSA"");
        rsaSignature.initVerify(publicKey);
        rsaSignature.update(verifier);
        return rsaSignature.verify(signature);
    }

    public static void main(String[] args) {
        try {
            String signed = ""<base64 encoded signature>"";
            String data = ""abc"";
            String encodedPublicKey = ""<base64 encoded public key>"";

            byte[] signature = java.util.Base64.getDecoder().decode(signed);
            byte[] verifier = data.getBytes(Charset.forName(""UTF-8""));
            byte[] decodedPublicKey = java.util.Base64.getDecoder().decode(encodedPublicKey);

            PublicKey publicKey = java.security.KeyFactory.getInstance(""RSA"")
                    .generatePublic(new java.security.spec.X509EncodedKeySpec(decodedPublicKey));

            JCEProvider jceProvider = new JCEProvider();
            boolean isVerified = jceProvider.verify(signature, verifier, publicKey);

            System.out.println(""Is the signature verified? "" + isVerified);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
10221411,10222196,"import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.xml.bind.DatatypeConverter;

public class RSAExample {
    private static byte[] h2b(String hex){
        return DatatypeConverter.parseHexBinary(hex);
    }
    private static String b2h(byte[] bytes){
        return DatatypeConverter.printHexBinary(bytes);
    }

    private static SecureRandom sr = new SecureRandom();

    public static KeyPair newKeyPair(int rsabits) throws NoSuchAlgorithmException {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(rsabits, sr);
        return generator.generateKeyPair();
    }

    public static byte[] pubKeyToBytes(PublicKey key){
        return key.getEncoded(); // X509 for a public key
    }
    public static byte[] privKeyToBytes(PrivateKey key){
        return key.getEncoded(); // PKCS8 for a private key
    }

    public static PublicKey bytesToPubKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(bytes));
    }
    public static PrivateKey bytesToPrivKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(bytes));
    }

    public static byte[] encryptWithPubKey(byte[] input, PublicKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(input);
    }
    public static byte[] decryptWithPrivKey(byte[] input, PrivateKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key);
        return cipher.doFinal(input);
    }


    public static void main(String[] args) throws Exception {
        KeyPair kp = newKeyPair(1<<11); // 2048 bit RSA; might take a second to generate keys
        PublicKey pubKey = kp.getPublic();
        PrivateKey privKey = kp.getPrivate();
        String plainText = ""Dear Bob,\nWish you were here.\n\t--Alice"";
        byte[] cipherText = encryptWithPubKey(plainText.getBytes(""UTF-8""),pubKey);
        System.out.println(""cipherText: ""+b2h(cipherText));
        System.out.println(""plainText:"");
        System.out.println(new String(decryptWithPrivKey(cipherText,privKey),""UTF-8""));
    }
}
","
import java.security.*;
import java.util.Base64;
import javax.crypto.Cipher;

public class RSAEncryptionExample {
    private KeyPair keypair;

    public RSAEncryptionExample() throws NoSuchAlgorithmException, NoSuchProviderException {
        KeyPairGenerator keygenerator = KeyPairGenerator.getInstance(""RSA"");
        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");
        keygenerator.initialize(1024, random);
        keypair = keygenerator.generateKeyPair();
    }

    public String ENCRYPT(String Algorithm, String Data) throws Exception {
        String alg = Algorithm;
        String data = Data;
        byte[] encrypted;
        if (alg.equals(""RSA"")) {
            PublicKey publicKey = keypair.getPublic();
            Cipher cipher;
            cipher = Cipher.getInstance(""RSA"");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            encrypted = cipher.doFinal(data.getBytes());
            System.out.println(""Encrypted String[RSA] -> "" + Base64.getEncoder().encodeToString(encrypted));
            return Base64.getEncoder().encodeToString(encrypted);
        } else {
            return null;
        }
    }

    public String DECRYPT(String Algorithm, String Data) throws Exception {
        String alg = Algorithm;
        byte[] Decrypted = Base64.getDecoder().decode(Data);

        if (alg.equals(""RSA"")) {
            PrivateKey privateKey = keypair.getPrivate();
            Cipher cipher;
            cipher = Cipher.getInstance(""RSA"");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            byte[] dec = cipher.doFinal(Decrypted);

            System.out.println(""Decrypted String[RSA] -> "" + new String(dec));
            return new String(dec);
        } else {
            return null;
        }
    }

    public static void main(String[] args) throws Exception {
        RSAEncryptionExample RSA = new RSAEncryptionExample();
        String encryptedString = RSA.ENCRYPT(""RSA"", ""avinash"");
        RSA.DECRYPT(""RSA"", encryptedString);
    }
}
"
13433529,18358247,"import java.security.GeneralSecurityException;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import android.util.Log;

public class EncodeDecodeAES {


    private static final String TAG_DEBUG = ""TAG"";
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public EncodeDecodeAES() {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (GeneralSecurityException e) {
            Log.d(TAG_DEBUG, e.getMessage());
        }
    }

    public byte[] encrypt(String text) throws Exception {
        if (text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception {
        if (code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }

    public static String bytesToHex(byte[] data) {
        if (data == null) {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i = 0; i < len; i++) {
            if ((data[i] & 0xFF) < 16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i] & 0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i] & 0xFF);
        }
        return str;
    }

    public static byte[] hexToBytes(String str) {
        if (str == null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i = 0; i < len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);
            }
            return buffer;
        }
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i < padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
","
import javax.crypto.*;
import javax.crypto.spec.SecretKeySpec;
import java.security.*;

public class AESExample {
    public static byte[] encrypt(byte[] data, String seed) throws Exception {
        KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
        SecureRandom secrand = SecureRandom.getInstance(""SHA1PRNG"");
        secrand.setSeed(seed.getBytes());
        keygen.init(128, secrand);

        SecretKey seckey = keygen.generateKey();
        byte[] rawKey = seckey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        return cipher.doFinal(data);
    }

    public static byte[] decrypt(byte[] data, String seed) throws Exception {
        KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
        SecureRandom secrand = SecureRandom.getInstance(""SHA1PRNG"");
        secrand.setSeed(seed.getBytes());
        keygen.init(128, secrand);

        SecretKey seckey = keygen.generateKey();
        byte[] rawKey = seckey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        return cipher.doFinal(data);
    }
}
"
18573573,18573851,"import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class AesFileIo {
//    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private static final String AES_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    public AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String decrypt(String text) {

        StringBuilder stringBuilder = new StringBuilder(); 
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);
            String decryptedValue = new String(cipher.doFinal(decordedValue),""UTF-8"");
            Log.e(""decrypted Value :"",decryptedValue);
            return decryptedValue; 
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public String encrypt(String text) {
        String encryptedValue=null;
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encValue = cipher.doFinal(text.getBytes());
            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return encryptedValue;
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.Arrays;
import android.util.Base64;

public class AESExample {
    private static SecretKeySpec secretKey;
    private static byte[] key;

    public static void main(String[] args) {
        String userCredential = ""myUserCredential123"";
        String password = ""myStrongPassword"";

        try {
            byte[] encryptedBytes = encrypt(userCredential, password);
            String encryptedString = Base64.encodeToString(encryptedBytes, Base64.DEFAULT);
            System.out.println(""Encrypted user credential: "" + encryptedString);

            String decryptedString = decrypt(encryptedBytes, password);
            System.out.println(""Decrypted user credential: "" + decryptedString);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static byte[] encrypt(String data, String password) throws Exception {
        setKey(password);
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        return cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
    }

    public static String decrypt(byte[] encryptedData, String password) throws Exception {
        setKey(password);
        Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] decryptedBytes = cipher.doFinal(encryptedData);
        return new String(decryptedBytes);
    }

    private static void setKey(String password) throws Exception {
        MessageDigest sha = null;
        key = password.getBytes(StandardCharsets.UTF_8);
        sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        secretKey = new SecretKeySpec(key, ""AES"");
    }
}
"
17972024,17975379,"import java.security.Provider;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Hex;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class Cast6 {

    static final String KEY_ALGO = ""CAST6"";
    static final String CIPHER_ALGO = ""CAST6/ECB/NOPADDING"";
    
    static String keytext = ""2342bb9efa38542c0af75647f29f615d"";
    static String plaintext = ""00000000000000000000000000000000"";
    static String ciphertext = ""c842a08972b43d20836c91d1b7530f6b"";
    
    static Provider bc = new BouncyCastleProvider();
    
    public static void main(String[] args) throws Exception {
        
        System.out.println(""encrypting"");
        String actual = encrypt();
        System.out.println(""actual: "" + actual);
        System.out.println(""expect: "" + ciphertext);

        System.out.println(""decrypting"");
        actual = decrypt();
        System.out.println(""actual: "" + actual);
        System.out.println(""expect: "" + plaintext);
    }

    static String encrypt() throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);
        
        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        
        byte[] input = Hex.decodeHex(plaintext.toCharArray());
        byte[] output = cipher.doFinal(input);
        String actual = Hex.encodeHexString(output);
        return actual;
    }
    

    static String decrypt() throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);
        
        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.DECRYPT_MODE, key);
        
        byte[] output = cipher.doFinal(Hex.decodeHex(ciphertext.toCharArray()));
        
        String actual = Hex.encodeHexString(output);
        return actual;  
    }

}
","
import java.io.UnsupportedEncodingException;
import java.security.Security;

import org.bouncycastle.crypto.BufferedBlockCipher;
import org.bouncycastle.crypto.CryptoException;
import org.bouncycastle.crypto.engines.CAST6Engine;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.util.encoders.Base64;

public class Test {
    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    public static final String UTF8 = ""utf-8"";
    public static final String KEY = ""CLp4j13gADa9AmRsqsXGJ"";

    public static byte[] encrypt(String inputString) throws UnsupportedEncodingException {
        final BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CAST6Engine());
        byte[] key = KEY.getBytes(UTF8);
        byte[] input = inputString.getBytes(UTF8);
        cipher.init(true, new KeyParameter(key));

        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];

        int outputLen = cipher.processBytes(input, 0, input.length, cipherText, 0);
        try {
            outputLen += cipher.doFinal(cipherText, outputLen);
        } catch (CryptoException ce) {
            System.err.println(ce);
            System.exit(1);
        }
        
        // Truncate the cipherText to correct length
        byte[] result = new byte[outputLen];
        System.arraycopy(cipherText, 0, result, 0, outputLen);
        
        return result;
    }

    public static void main(String[] args) throws UnsupportedEncodingException {
        final String toEncrypt = ""hola"";
        final String encrypted = new String(Base64.encode(encrypt(toEncrypt)), UTF8);
        System.out.println(encrypted);
    }
}
"
17079579,17080884,"    import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class DescEncrypter {

    public static final int SALT_LENGTH = 20;
    public static final int PBE_ITERATION_COUNT = 200; //1024;

    private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";

    //algoritmo / modo / relleno 
    private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

    byte[] iv = ""1234567890asdfgh"".getBytes();

    byte[] salt = ""dfghjklpoiuytgftgyhj"".getBytes();

    public byte[] encrypt(String password, String cleartext) {

        byte[] encryptedText = null;

        try {


            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);

            //Realizamos el cifrado
            encryptedText = encryptionCipher.doFinal(cleartext.getBytes());

        } catch (Exception e) {
            e.printStackTrace();
        }

        return encryptedText;
    }

    public String decrypt(String password, byte[] encryptedText) {

        String cleartext = """";

        try {

            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);

            //Realizamos el descifrado
            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);

            cleartext =  new String(decryptedText); 

        } catch (Exception e) {
            e.printStackTrace();
        }

        return cleartext;
    }      
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class AES_Algo {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/ECB/PKCS5Padding""; // Change this if necessary

    public static String decrypt(String key, String encryptedData) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(StandardCharsets.UTF_8), ALGORITHM);
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) {
        String masterKey = ""eX0XcsF8lkeX0XcsF8lkeX0XcsF8lkeX0XcsF8lkeX0XcsF8lk"";
        try {
            String decryptedString = AES_Algo.decrypt(masterKey, ""LVmDIcmVIuNVPObjLXkVbFc13NCX1Md3DjrvfiioMQHS7QmizT3dlSujgA7NS0zI HEweRWGcwOKpu0wurK495yCTWkJO33X1n+at60xLdJ7ZUreRWN9RatUjRQuLI7Ft kwH7QMTQAYXQizGJ0HrArja8QA/YnkiGpgO0pdmYm9Mb6g/sIXhz1Oeo42uwzTM1 F+t6AM/qrH9ZMozlctU6LQQVIggP8zzmnwvjNCyyYJCsXedOEMcvrpQV100gz+pf cE4RisPgN0IOKzvzepJ88E3VMPCXBv/AV4Z2/fuBcmimzGdvZwKgYM/39TGNBS7t T491knA3ZdMoAnSPFvdM4khfRyM5I9FJpwDxmpykA4VpBUhyd4p+ZS1ZSQ8Zwi3I 5egtoNkSJhI6pjAR7PbzJtJ+VAWCVIdsFP4Kc+KKPBE0HVS5UiQQ+OJjx2r9iMMR OYqeyqMv8xw3Wy7TBMiKnQMCRo5+K1mDabx164+6cfoKk8+6b5WlNfBQVobZpQs2"");
            System.out.println(decryptedString);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
15669550,15669908,"import java.security.MessageDigest;
import java.math.BigInteger;
import javax.xml.bind.DatatypeConverter;

public class TestHash3 {

    public static void main(String[] args) throws Exception {
        String hexString = ""1234"";

        /*
         * NB!
         * Before passing hex string to DatatypeConverter.parseHexBinary(),
         * we need to check if the hex sting is even-length, 
         * otherwise DatatypeConverter.parseHexBinary() will throw a
         * java.lang.IllegalArgumentException: hexBinary needs to be even-length
         */
        hexString = (hexString.length() % 2 == 0) ? hexString : ""0"" + hexString;
        byte[] bytes = DatatypeConverter.parseHexBinary(hexString);

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] byteData = md.digest(bytes);

        System.out.println(""1) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString1(byteData));
        System.out.println(""2) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString2(byteData));
        System.out.println(""3) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString3(byteData));
        System.out.println(""4) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString4(byteData));
    }

    public static String bytesToHexString1(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i < bytes.length; i++) {
            hexBuffer.append(Integer.toString((bytes[i] & 0xFF) + 0x100, 16).substring(1));
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString2(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer(bytes.length * 2);
        for (byte b: bytes) {
            int n = b & 0xFF;   // casting to integer to avoid problems with negative bytes
            if (n < 0x10) {
                hexBuffer.append(""0"");
            }
            hexBuffer.append(Integer.toHexString(n));
        }

        return hexBuffer.toString();
    }       

    public static String bytesToHexString3(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i < bytes.length; i++) {
            String hexString = Integer.toHexString(0xff & bytes[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hexString.length() == 1) {
                hexBuffer.append('0');
            }
            hexBuffer.append(hexString);
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString4(byte[] bytes) {
        String hexString = new BigInteger(1, bytes).toString(16);

        /*
         * NB!
         * We need an even-length hex string to propely represent bytes in hexadecimal.
         * A hexadecimal representation of one byte consists of two hex digits.
         * If the value is less than 16 (dec), it is prepended with zero
         * E.g.:
         * 1  (byte)    ==> 01 (hex)    // pay attention to the prepended zero
         * 15 (byte)    ==> 0F (hex)
         * 16 (byte)    ==> 10 (hex)    // no need to prepend
         * 255(byte)    ==> FF (hex)
         *
         * BigInteger.toString(16) can return both even and odd-length hex strings.
         * E.g.:
         * byte[] bytes = {15, 16}  // two bytes
         * BigInteger(1, bytes).toString(16) will produce (NB!): f10
         * But we need (NB!): 0f10
         * So we must check if the resulting hex string is even-length,
         * and if not, prepend it with zero.
         */
        return ((hexString.length() % 2 == 0) ? hexString : ""0"" + hexString);
    }
}
","
import java.nio.ByteBuffer;
import java.security.MessageDigest;

public class Main {
    public static void main(String[] args) {
        try {
            String ss = ""9a"";
            byte[] ba = hexStringToByteArray(ss);
            MessageDigest md = MessageDigest.getInstance(""SHA-1"");
            byte[] digest = md.digest(ba);
            String results = byteArrayToHexString(digest);
            System.out.println(""sha:"" + results);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static byte[] hexStringToByteArray(String hex) {
        int len = hex.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                                 + Character.digit(hex.charAt(i+1), 16));
        }
        return data;
    }

    public static String byteArrayToHexString(byte[] array) {
        StringBuilder sb = new StringBuilder();
        for(byte b : array) {
            sb.append(String.format(""%02x"", b));
        }
        return sb.toString();
    }
}
"
15669550,15669908,"import java.security.MessageDigest;

public class TestHash {

    public static void main(String[] args) throws Exception {
        String password = ""9a"";

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(password.getBytes());
        byte[] byteData = md.digest();
        // byte[] byteData = md.digest(password.getBytes());    // both updates and completes the hash computation

        // Method 1 of converting bytes to hex format
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < byteData.length; i++) {
            sb.append(Integer.toString((byteData[i] & 0xFF) + 0x100, 16).substring(1));
        }

        System.out.println(""1) Hex format : "" + sb.toString());

        // Method 2 of converting bytes to hex format
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < byteData.length; i++) {
            String hex = Integer.toHexString(0xff & byteData[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        System.out.println(""2) Hex format : "" + hexString.toString());      
    }
}
","
import java.nio.ByteBuffer;
import java.security.MessageDigest;

public class Main {
    public static void main(String[] args) {
        try {
            String ss = ""9a"";
            byte[] ba = hexStringToByteArray(ss);
            MessageDigest md = MessageDigest.getInstance(""SHA-1"");
            byte[] digest = md.digest(ba);
            String results = byteArrayToHexString(digest);
            System.out.println(""sha:"" + results);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static byte[] hexStringToByteArray(String hex) {
        int len = hex.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)
                                 + Character.digit(hex.charAt(i+1), 16));
        }
        return data;
    }

    public static String byteArrayToHexString(byte[] array) {
        StringBuilder sb = new StringBuilder();
        for(byte b : array) {
            sb.append(String.format(""%02x"", b));
        }
        return sb.toString();
    }
}
"
15669550,15669908,"import java.security.MessageDigest;
import java.math.BigInteger;
import javax.xml.bind.DatatypeConverter;

public class TestHash3 {

    public static void main(String[] args) throws Exception {
        String hexString = ""1234"";

        /*
         * NB!
         * Before passing hex string to DatatypeConverter.parseHexBinary(),
         * we need to check if the hex sting is even-length, 
         * otherwise DatatypeConverter.parseHexBinary() will throw a
         * java.lang.IllegalArgumentException: hexBinary needs to be even-length
         */
        hexString = (hexString.length() % 2 == 0) ? hexString : ""0"" + hexString;
        byte[] bytes = DatatypeConverter.parseHexBinary(hexString);

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] byteData = md.digest(bytes);

        System.out.println(""1) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString1(byteData));
        System.out.println(""2) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString2(byteData));
        System.out.println(""3) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString3(byteData));
        System.out.println(""4) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString4(byteData));
    }

    public static String bytesToHexString1(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i < bytes.length; i++) {
            hexBuffer.append(Integer.toString((bytes[i] & 0xFF) + 0x100, 16).substring(1));
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString2(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer(bytes.length * 2);
        for (byte b: bytes) {
            int n = b & 0xFF;   // casting to integer to avoid problems with negative bytes
            if (n < 0x10) {
                hexBuffer.append(""0"");
            }
            hexBuffer.append(Integer.toHexString(n));
        }

        return hexBuffer.toString();
    }       

    public static String bytesToHexString3(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i < bytes.length; i++) {
            String hexString = Integer.toHexString(0xff & bytes[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hexString.length() == 1) {
                hexBuffer.append('0');
            }
            hexBuffer.append(hexString);
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString4(byte[] bytes) {
        String hexString = new BigInteger(1, bytes).toString(16);

        /*
         * NB!
         * We need an even-length hex string to propely represent bytes in hexadecimal.
         * A hexadecimal representation of one byte consists of two hex digits.
         * If the value is less than 16 (dec), it is prepended with zero
         * E.g.:
         * 1  (byte)    ==> 01 (hex)    // pay attention to the prepended zero
         * 15 (byte)    ==> 0F (hex)
         * 16 (byte)    ==> 10 (hex)    // no need to prepend
         * 255(byte)    ==> FF (hex)
         *
         * BigInteger.toString(16) can return both even and odd-length hex strings.
         * E.g.:
         * byte[] bytes = {15, 16}  // two bytes
         * BigInteger(1, bytes).toString(16) will produce (NB!): f10
         * But we need (NB!): 0f10
         * So we must check if the resulting hex string is even-length,
         * and if not, prepend it with zero.
         */
        return ((hexString.length() % 2 == 0) ? hexString : ""0"" + hexString);
    }
}
","
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import javax.xml.bind.DatatypeConverter;

public class Main {
    public static void main(String[] args) {
        String ss = ""9a"";
        byte[] ba = DatatypeConverter.parseHexBinary(ss);
        try {
            MessageDigest md = MessageDigest.getInstance(""SHA-1"");
            byte[] hash = md.digest(ba);
            String results = DatatypeConverter.printHexBinary(hash).toLowerCase();
            System.out.println(""SHA-1: "" + results);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
15669550,15669908,"import java.security.MessageDigest;

public class TestHash {

    public static void main(String[] args) throws Exception {
        String password = ""9a"";

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(password.getBytes());
        byte[] byteData = md.digest();
        // byte[] byteData = md.digest(password.getBytes());    // both updates and completes the hash computation

        // Method 1 of converting bytes to hex format
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < byteData.length; i++) {
            sb.append(Integer.toString((byteData[i] & 0xFF) + 0x100, 16).substring(1));
        }

        System.out.println(""1) Hex format : "" + sb.toString());

        // Method 2 of converting bytes to hex format
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < byteData.length; i++) {
            String hex = Integer.toHexString(0xff & byteData[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        System.out.println(""2) Hex format : "" + hexString.toString());      
    }
}
","
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import javax.xml.bind.DatatypeConverter;

public class Main {
    public static void main(String[] args) {
        String ss = ""9a"";
        byte[] ba = DatatypeConverter.parseHexBinary(ss);
        try {
            MessageDigest md = MessageDigest.getInstance(""SHA-1"");
            byte[] hash = md.digest(ba);
            String results = DatatypeConverter.printHexBinary(hash).toLowerCase();
            System.out.println(""SHA-1: "" + results);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
20929105,20929131,"import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt()
    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.Base64;

public class EncryptionUtils {
    private static final String KEY = ""SecretKey1234567"";

    public static String encrypt(String data) throws Exception {
        Key secretKey = new SecretKeySpec(KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedBytes = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }

    public static String decrypt(String encryptedData) throws Exception {
        Key secretKey = new SecretKeySpec(KEY.getBytes(StandardCharsets.UTF_8), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(encryptedData));
        return new String(decryptedBytes, StandardCharsets.UTF_8);
    }

    public static void main(String[] args) {
        try {
            String originalData = ""Hello, World!"";
            String encryptedData = encrypt(originalData);
            String decryptedData = decrypt(encryptedData);

            System.out.println(""Original Data: "" + originalData);
            System.out.println(""Encrypted Data: "" + encryptedData);
            System.out.println(""Decrypted Data: "" + decryptedData);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
24338108,24339146,"import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;
import java.util.*;

/**
 *  This class encrypts and decrypts a file using CipherStreams
 *  and a 256-bit Rijndael key. The key is then encrypted using
 *  a 1024-bit RSA key, which is password-encrypted.
 */
public class FileEncryptorRSA {
  /**
   *    When files are encrypted, this will be appended to the end
   *    of the filename.
   */
  private static final String ENCRYPTED_FILENAME_SUFFIX="".encrypted"";

  /**
   *    When files are decrypted, this will be appended to the end
   *    of the filename.
   */
  private static final String DECRYPTED_FILENAME_SUFFIX="".decrypted"";

  /**
   *    Number of times the password will be hashed with MD5
   *    when transforming it into a TripleDES key.
   */
  private static final int ITERATIONS = 1000;

  /**
   *    FileEncryptor is started with one of three options:
   *
   *    -c: create key pair and write it to 2 files
   *    -e: encrypt a file, given as an argument
   *    -d: decrypt a file, given as an argument
   */
  public static void main (String[] args)
  throws Exception {
    if ((args.length < 1) || (args.length > 2)) {
      usage();
    } else if (""-c"".equals(args[0])) {
      createKey();
    } else if (""-e"".equals(args[0])) {
      encrypt(args[1]);
    } else if (""-d"".equals(args[0])) {
      decrypt(args[1]);
    } else {
      usage();
    }
  }

  private static void usage() {
    System.err.println(""Usage: java FileEncryptor -c|-e|-d [filename]"");
    System.exit(1);
  }

  /**
   *    Creates a 1024 bit RSA key and stores it to
   *    the filesystem as two files.
   */
  private static void createKey()
  throws Exception {
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    System.out.print(""Password to encrypt the private key: "");
    String password = in.readLine();
    System.out.println(""Generating an RSA keypair..."");

    // Create an RSA key
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    keyPairGenerator.initialize(1024);
    KeyPair keyPair = keyPairGenerator.genKeyPair();

    System.out.println(""Done generating the keypair.\n"");

    // Now we need to write the public key out to a file
    System.out.print(""Public key filename: "");
    String publicKeyFilename = in.readLine();

    // Get the encoded form of the public key so we can
    // use it again in the future. This is X.509 by default.
    byte[] publicKeyBytes = keyPair.getPublic().getEncoded();

    // Write the encoded public key out to the filesystem
    FileOutputStream fos = new FileOutputStream(publicKeyFilename);
    fos.write(publicKeyBytes);
    fos.close();

    // Now we need to do the same thing with the private key,
    // but we need to password encrypt it as well.
    System.out.print(""Private key filename: "");
    String privateKeyFilename = in.readLine();

    // Get the encoded form. This is PKCS#8 by default.
    byte[] privateKeyBytes = keyPair.getPrivate().getEncoded();

    // Here we actually encrypt the private key
    byte[] encryptedPrivateKeyBytes =
    passwordEncrypt(password.toCharArray(),privateKeyBytes);

    fos = new FileOutputStream(privateKeyFilename);
    fos.write(encryptedPrivateKeyBytes);
    fos.close();
  }

  /**
   *    Encrypt the given file with a session key encrypted with an
   *    RSA public key which will be read in from the filesystem.
   */
  private static void encrypt(String fileInput)
  throws Exception {

    BufferedReader in = new BufferedReader
    (new InputStreamReader(System.in));
    System.out.print(""Public Key to encrypt with: "");
    String publicKeyFilename = in.readLine();

    // Load the public key bytes
    FileInputStream fis = new FileInputStream(publicKeyFilename);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    int theByte = 0;
    while ((theByte = fis.read()) != -1)
    {
      baos.write(theByte);
    }
    fis.close();

    byte[] keyBytes = baos.toByteArray();
    baos.close();

    // Turn the encoded key into a real RSA public key.
    // Public keys are encoded in X.509.
    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PublicKey publicKey = keyFactory.generatePublic(keySpec);

    // Open up an output file for the output of the encryption
    String fileOutput = fileInput + ENCRYPTED_FILENAME_SUFFIX;
    DataOutputStream output = new DataOutputStream
    (new FileOutputStream(fileOutput));

    // Create a cipher using that key to initialize it
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey);

    // Now create a new 256 bit Rijndael key to encrypt the file itself.
    // This will be the session key.
    KeyGenerator rijndaelKeyGenerator = KeyGenerator.getInstance(""Rijndael"");
    rijndaelKeyGenerator.init(256);
    System.out.println(""Generating session key..."");
    Key rijndaelKey = rijndaelKeyGenerator.generateKey();
    System.out.println(""Done generating key."");

    // Encrypt the Rijndael key with the RSA cipher
    // and write it to the beginning of the file.
    byte[] encodedKeyBytes= rsaCipher.doFinal(rijndaelKey.getEncoded());
    output.writeInt(encodedKeyBytes.length);
    output.write(encodedKeyBytes);

    // Now we need an Initialization Vector for the symmetric cipher in CBC mode
    SecureRandom random = new SecureRandom();
    byte[] iv = new byte[16];
    random.nextBytes(iv);

    // Write the IV out to the file.
    output.write(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);

    // Create the cipher for encrypting the file itself.
    Cipher symmetricCipher = Cipher.getInstance(""Rijndael/CBC/PKCS5Padding"");
    symmetricCipher.init(Cipher.ENCRYPT_MODE, rijndaelKey, spec);

    CipherOutputStream cos = new CipherOutputStream(output, symmetricCipher);

    System.out.println(""Encrypting the file..."");

    FileInputStream input = new FileInputStream(fileInput);

    theByte = 0;
    while ((theByte = input.read()) != -1)
    {
      cos.write(theByte);
    }
    input.close();
    cos.close();
    System.out.println(""File encrypted."");
    return;
  }

  /**
   *    Decrypt the given file.
   *    Start by getting the RSA private key
   *    and decrypting the session key embedded
   *    in the file. Then decrypt the file with
   *    that session key.
   */
  private static void decrypt(String fileInput)
  throws Exception {

    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    System.out.print(""Private Key to decrypt with: "");
    String privateKeyFilename = in.readLine();

    System.out.print(""Password for the private key: "");
    String password = in.readLine();

    // Load the private key bytes
    FileInputStream fis = new FileInputStream(privateKeyFilename);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    int theByte = 0;
    while ((theByte = fis.read()) != -1)
    {
      baos.write(theByte);
    }
    fis.close();

    byte[] keyBytes = baos.toByteArray();
    baos.close();

    keyBytes = passwordDecrypt(password.toCharArray(), keyBytes);

    // Turn the encoded key into a real RSA private key.
    // Private keys are encoded in PKCS#8.
    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PrivateKey privateKey = keyFactory.generatePrivate(keySpec);

    // Create a cipher using that key to initialize it
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");

    // Read in the encrypted bytes of the session key
    DataInputStream dis = new DataInputStream(new FileInputStream(fileInput));
    byte[] encryptedKeyBytes = new byte[dis.readInt()];
    dis.readFully(encryptedKeyBytes);

    // Decrypt the session key bytes.
    rsaCipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte[] rijndaelKeyBytes = rsaCipher.doFinal(encryptedKeyBytes);

    // Transform the key bytes into an actual key.
    SecretKey rijndaelKey = new SecretKeySpec(rijndaelKeyBytes, ""Rijndael"");

    // Read in the Initialization Vector from the file.
    byte[] iv = new byte[16];
    dis.read(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance(""Rijndael/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, rijndaelKey, spec);
    CipherInputStream cis = new CipherInputStream(dis, cipher);

    System.out.println(""Decrypting the file..."");
    FileOutputStream fos = new FileOutputStream(fileInput + DECRYPTED_FILENAME_SUFFIX);

    // Read through the file, decrypting each byte.
    theByte = 0;
    while ((theByte = cis.read()) != -1)
    {
      fos.write(theByte);
    }
    cis.close();
    fos.close();
    System.out.println(""Done."");
    return;
  }

  /**
   *    Utility method to encrypt a byte array with a given password.
   *    Salt will be the first 8 bytes of the byte array returned.
   */
  private static byte[] passwordEncrypt(char[] password, byte[] plaintext) throws Exception {

    // Create the salt.
    byte[] salt = new byte[8];
    Random random = new Random();
    random.nextBytes(salt);

    // Create a PBE key and cipher.
    PBEKeySpec keySpec = new PBEKeySpec(password);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithSHAAndTwofish-CBC"");
    SecretKey key = keyFactory.generateSecret(keySpec);
    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATIONS);
    Cipher cipher = Cipher.getInstance(""PBEWithSHAAndTwofish-CBC"");
    cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

    // Encrypt the array
    byte[] ciphertext = cipher.doFinal(plaintext);

    // Write out the salt, then the ciphertext and return it.
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    baos.write(salt);
    baos.write(ciphertext);
    return baos.toByteArray();
  }

  /**
   *    Utility method to decrypt a byte array with a given password.
   *    Salt will be the first 8 bytes in the array passed in.
   */
  private static byte[] passwordDecrypt(char[] password, byte[] ciphertext) throws Exception {

    // Read in the salt.
    byte[] salt = new byte[8];
    ByteArrayInputStream bais = new ByteArrayInputStream(ciphertext);
    bais.read(salt,0,8);

    // The remaining bytes are the actual ciphertext.
    byte[] remainingCiphertext = new byte[ciphertext.length-8];
    bais.read(remainingCiphertext,0,ciphertext.length-8);

    // Create a PBE cipher to decrypt the byte array.
    PBEKeySpec keySpec = new PBEKeySpec(password);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithSHAAndTwofish-CBC"");
    SecretKey key = keyFactory.generateSecret(keySpec);
    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATIONS);
    Cipher cipher = Cipher.getInstance(""PBEWithSHAAndTwofish-CBC"");

    // Perform the actual decryption.
    cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
    return cipher.doFinal(remainingCiphertext);
  }
}
","
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.Cipher;

public class EncryptionApp {
    public static void main(String[] args) throws Exception {
        // Read the public key file
        byte[] publicKeyBytes = Files.readAllBytes(Paths.get(""public_key.pem""));

        // Create a PublicKey object from the key bytes
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyBytes));

        // Plain text to encrypt
        String plainText = ""Hello, World!"";

        // Encrypt the plain text using the public key
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());

        // Print the encrypted text
        System.out.println(""Encrypted text: "" + new String(encryptedBytes));
    }
}
"
23374233,23455539,"import android.util.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Created by sergi.castellsague on 04/05/2014.
 */
public class SecurityManager
{
private static final int ITERATIONS = 1000;

public enum HashMethod
{
    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }
    };

    public abstract String getHashString();

}

public static HashMethod getAppropriateHash()
{
    HashMethod method = null;

    if ( isPBKDFAvailable() )
    {
        method = HashMethod.PBKDF2;
    }
    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }
    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
    {
        method = HashMethod.SHA1;
    }

    return method;
}


private static boolean isPBKDFAvailable()
{
    try
    {
        SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
    }
    catch ( Exception notAvailable)
    {
        return false;
    }
    return true;
}

private static boolean isDigestAvailable( String method )
{
    try
    {
        MessageDigest.getInstance( method );
    }
    catch ( Exception notAvailable )
    {
        return false;
    }

    return true;
}

public static String getHashedPassword( HashMethod method, String password )
{
    String hashed;

    if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )
    {
        hashed = generatePBKDF( password );
    }
    else
    {
        hashed = password;
        for ( int i = 0; i < ITERATIONS; i++ )
        {
            hashed = generateDigestPassword( password, method.getHashString() );
        }
    }

    return hashed;
}

private static String generatePBKDF( String password )
{
    // Generate a 512-bit key
    final int outputKeyLength = 512;

    char[] chars = new char[password.length()];
    password.getChars( 0, password.length(), chars, 0 );
    byte[] salt = ""salt_on_client_is_funny"".getBytes(); // In security terms, this is worthess. However, it's required.

    byte[] hashedPassBytes = new byte[0];
    try
    {
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
        KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );

        hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();
    }
    catch ( Exception shouldNotHappen )
    {}

    return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );
}

private static String generateDigestPassword( String password, String algorithm )
{
    byte[] digest = new byte[0];
    byte[] buffer = password.getBytes();

    try {
        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
        messageDigest.reset();
        messageDigest.update( buffer );
        digest = messageDigest.digest();
    }
    catch ( NoSuchAlgorithmException ex )
    {}

    return Base64.encodeToString(digest, Base64.DEFAULT);
}
}
","
import java.security.Provider;
import java.security.Security;
import java.util.HashSet;
import java.util.Set;

public class AvailableHashAlgorithms {

    public static Set<String> getAvailableAlgorithms() {
        Set<String> algorithms = new HashSet<>();
        for (Provider provider : Security.getProviders()) {
            for (Object key : provider.keySet()) {
                String keyString = key.toString();
                if (keyString.startsWith(""MessageDigest."")) {
                    algorithms.add(keyString.substring(""MessageDigest."".length()));
                }
            }
        }
        return algorithms;
    }

    public static void main(String[] args) {
        Set<String> availableAlgorithms = getAvailableAlgorithms();
        for (String algorithm : availableAlgorithms) {
            System.out.println(algorithm);
        }
    }
}
"
22201511,22218410,"import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class Crypto {
     public static final String TAG = ""smsfwd"";

        private static Cipher aesCipher;
        private static SecretKey secretKey;
        private static IvParameterSpec ivParameterSpec;

        private static String CIPHER_TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
        private static String CIPHER_ALGORITHM = ""AES"";
        // Replace me with a 16-byte key, share between Java and C#
        private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        private static String MESSAGEDIGEST_ALGORITHM = ""MD5"";

        public Crypto(String passphrase) {
            byte[] passwordKey = encodeDigest(passphrase);

            try {
                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
            } catch (NoSuchPaddingException e) {
                Log.e(TAG, ""No such padding PKCS5"", e);
            }

            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
            ivParameterSpec = new IvParameterSpec(rawSecretKey);
        }

        public String encryptAsBase64(byte[] clearData) {
            byte[] encryptedData = encrypt(clearData);
            return  Base64.encodeToString(encryptedData, Base64.DEFAULT);
        }

        public byte[] encrypt(byte[] clearData) {
            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }

            byte[] encryptedData;
            try {
                encryptedData = aesCipher.doFinal(clearData);
            } catch (IllegalBlockSizeException e) {
                Log.e(TAG, ""Illegal block size"", e);
                return null;
            } catch (BadPaddingException e) {
                Log.e(TAG, ""Bad padding"", e);
                return null;
            }
            return encryptedData;
        }

        private byte[] encodeDigest(String text) {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
                return digest.digest(text.getBytes());
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
            }

            return null;
        }
}
","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import org.apache.commons.codec.binary.Hex;

public class Main {

    public static void main(String[] args) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(
                    ""MyDifficultPassw"".getBytes(StandardCharsets.UTF_8), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(""tryToEncrypt"".getBytes(StandardCharsets.UTF_8));
            System.out.println(toHex(encrypted));

        } catch (Exception e) {
            System.out.println(e.toString());
        }
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private final static String HEX = ""0123456789ABCDEF"";

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
    }
}
"
6486121,20066617,"package com.cipher;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encrypt {

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        // TODO Auto-generated method stub
String s=""You are doing encryption at deep level"";
SecureRandom sr=SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(s.getBytes());
byte[] k=new byte[128/8];
sr.nextBytes(k);
SecretKeySpec spec=new SecretKeySpec(k,""AES"");
byte[] iv={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
IvParameterSpec ivs=new IvParameterSpec(iv);
Cipher cps=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cps.init(Cipher.ENCRYPT_MODE,spec,ivs);
byte[] iv2=cps.doFinal(s.getBytes());
System.out.println(""En""+iv2);
Cipher cpr=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cpr.init(Cipher.DECRYPT_MODE, spec,ivs);
byte[] iv3=cpr.doFinal(iv2);
String ds=new String(iv3);
System.out.println(ds);


    }

}
","
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class SimpleCrypto {

    public static void main(String[] args) {
        try {
            String masterPassword = ""YourMasterPassword"";
            String cleartext = ""Hello, World!"";
            String encrypted = encrypt(masterPassword, cleartext);
            System.out.println(""Encrypted: "" + encrypted);
            String decrypted = decrypt(masterPassword, encrypted);
            System.out.println(""Decrypted: "" + decrypted);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 128-bit AES
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(byte[] buf) {
        StringBuilder sb = new StringBuilder();
        for (byte b : buf) {
            sb.append(String.format(""%02X"", b));
        }
        return sb.toString();
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++) {
            result[i] = (byte) Integer.parseInt(hexString.substring(2 * i, 2 * i + 2), 16);
        }
        return result;
    }
}
"
28622438,28624160,"import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}
","
import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536;
    private static int keySize = 256;
    private static byte[] ivBytes;

    public static void main(String []args) throws Exception {

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {

        salt = getSalt();
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        SecretKey secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        byte[] saltBytes = salt.getBytes(""UTF-8"");
        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(String.valueOf(encryptedText));

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(encryptedText, saltBytes, iterations, keySize);
        SecretKey secretkey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretkey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        } catch (IllegalBlockSizeException | BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);
    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}
"
26633349,27928360,"import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

    /**
     * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections
     * <p>fixes https://github.com/koush/ion/issues/386</p>
     *
     * <p> see https://code.google.com/p/android/issues/detail?id=78187 </p>
     */
    public class NoSSLv3Factory extends SSLSocketFactory {
        private final SSLSocketFactory delegate;

        public NoSSLv3Factory() {
            this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
        }

        @Override
        public String[] getDefaultCipherSuites() {
            return delegate.getDefaultCipherSuites();
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return delegate.getSupportedCipherSuites();
        }

        private static Socket makeSocketSafe(Socket socket) {
            if (socket instanceof SSLSocket) {
                socket = new NoSSLv3SSLSocket((SSLSocket) socket);
            }
            return socket;
        }

        @Override
        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
        }

        /**
         * Created by robUx4 on 25/10/2014.
         */
        private static class DelegateSSLSocket extends SSLSocket {

            protected final SSLSocket delegate;

            DelegateSSLSocket(SSLSocket delegate) {
                this.delegate = delegate;
            }

            @Override
            public String[] getSupportedCipherSuites() {
                return delegate.getSupportedCipherSuites();
            }

            @Override
            public String[] getEnabledCipherSuites() {
                return delegate.getEnabledCipherSuites();
            }

            @Override
            public void setEnabledCipherSuites(String[] suites) {
                delegate.setEnabledCipherSuites(suites);
            }

            @Override
            public String[] getSupportedProtocols() {
                return delegate.getSupportedProtocols();
            }

            @Override
            public String[] getEnabledProtocols() {
                return delegate.getEnabledProtocols();
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                delegate.setEnabledProtocols(protocols);
            }

            @Override
            public SSLSession getSession() {
                return delegate.getSession();
            }

            @Override
            public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.addHandshakeCompletedListener(listener);
            }

            @Override
            public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.removeHandshakeCompletedListener(listener);
            }

            @Override
            public void startHandshake() throws IOException {
                delegate.startHandshake();
            }

            @Override
            public void setUseClientMode(boolean mode) {
                delegate.setUseClientMode(mode);
            }

            @Override
            public boolean getUseClientMode() {
                return delegate.getUseClientMode();
            }

            @Override
            public void setNeedClientAuth(boolean need) {
                delegate.setNeedClientAuth(need);
            }

            @Override
            public void setWantClientAuth(boolean want) {
                delegate.setWantClientAuth(want);
            }

            @Override
            public boolean getNeedClientAuth() {
                return delegate.getNeedClientAuth();
            }

            @Override
            public boolean getWantClientAuth() {
                return delegate.getWantClientAuth();
            }

            @Override
            public void setEnableSessionCreation(boolean flag) {
                delegate.setEnableSessionCreation(flag);
            }

            @Override
            public boolean getEnableSessionCreation() {
                return delegate.getEnableSessionCreation();
            }

            @Override
            public void bind(SocketAddress localAddr) throws IOException {
                delegate.bind(localAddr);
            }

            @Override
            public synchronized void close() throws IOException {
                delegate.close();
            }

            @Override
            public void connect(SocketAddress remoteAddr) throws IOException {
                delegate.connect(remoteAddr);
            }

            @Override
            public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
                delegate.connect(remoteAddr, timeout);
            }

            @Override
            public SocketChannel getChannel() {
                return delegate.getChannel();
            }

            @Override
            public InetAddress getInetAddress() {
                return delegate.getInetAddress();
            }

            @Override
            public InputStream getInputStream() throws IOException {
                return delegate.getInputStream();
            }

            @Override
            public boolean getKeepAlive() throws SocketException {
                return delegate.getKeepAlive();
            }

            @Override
            public InetAddress getLocalAddress() {
                return delegate.getLocalAddress();
            }

            @Override
            public int getLocalPort() {
                return delegate.getLocalPort();
            }

            @Override
            public SocketAddress getLocalSocketAddress() {
                return delegate.getLocalSocketAddress();
            }

            @Override
            public boolean getOOBInline() throws SocketException {
                return delegate.getOOBInline();
            }

            @Override
            public OutputStream getOutputStream() throws IOException {
                return delegate.getOutputStream();
            }

            @Override
            public int getPort() {
                return delegate.getPort();
            }

            @Override
            public synchronized int getReceiveBufferSize() throws SocketException {
                return delegate.getReceiveBufferSize();
            }

            @Override
            public SocketAddress getRemoteSocketAddress() {
                return delegate.getRemoteSocketAddress();
            }

            @Override
            public boolean getReuseAddress() throws SocketException {
                return delegate.getReuseAddress();
            }

            @Override
            public synchronized int getSendBufferSize() throws SocketException {
                return delegate.getSendBufferSize();
            }

            @Override
            public int getSoLinger() throws SocketException {
                return delegate.getSoLinger();
            }

            @Override
            public synchronized int getSoTimeout() throws SocketException {
                return delegate.getSoTimeout();
            }

            @Override
            public boolean getTcpNoDelay() throws SocketException {
                return delegate.getTcpNoDelay();
            }

            @Override
            public int getTrafficClass() throws SocketException {
                return delegate.getTrafficClass();
            }

            @Override
            public boolean isBound() {
                return delegate.isBound();
            }

            @Override
            public boolean isClosed() {
                return delegate.isClosed();
            }

            @Override
            public boolean isConnected() {
                return delegate.isConnected();
            }

            @Override
            public boolean isInputShutdown() {
                return delegate.isInputShutdown();
            }

            @Override
            public boolean isOutputShutdown() {
                return delegate.isOutputShutdown();
            }

            @Override
            public void sendUrgentData(int value) throws IOException {
                delegate.sendUrgentData(value);
            }

            @Override
            public void setKeepAlive(boolean keepAlive) throws SocketException {
                delegate.setKeepAlive(keepAlive);
            }

            @Override
            public void setOOBInline(boolean oobinline) throws SocketException {
                delegate.setOOBInline(oobinline);
            }

            @Override
            public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
                delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
            }

            @Override
            public synchronized void setReceiveBufferSize(int size) throws SocketException {
                delegate.setReceiveBufferSize(size);
            }

            @Override
            public void setReuseAddress(boolean reuse) throws SocketException {
                delegate.setReuseAddress(reuse);
            }

            @Override
            public synchronized void setSendBufferSize(int size) throws SocketException {
                delegate.setSendBufferSize(size);
            }

            @Override
            public void setSoLinger(boolean on, int timeout) throws SocketException {
                delegate.setSoLinger(on, timeout);
            }

            @Override
            public synchronized void setSoTimeout(int timeout) throws SocketException {
                delegate.setSoTimeout(timeout);
            }

            @Override
            public void setSSLParameters(SSLParameters p) {
                delegate.setSSLParameters(p);
            }

            @Override
            public void setTcpNoDelay(boolean on) throws SocketException {
                delegate.setTcpNoDelay(on);
            }

            @Override
            public void setTrafficClass(int value) throws SocketException {
                delegate.setTrafficClass(value);
            }

            @Override
            public void shutdownInput() throws IOException {
                delegate.shutdownInput();
            }

            @Override
            public void shutdownOutput() throws IOException {
                delegate.shutdownOutput();
            }

            @Override
            public String toString() {
                return delegate.toString();
            }

            @Override
            public boolean equals(Object o) {
                return delegate.equals(o);
            }
        }

        /**
         * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections
         * <p>fixes https://github.com/koush/ion/issues/386</p>
         */
        private static class NoSSLv3SSLSocket extends DelegateSSLSocket {

            private NoSSLv3SSLSocket(SSLSocket delegate) {
                super(delegate);

                String canonicalName = delegate.getClass().getCanonicalName();
                if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")) {
                    // try replicate the code from HttpConnection.setupSecureSocket()
                    try {
                        Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
                        if (null != msetUseSessionTickets) {
                            msetUseSessionTickets.invoke(delegate, true);
                        }
                    } catch (NoSuchMethodException ignored) {
                    } catch (InvocationTargetException ignored) {
                    } catch (IllegalAccessException ignored) {
                    }
                }
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                if (protocols != null && protocols.length == 1 && ""SSLv3"".equals(protocols[0])) {
                    // no way jose
                    // see issue https://code.google.com/p/android/issues/detail?id=78187
                    List<String> enabledProtocols = new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
                    if (enabledProtocols.size() > 1) {
                        enabledProtocols.remove(""SSLv3"");
                    }
                    protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
                }
                super.setEnabledProtocols(protocols);
            }
        }

    }
","
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import java.io.IOException;
import java.net.URL;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

public class Main {

    public static void main(String[] args) throws IOException, NoSuchAlgorithmException, KeyManagementException {
        // Create a custom TrustManager that trusts all certificates
        TrustManager[] trustAllCerts = new TrustManager[] {
            new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[0];
                }
            }
        };

        // Create a custom SSLContext with the trustAllCerts TrustManager
        SSLContext sslContext = SSLContext.getInstance(""TLS"");
        sslContext.init(null, trustAllCerts, new java.security.SecureRandom());
        SSLSocketFactory tlsOnlySocketFactory = sslContext.getSocketFactory();

        // Set the custom SSLSocketFactory as the default for HttpsURLConnection
        HttpsURLConnection.setDefaultSSLSocketFactory(tlsOnlySocketFactory);

        // Set the system property to only allow TLS protocols
        System.setProperty(""https.protocols"", ""TLSv1,TLSv1.1,TLSv1.2"");

        // Make a HTTPS request
        URL url = new URL(""https://example.com"");
        HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
        connection.setRequestMethod(""GET"");

        // Handle the response
        int responseCode = connection.getResponseCode();
        System.out.println(""Response Code: "" + responseCode);
    }
}
"
26849580,26851569,"import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStore.ProtectionParameter;
import java.security.KeyStore.SecretKeyEntry;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableEntryException;
import java.security.cert.CertificateException;
import java.security.spec.InvalidParameterSpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AESWithStaticKeyAndRandomIV {

    private static final String KEY_ALIAS = ""secret"";

    private static byte[] KEY = new byte[] { (byte) 0x14, (byte) 0x0b,
            (byte) 0x41, (byte) 0xb2, (byte) 0x2a, (byte) 0x29, (byte) 0xbe,
            (byte) 0xb4, (byte) 0x06, (byte) 0x1b, (byte) 0xda, (byte) 0x66,
            (byte) 0xb6, (byte) 0x74, (byte) 0x7e, (byte) 0x14 };

    private static ProtectionParameter PASSWORD = new KeyStore.PasswordProtection(
            new char[] {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'});

    private final KeyStore store;

    private AESWithStaticKeyAndRandomIV(KeyStore store) {
        this.store = store;
    }

    public byte[] encrypt(byte[] plaintext) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }
            cipher.init(Cipher.ENCRYPT_MODE, key);

            AlgorithmParameters params = cipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

            byte[] ciphertext = new byte[iv.length
                    + cipher.getOutputSize(plaintext.length)];
            System.arraycopy(iv, 0, ciphertext, 0, iv.length);
            cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
                    iv.length);
            return ciphertext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | InvalidParameterSpecException
                | ShortBufferException | IllegalBlockSizeException
                | BadPaddingException e) {
            throw new IllegalStateException(
                    ""CBC encryption with standard algorithm should never fail"",
                    e);
        }
    }

    public byte[] decrypt(byte[] ciphertext) throws IllegalBlockSizeException,
            BadPaddingException {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }

            if (ciphertext.length < cipher.getBlockSize()) {
                throw new IllegalArgumentException(
                        ""Ciphertext too small to contain IV"");
            }

            IvParameterSpec ivSpec = new IvParameterSpec(ciphertext, 0,
                    cipher.getBlockSize());
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

            byte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length
                    - cipher.getBlockSize())];
            cipher.doFinal(ciphertext, cipher.getBlockSize(), ciphertext.length
                    - cipher.getBlockSize(), plaintext, 0);
            return plaintext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | ShortBufferException
                | InvalidAlgorithmParameterException e) {
            throw new IllegalStateException(
                    ""CBC decryption with standard algorithm should be available"",
                    e);
        }
    }

    public static KeyStore createStoreWithSecretKey() {

        try {
            KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
            keyStore.load(null);
            SecretKey key = new SecretKeySpec(KEY, ""AES"");
            keyStore.setEntry(KEY_ALIAS, new KeyStore.SecretKeyEntry(key), PASSWORD);
            return keyStore;
        } catch (KeyStoreException | NoSuchAlgorithmException
                | CertificateException | IOException e) {
            throw new IllegalStateException(""Unable to create key store"", e);
        }
    }

    public static void main(String[] args) throws Exception {
        AESWithStaticKeyAndRandomIV crypt = new AESWithStaticKeyAndRandomIV(
                createStoreWithSecretKey());

        byte[] plaintext = crypt.decrypt(crypt.encrypt(""owlstead""
                .getBytes(StandardCharsets.UTF_8)));
        System.out.println(new String(plaintext, StandardCharsets.UTF_8));
    }
}
","
import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class AESExample {
    private static final String ALGORITHM = ""AES"";
    private static final String TRANSFORMATION = ""AES/CBC/PKCS5Padding"";

    public static void main(String[] args) {
        try {
            String key = ""mySecretKey12345""; // Your secret key here
            String iv = ""0123456789abcdef""; // Your initialization vector here

            String plainText = ""Hello, world!"";

            String encryptedText = encrypt(plainText, key, iv);
            System.out.println(""Encrypted Text: "" + encryptedText);

            String decryptedText = decrypt(encryptedText, key, iv);
            System.out.println(""Decrypted Text: "" + decryptedText);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String encrypt(String plainText, String key, String iv) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes());

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);

        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(""UTF-8""));
        return Base64.encodeBase64String(encryptedBytes);
    }

    public static String decrypt(String encryptedText, String key, String iv) throws Exception {
        SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes());

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);

        byte[] decodedBytes = Base64.decodeBase64(encryptedText);
        byte[] decryptedBytes = cipher.doFinal(decodedBytes);

        return new String(decryptedBytes, ""UTF-8"");
    }
}
"
25121868,25123606,"import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//import javax.xml.bind.DatatypeConverter;
import android.util.Base64;


public class Support {

    private static final String SALT = ""3D5900AE-111A-45BE-96B3-D9E4606CA793"";
    private static final int MAX_HASH_ITERATIONS = 10;

    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String result = Support.GetPasswordHash(""test"");
        System.out.println(result);
    }

    public static String GetPasswordHash(String plaintextPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = plaintextPassword;
        for (int hashLimit = 0; hashLimit < MAX_HASH_ITERATIONS; hashLimit++) {
            hashData = GetHash(SALT + hashData);
        }
        return hashData;
    }

    //Gets the hash value of the data using SHA512Managed
    private static String GetHash(String unhashedData) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        return getMD5Password(unhashedData);
    }

    //Verifies the hash
    public static boolean VerifyHashedPassword(String plaintextPassword, String encryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = GetPasswordHash(plaintextPassword);
        return encryptedPassword.equals(hashData);
    }


    public static String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{
        MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-512""); 
        digest.update(password.getBytes(""UTF-16LE"")); 
        byte messageDigest[] = digest.digest();

        StringBuilder sb = new StringBuilder();
        for(int iPos = 0; iPos < messageDigest.length; iPos++) {
            String h = Integer.toHexString(0xFF & messageDigest[iPos]);
            while (h.length() < 2) {
                h = ""0"" + h;
            }
            sb.append(h);
        }

        String md5String = sb.toString().toUpperCase();     
        String res = Base64.encodeToString(md5String.getBytes(), Base64.DEFAULT);

        return res;
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.io.UnsupportedEncodingException;

public class CMSHashManager {
    private static final String SALT = ""3D5900AE-111A-45BE-96B3-D9E4606CA793"";
    private static final int HASH_ITERATIONS_MAX = 10;

    private CMSHashManager() {
    }

    public static String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = password;
        for (int hashLimit = 0; hashLimit < HASH_ITERATIONS_MAX; hashLimit++) {
            hashData = getHash(SALT + hashData);
        }
        return hashData;
    }

    public static boolean verifyHashedPassword(String plaintextPassword, String encryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = getMD5Password(plaintextPassword);
        return encryptedPassword.equals(hashData);
    }

    private static String getHash(String unhashedData) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
        byte[] hashData = digest.digest(unhashedData.getBytes(""UTF-8""));

        StringBuilder hexString = new StringBuilder();
        for (byte b : hashData) {
            String hex = Integer.toHexString(0xFF & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String plaintext = ""12345"";
        String encrypted = ""NgkuakH7UsCQwGHMQOhVXI3nW6M+1AtREY4Qx35osQo87p/whZIzy8cZU7+R7XnmyzgMzLWSvX+rTiWzfGTPsA=="";

        boolean isMatch = verifyHashedPassword(plaintext, encrypted);
        System.out.println(""Password match: "" + isMatch);
    }
}
"
34074485,34075332,"import java.io.*;
import java.security.MessageDigest;

public class Checksums {

    public static void main(String[] args) {
        String sourceDir = ""/Users/Jan/Desktop/Folder1"";
        String targetDir = ""/Users/Jan/Desktop/Folder2"";
        try {
            new Checksums().createHash(new File(sourceDir), new File(targetDir));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void createHash(File sourceDir, File targetDir) throws Exception {
        for (File f : sourceDir.listFiles()) {
            String hash = createHash(f); // That you almost have
            File target = new File(targetDir, f.getName() + "".hash"");
            writeHash(target, hash);
        }
    }

    public String createHash(File datafile) throws Exception {
        // SNIP - YOUR CODE BEGINS
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        FileInputStream fis = new FileInputStream(datafile);
        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format
        StringBuffer sb = new StringBuffer("""");
        for (int i = 0; i < mdbytes.length; i++) {
            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }
        // SNAP - YOUR CODE ENDS
        return sb.toString();
    }

    public void writeHash(File target, String hash) {
        try (FileOutputStream fo = new FileOutputStream(target)) {
            fo.write(hash.getBytes());
            System.out.println(""Hash written for "" + target.getAbsolutePath());
        } catch (IOException e) {
            System.err.println(""No Hash Written for "" + target.getName());
        }
    }

}
","
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.security.MessageDigest;

public class HMAC {
    public static void main(String args[]) throws Exception {
        if (args.length != 2) {
            System.out.println(""Please provide two input arguments: directory1 and directory2"");
            return;
        }

        String directory1 = args[0];
        String directory2 = args[1];

        File[] files = new File(directory1).listFiles();
        if (files == null) {
            System.out.println(""Invalid directory1 path"");
            return;
        }

        MessageDigest md = MessageDigest.getInstance(""SHA1"");

        FileWriter fileWriter = new FileWriter(directory2 + ""/output.txt"");
        PrintWriter printWriter = new PrintWriter(fileWriter);

        for (File file : files) {
            if (file.isFile()) {
                FileInputStream fis = new FileInputStream(file);
                byte[] dataBytes = new byte[1024];
                int nread;

                while ((nread = fis.read(dataBytes)) != -1) {
                    md.update(dataBytes, 0, nread);
                }

                byte[] mdbytes = md.digest();

                // Convert the byte to hex format
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < mdbytes.length; i++) {
                    sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
                }

                printWriter.println(file.getName() + "" "" + sb.toString());
                System.out.println(file.getName() + "" hash value: "" + sb.toString());

                fis.close();
            }
        }

        printWriter.close();
        fileWriter.close();
    }
}
"
31432218,31433753,"import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.RijndaelEngine;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.KeyParameter;

import java.nio.charset.Charset;

public class Encrypt {
    public static void main(String[] args) throws InvalidCipherTextException {
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String data = ""sellerid=Company&returnsreference=0003&contents_value=101&contents_description=clothes&fullname=Joe%20Bloggs&company=Company&email=joe.bloggs@gmail.com&email_confirm=joe.bloggs@gmail.com&telephone=123&address_line_1=1&city=Acampo&postcode=952200001&country_code=US&weight=1&height=2&length=3&width=4"";
        encrypt(key, data);
    }

    private static void encrypt(String key, String data) throws InvalidCipherTextException {
        byte[] givenKey = key.getBytes(Charset.forName(""ASCII""));
        final int keysize = 256;
        byte[] keyData = new byte[keysize / Byte.SIZE];
        System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
        KeyParameter keyParameter = new KeyParameter(keyData);
        BlockCipher rijndael = new RijndaelEngine(256);
        ZeroBytePadding c = new ZeroBytePadding();
        PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);
        pbbc.init(true, keyParameter);
        byte[] plaintext = data.getBytes(Charset.forName(""UTF8""));
        byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
        int offset = 0;
        offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
        offset += pbbc.doFinal(ciphertext, offset);
        System.out.println(""Encrypted: "" + Base64.encodeBase64String(ciphertext));
    }
}
","
import org.apache.commons.codec.binary.Base64;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.UnsupportedEncodingException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;

public class Encrypt {
    public static byte[] ivBytes = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    public static void main(String[] args) throws InvalidKeyException, UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        String data = ""sellerid=Company&returnsreference=0003&contents_value=101&contents_description=clothes&fullname=Joe%20Bloggs&company=Company&email=joe.bloggs@gmail.com&email_confirm=joe.bloggs@gmail.com&telephone=123&address_line_1=1&city=Acampo&postcode=952200001&country_code=US&weight=1&height=2&length=3&width=4"";
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String encoded = encode(data, key);
        System.out.println(""Encoded: "" + encoded);
        String decoded = decode(encoded, key);
        System.out.println(""Decoded: "" + decoded);
    }

    public static String encode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = data.getBytes(""UTF-8"");
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
        return Base64.encodeBase64String(cipher.doFinal(textBytes));
    }

    public static String decode(String data, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        byte[] textBytes = Base64.decodeBase64(data);
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
        return new String(cipher.doFinal(textBytes), ""UTF-8"");
    }
}
"
30429112,30431207,"import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import android.util.Base64;

public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}
","
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;

public class DatabaseHelper extends SQLiteOpenHelper {
    private static final String DATABASE_NAME = ""YourDatabaseName"";
    private static final int DATABASE_VERSION = 1;

    public DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        // Create your database tables
        String createTableQuery = ""CREATE TABLE IF NOT EXISTS your_table_name (""
                + ""id INTEGER PRIMARY KEY,""
                + ""name TEXT,""
                + ""age INTEGER)"";
        db.execSQL(createTableQuery);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Upgrade your database if needed
        // Example: db.execSQL(""DROP TABLE IF EXISTS your_table_name"");
        // Then, recreate your tables by calling onCreate(db);
    }

    // Helper methods for inserting, updating, deleting records, etc.
    // Add your own methods here
    // ...

    // Usage example
    public void insertRecord(int id, String name, int age) {
        SQLiteDatabase db = this.getWritableDatabase();
        String insertQuery = ""INSERT INTO your_table_name (id, name, age) VALUES (?, ?, ?)"";
        db.execSQL(insertQuery, new Object[]{id, name, age});
        db.close();
    }
}
"
38477845,38492575,"package nl.owlstead.stackoverflow;

import java.io.File;
import java.math.BigInteger;
import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LoadRSAKeyFromText {

    public static void main(String[] args) throws Exception {
        // parse the lines to find the modulus n and public exponent e
        List<String> all = Files.readAllLines(new File(args[0]).toPath());
        String nString = null, eString = null;
        for (String line : all) {
            Pattern nPattern = Pattern.compile(""\""n\""\\s*:\\s*\""(.*?)\"",?"");
            Matcher nMatcher = nPattern.matcher(line);
            if (nMatcher.matches()) {
                nString = nMatcher.group(1).replaceAll(""\\s+"", """");
            }

            Pattern ePattern = Pattern.compile(""\""e\""\\s*:\\s*\""(.*?)\"",?"");
            Matcher eMatcher = ePattern.matcher(line);
            if (eMatcher.matches()) {
                eString = eMatcher.group(1);
            }
        }

        // decode base 64 (with _ and -, so URL safe)
        Decoder urlDecoder = Base64.getUrlDecoder();
        byte[] nData = urlDecoder.decode(nString);
        byte[] eData = urlDecoder.decode(eString);

        // convert to *positive* integers
        BigInteger n = new BigInteger(1, nData);
        BigInteger e = new BigInteger(1, eData);

        // create RSA specification and convert to key
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(n, e);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        RSAPublicKey pk = (RSAPublicKey) kf.generatePublic(keySpec);
        System.out.println(pk.getAlgorithm());
    }
}
","
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

public class PublicKeyReader {

    public static PublicKey get() throws Exception {
        String key = ""vswzzDmrqLSHUu61YDxUhM87hjcVjg42NwpFOyLQK8CyW5YRcr1YUkFRNDbb92MTNW3CsSWJX3DSuilnxf8n3_JW-A9R5JAqwmEygYIXuFcoJ_pb923bph0-ayWPBfD-qwYrELvpiEHBf1QSLJYkRb1wzAlwhCeYJorifu2WhCZoOVVYQAEyNqYF7AVhNImioT8-lhFWGqHp2Jt7-oXtCjVVyyShRHUMYyCRzGj1VGI6AU5DgVebXYD2GJawUhX-AD2CzsX8lMXeaVu88sBU9XLL1Zb_cOvAC7wTXxcls0taKx-8PiWUWKjSg0-O2ZXbfFROyQpQYHQH0BkO8XRh8w"";

        byte[] decodedKey = Base64.getDecoder().decode(key);

        X509EncodedKeySpec spec = new X509EncodedKeySpec(decodedKey);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        return kf.generatePublic(spec);
    }

    public static void main(String[] args) {
        try {
            PublicKey publicKey = new PublicKeyReader().get();
            System.out.println(publicKey);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
34522859,34533032,"package nl.owlstead.stackoverflow;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.security.Signature;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.Base64.Decoder;

import javax.crypto.Cipher;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class PKCS1PublicKey {

    public static RSAPublicKey fromPKCS1Encoding(byte[] pkcs1EncodedPublicKey) {
        // --- parse public key ---
        org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pkcs1EncodedPublicKey);
        } catch (Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        String pkey = ""MIIBCgKCAQEA2tF2g/muNw9xKTVcIkjUMvMhygtIW49yo1PgbwqDQ/w9MSfEARtYYF6Tenfz0twaR/eI14GXmlIffflORe4eaSuMBhwQFOIKU/1+v1BV3RLqGGblvHTVaMVm49AGiqxNnh1LBbcSrC5UhMqlL/HGiku0oYsbjLzwcLc5ac6aBQVD60wWGNm1g26lRQGRbCLqxVfcWKT3AMvEQK3cEx/En7/5Vg1V8xnJraNMrO8UGnaX8LLJFzYJiSCEShh7F+pMHbf4MaBekw7Aaf5hPJtczNsR137R92Be3OP4idI5NLmTV+Pi1DWlxhjEhswKH88SP+gsW31gS7B/ddECUqewQwIDAQAB"";
        Decoder decoder = Base64.getDecoder();
        byte[] dpkey = decoder.decode(pkey);
        RSAPublicKey publicKey = fromPKCS1Encoding(dpkey);

        String plainData = ""Hi I m here"";
        String data = ""aP0nuYYA1hE5odsCkR/DcdRbBvO2Z8IOlqXf/bKZJiG8HELIop90Vno1dKC1qyHEAOXy0gtH7GtJamzoBjDZmHPT6eto9EZP/xE7xZ8L05kjp0z2thLqO7on4C6DrG++TK1j+E3T7V0UeU874WIB0AEVzu1XUKFW6aeuU67a/gdn8N2n7N/WXtlyNSVZXg8f4PeUhGvFJrhINZT7BuMMZj1gZs4wMJPAICwfvVeg02RPH0N3Ybf2iVgRuZlmtQXGTyBlCxe9ybdHzuQM6nXghpLNmaOzCypb+yVs3Da7E0b3/fKQ7JqPSquWex2ERZbIMSTC6oCzc1rOF6iKVAd92Q=="";
        byte[] ciphertext = decoder.decode(data);

        // this will fail of course if the ""signature"" was generated using OAEP - use PSS signatures instead (see comments below)
        verifyBC(publicKey, plainData, ciphertext);
        System.out.flush();
        decryptBC(publicKey, plainData, ciphertext);
        System.out.flush();
        decryptSun(publicKey, plainData, ciphertext);
        System.out.flush();
    }

    private static void decryptBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""BC"");
        // this *should* fail
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }

    private static void decryptSun(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""SunJCE"");
        // this fails beautifully
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }

    private static void verifyBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        // what should work (for PKCS#1 v1.5 signatures), requires Bouncy Castle provider
        Signature sig = Signature.getInstance( ""SHA256withRSAandMGF1"");
        sig.initVerify(publicKey);
        sig.update(plainData.getBytes(UTF_8));
        System.out.println(sig.verify(ciphertext));
    }
}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.io.UnsupportedEncodingException;
import org.apache.commons.codec.binary.Base64;
import java.security.spec.X509EncodedKeySpec;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.KeyFactory;
import java.security.Signature;
import java.security.PublicKey;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.lang.String;

class PubCheck {
    public static boolean verify(String message, String signature, PublicKey publicKey) throws SignatureException {
        try {
            Signature sign = Signature.getInstance(""SHA1withRSA"");
            sign.initVerify(publicKey);
            sign.update(message.getBytes(""UTF-8""));
            return sign.verify(Base64.decodeBase64(signature.getBytes(""UTF-8"")));
        } catch (Exception ex) {
            throw new SignatureException(ex);
        }
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeySpecException, SignatureException {
        String plainData = ""Hi I m here"";
        String pkey = ""MIIBCgKCAQEA2tF2g/muNw9xKTVcIkjUMvMhygtIW49yo1PgbwqDQ/w9MSfEARtYYF6Tenfz0twaR/eI14GXmlIffflORe4eaSuMBhwQFOIKU/1+v1BV3RLqGGblvHTVaMVm49AGiqxNnh1LBbcSrC5UhMqlL/HGiku0oYsbjLzwcLc5ac6aBQVD60wWGNm1g26lRQGRbCLqxVfcWKT3AMvEQK3cEx/En7/5Vg1V8xnJraNMrO8UGnaX8LLJFzYJiSCEShh7F+pMHbf4MaBekw7Aaf5hPJtczNsR137R92Be3OP4idI5NLmTV+Pi1DWlxhjEhswKH88SP+gsW31gS7B/ddECUqewQwIDAQAB"";

        String data = ""aP0nuYYA1hE5odsCkR/DcdRbBvO2Z8IOlqXf/bKZJiG8HELIop90Vno1dKC1qyHEAOXy0gtH7GtJamzoBjDZmHPT6eto9EZP/xE7xZ8L05kjp0z2thLqO7on4C6DrG++TK1j+E3T7V0UeU874WIB0AEVzu1XUKFW6aeuU67a/gdn8N2n7N/WXtlyNSVZXg8f4PeUhGvFJrhINZT7BuMMZj1gZs4wMJPAICwfvVeg02RPH0N3Ybf2iVgRuZlmtQXGTyBlCxe9ybdHzuQM6nXghpLNmaOzCypb+yVs3Da7E0b3/fKQ7JqPSquWex2ERZbIMSTC6oCzc1rOF6iKVAd92Q=="";

        byte[] encodedPublicKey = Base64.decodeBase64(pkey);
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedPublicKey);

        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);

        boolean retvar = verify(plainData, data, publicKey);
    }
}
"
31915617,39615507,"import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;

/**
 * @author visruthcv
 *
 */
public class CryptographyUtil {

    private static final String ALGORITHM = ""RSA"";

    public static byte[] encrypt(byte[] publicKey, byte[] inputData)
            throws Exception {

        PublicKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePublic(new X509EncodedKeySpec(publicKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);

        byte[] encryptedBytes = cipher.doFinal(inputData);

        return encryptedBytes;
    }

    public static byte[] decrypt(byte[] privateKey, byte[] inputData)
            throws Exception {

        PrivateKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePrivate(new PKCS8EncodedKeySpec(privateKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, key);

        byte[] decryptedBytes = cipher.doFinal(inputData);

        return decryptedBytes;
    }

    public static KeyPair generateKeyPair()
            throws NoSuchAlgorithmException, NoSuchProviderException {

        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM);

        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");

        // 512 is keysize
        keyGen.initialize(512, random);

        KeyPair generateKeyPair = keyGen.generateKeyPair();
        return generateKeyPair;
    }

    public static void main(String[] args) throws Exception {

        KeyPair generateKeyPair = generateKeyPair();

        byte[] publicKey = generateKeyPair.getPublic().getEncoded();
        byte[] privateKey = generateKeyPair.getPrivate().getEncoded();

        byte[] encryptedData = encrypt(publicKey,
                ""hi this is Visruth here"".getBytes());

        byte[] decryptedData = decrypt(privateKey, encryptedData);

        System.out.println(new String(decryptedData));

    }

}
","
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;
import javax.crypto.*;

public class PublicPrivateKey {

    public static String getEncrypted(String data, String Key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        PublicKey publicKey = KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(Key.getBytes())));
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);
        byte[] encryptedBytes = cipher.doFinal(data.getBytes());
        return new String(Base64.getEncoder().encode(encryptedBytes));
    }

    public static String getDecrypted(String data, String Key) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        PrivateKey privateKey = KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(Base64.getDecoder().decode(Key.getBytes())));
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] encryptedBytes = cipher.doFinal(Base64.getDecoder().decode(data.getBytes()));
        return new String(encryptedBytes);
    }

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
        keyPairGenerator.initialize(1024);
        KeyPair keyPair = keyPairGenerator.genKeyPair();

        String pubKey = new String(Base64.getEncoder().encode(keyPair.getPublic().getEncoded()));
        String priKey = new String(Base64.getEncoder().encode(keyPair.getPrivate().getEncoded()));
        System.out.println(""Public Key:"" + pubKey);
        System.out.println(""Private Key:"" + priKey);
        String cipherText = getEncrypted(""hi this is a string"", pubKey);

        System.out.println(""CHIPHER:"" + cipherText);
        String decryptedText = getDecrypted(cipherText, priKey);
        System.out.println(""DECRYPTED STRING:"" + decryptedText);
    }
}
"
44234719,44251884,"package ciphers;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.util.Base64;

public class Java_AES_Cipher {

    private static String CIPHER_NAME = ""AES/CBC/PKCS5PADDING"";
    private static int CIPHER_KEY_LEN = 16; //128 bits

    /**
     * Encrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * 
     * @param key  - key to use should be 16 bytes long (128 bits)
     * @param iv - initialization vector
     * @param data - data to encrypt
     * @return encryptedData data in base64 encoding with iv attached at end after a :
     */
    public static String encrypt(String key, String iv, String data) {
        try {
            if (key.length() < Java_AES_Cipher.CIPHER_KEY_LEN) {
                int numPad = Java_AES_Cipher.CIPHER_KEY_LEN - key.length();

                for(int i = 0; i < numPad; i++){
                    key += ""0""; //0 pad to len 16 bytes
                }

            } else if (key.length() > Java_AES_Cipher.CIPHER_KEY_LEN) {
                key = key.substring(0, CIPHER_KEY_LEN); //truncate to 16 bytes
            }


            IvParameterSpec initVector = new IvParameterSpec(iv.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, initVector);

            byte[] encryptedData = cipher.doFinal((data.getBytes()));

            String base64_EncryptedData = Base64.getEncoder().encodeToString(encryptedData);
            String base64_IV = Base64.getEncoder().encodeToString(iv.getBytes(""UTF-8""));

            return base64_EncryptedData + "":"" + base64_IV;

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    /**
     * Decrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * @param key - key to use should be 16 bytes long (128 bits)
     * @param data - encrypted data with iv at the end separate by :
     * @return decrypted data string
     */

    public static String decrypt(String key, String data) {
        try {

            String[] parts = data.split("":"");

            IvParameterSpec iv = new IvParameterSpec(Base64.getDecoder().decode(parts[1]));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] decodedEncryptedData = Base64.getDecoder().decode(parts[0]);

            byte[] original = cipher.doFinal(decodedEncryptedData);

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

}
","
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Main {

    public static String encrypt(String key, String initVector, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string: "" + Base64.getEncoder().encodeToString(encrypted));

            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static String decrypt(String key, String initVector, String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] encryptedBytes = Base64.getDecoder().decode(encrypted);
            byte[] decrypted = cipher.doFinal(encryptedBytes);

            return new String(decrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    public static void main(String[] args) {
        String key = ""0123456789abcdef""; // Same as in PHP
        String initVector = ""fedcba9876543210""; // Same as in PHP

        System.out.println(decrypt(key, initVector, encrypt(key, initVector, ""Hello World!!!"")));
    }
}
"
43960761,43965528,"import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStore.Entry;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Calendar;
import java.util.Date;

import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

public class StoreKeyPair {
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(2048, new SecureRandom());
        KeyPair pair = generator.generateKeyPair();

        return pair;
    }

    public static Certificate selfSign(KeyPair keyPair, String subjectDN)
            throws OperatorCreationException, CertificateException, IOException
    {
        Provider bcProvider = new BouncyCastleProvider();
        Security.addProvider(bcProvider);

        long now = System.currentTimeMillis();
        Date startDate = new Date(now);

        X500Name dnName = new X500Name(subjectDN);

        // Using the current timestamp as the certificate serial number
        BigInteger certSerialNumber = new BigInteger(Long.toString(now));

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
        // 1 Yr validity
        calendar.add(Calendar.YEAR, 1);

        Date endDate = calendar.getTime();

        // Use appropriate signature algorithm based on your keyPair algorithm.
        String signatureAlgorithm = ""SHA256WithRSA"";

        SubjectPublicKeyInfo subjectPublicKeyInfo = SubjectPublicKeyInfo.getInstance(keyPair
                .getPublic().getEncoded());

        X509v3CertificateBuilder certificateBuilder = new X509v3CertificateBuilder(dnName,
                certSerialNumber, startDate, endDate, dnName, subjectPublicKeyInfo);

        ContentSigner contentSigner = new JcaContentSignerBuilder(signatureAlgorithm).setProvider(
                bcProvider).build(keyPair.getPrivate());

        X509CertificateHolder certificateHolder = certificateBuilder.build(contentSigner);

        Certificate selfSignedCert = new JcaX509CertificateConverter()
                .getCertificate(certificateHolder);

        return selfSignedCert;
    }

    public static void main(String[] args) throws Exception {
        KeyPair generatedKeyPair = generateKeyPair();

        String filename = ""test_gen_self_signed.pkcs12"";
        char[] password = ""test"".toCharArray();

        storeToPKCS12(filename, password, generatedKeyPair);

        KeyPair retrievedKeyPair = loadFromPKCS12(filename, password);

        // you can validate by generating a signature and verifying it or by
        // comparing the moduli by first casting to RSAPublicKey, e.g.:

        RSAPublicKey pubKey = (RSAPublicKey) generatedKeyPair.getPublic();
        RSAPrivateKey privKey = (RSAPrivateKey) retrievedKeyPair.getPrivate();
        System.out.println(pubKey.getModulus().equals(privKey.getModulus()));
    }

    private static KeyPair loadFromPKCS12(String filename, char[] password)
            throws KeyStoreException, NoSuchAlgorithmException, CertificateException,
            FileNotFoundException, IOException, UnrecoverableEntryException {
        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");

        try (FileInputStream fis = new FileInputStream(filename);) {
            pkcs12KeyStore.load(fis, password);
        }

        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(password);
        Entry entry = pkcs12KeyStore.getEntry(""owlstead"", param);
        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;
        PublicKey publicKey = privKeyEntry.getCertificate().getPublicKey();
        PrivateKey privateKey = privKeyEntry.getPrivateKey();
        return new KeyPair(publicKey, privateKey);
    }

    private static void storeToPKCS12(
            String filename, char[] password,
            KeyPair generatedKeyPair) throws KeyStoreException, IOException,
            NoSuchAlgorithmException, CertificateException, FileNotFoundException,
            OperatorCreationException {

        Certificate selfSignedCertificate = selfSign(generatedKeyPair, ""CN=owlstead"");

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        pkcs12KeyStore.load(null, null);

        KeyStore.Entry entry = new PrivateKeyEntry(generatedKeyPair.getPrivate(),
                new Certificate[] { selfSignedCertificate });
        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(password);

        pkcs12KeyStore.setEntry(""owlstead"", entry, param);

        try (FileOutputStream fos = new FileOutputStream(filename)) {
            pkcs12KeyStore.store(fos, password);
        }
    }
}
","
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.SecureRandom;

public class KeyPairDemo {
    private static KeyPair keyPair;

    public static void main(String[] args) {
        try {
            if (keyPair == null) {
                keyPair = generateKeyPair();
            }

            // Use the keyPair for encryption or decryption
            // ...
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(2048, new SecureRandom());
        KeyPair pair = generator.generateKeyPair();

        return pair;
    }
}
"
41934099,41934100,"import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import javax.net.ssl.SSLServerSocketFactory;

public class Ciphers
{
    public static void main(String[] args)
        throws Exception
    {
        SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();

        String[] defaultCiphers = ssf.getDefaultCipherSuites();
        String[] availableCiphers = ssf.getSupportedCipherSuites();

        TreeMap ciphers = new TreeMap();

        for(int i=0; i<availableCiphers.length; ++i )
            ciphers.put(availableCiphers[i], Boolean.FALSE);

        for(int i=0; i<defaultCiphers.length; ++i )
            ciphers.put(defaultCiphers[i], Boolean.TRUE);

        System.out.println(""Default\tCipher"");
        for(Iterator i = ciphers.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry cipher=(Map.Entry)i.next();

            if(Boolean.TRUE.equals(cipher.getValue()))
                System.out.print('*');
            else
                System.out.print(' ');

            System.out.print('\t');
            System.out.println(cipher.getKey());
        }
    }
}
","
import javax.crypto.Cipher;

public class Main {
    public static void main(String[] args) {
        try {
            // Install the Unlimited Strength Jurisdiction Policy Files
            // Replace ""path/to/jre"" with the actual path to your Java installation directory
            System.setProperty(""java.home"", ""path/to/jre"");

            // Check if the Unlimited Strength Jurisdiction Policy Files are installed
            int maxKeyLength = Cipher.getMaxAllowedKeyLength(""AES"");
            System.out.println(""Max Key Length: "" + maxKeyLength);

            // Enable Unlimited Strength Jurisdiction Policy Files if not already enabled
            if (maxKeyLength <= 128) {
                // Replace ""path/to/jdk"" with the actual path to your JDK installation directory
                System.setProperty(""java.home"", ""path/to/jdk"");
                System.out.println(""Unlimited Strength Jurisdiction Policy Files not installed. Enabling..."");

                // Install the Unlimited Strength Jurisdiction Policy Files
                Runtime.getRuntime().exec(""cp path/to/jdk/jre/lib/security/local_policy.jar path/to/jre/lib/security/"");
                Runtime.getRuntime().exec(""cp path/to/jdk/jre/lib/security/US_export_policy.jar path/to/jre/lib/security/"");
                System.out.println(""Unlimited Strength Jurisdiction Policy Files installed successfully."");

                // Restart the JVM to apply the changes
                System.exit(0);
            } else {
                System.out.println(""Unlimited Strength Jurisdiction Policy Files already installed."");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
"
41162523,41162646,"import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.jcajce.provider.asymmetric.rsa.DigestSignatureSpi.SHA1;

public class SHA1_test {

    public static String sha1(String s, String keyString)
            throws UnsupportedEncodingException, NoSuchAlgorithmException,
            InvalidKeyException {

        SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""),
                ""HmacSHA1"");
        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(key);

        byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));

        return new String(Base64.encodeBase64(bytes));

    }

    public static void main(String[] args) throws InvalidKeyException,
            UnsupportedEncodingException, NoSuchAlgorithmException {
        Boolean validate = false;
        String code = sha1(""admin"", ""123456"");
        String your_user_inputString = ""testpassword"";

        if (code.equals(sha1(your_user_inputString, ""123456""))) {
            System.out.println(""Correct"");
        } else {
            System.out.println(""Bad password"");
        }

    }

}
","
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        String pass = ""f6ce584e7b4ff5253eed4a2ea2b44247"";

        Scanner scanner = new Scanner(System.in);
        System.out.print(""Enter password: "");
        String userInput = scanner.nextLine();

        String hashedInput = sha1Hash(userInput);
        
        if (pass.equals(hashedInput)) {
            System.out.println(""Success"");
        } else {
            System.out.println(""Password incorrect"");
        }
    }
    
    public static String sha1Hash(String input) {
        try {
            // Create a SHA1 MessageDigest instance
            MessageDigest md = MessageDigest.getInstance(""SHA1"");
            
            // Convert the input string to bytes and compute the hash
            byte[] hashBytes = md.digest(input.getBytes());
            
            // Convert the hash bytes to hexadecimal representation
            StringBuilder sb = new StringBuilder();
            for (byte b : hashBytes) {
                sb.append(String.format(""%02x"", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            System.out.println(""Error: "" + e.getMessage());
            return null;
        }
    }
}
"
28042594,47128415,"/* verifyRSAsha256.java */
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;
import javax.xml.bind.DatatypeConverter;

/*
Compile:
clear && javac verifyRSAsha256.java && java verifyRSAsha256

Create private key:
openssl genrsa -des3 -out encrypted.pem 2048 && openssl rsa -in encrypted.pem -out private.pem -outform PEM && openssl rsa -in private.pem -pubout > public.pem

Create signature:
/bin/echo -n ""some text that you want to be trusted"" > data.txt
openssl dgst -sha256 -sign private.pem data.txt > signature.tmp
base64 signature.tmp

Verify signature:
openssl dgst -sha256 -verify public.pem -signature signature.tmp data.txt
*/

public class verifyRSAsha256 {

    public static void main(String args[]){
        String publicKey = 
        //  ""-----BEGIN PUBLIC KEY-----""+
            ""MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwns0JWYgEshlpLYsZQFc""+
            ""d5iVSqIHDO0zISLlO1aK4bbbosSvRE81+inKrG5mlnkIrv0+mJ/qTLY1RdBAVAe4""+
            ""GPLTpHmLJhEtq7stydm2cCTEPRwfJNjoHqATDHEm1KLVGA8k0hztfMr8fLChE3/K""+
            ""n2MHxzs7qhMLyBdPqbVC9RNja3i+Nl814xPTSXJ50zdJMLC56VtIU0xjqNjXN8iQ""+
            ""pLZ2EfcP55nZ/venD01yxfsUn4sQLFTAlXqygA10fdDv9y0eZvgaGGSb4MuPT7yD""+
            ""BfgNEU3tl4nRdSzPNkCkCmkuaa/pqZ5uw+G0HBwaQlHDwsnIcwE/xo6aHpt4xF4W""+
            ""/QIDAQAB"";
        //  ""-----END PUBLIC KEY-----"";

        byte[] signature, data;

        // the signature is a binary data and I encoded it with base64, so the signature must be decoded from base64 to binary again
        signature = DatatypeConverter.parseBase64Binary(""Yy9CdQDfdYWwZkSu2SZgoFABHk5Bd3tzYvX73QR+GDCWpUsWrO5CXRF+j3dBz+bq1SRQ+1c1hdez5mMeE1587s4Mos8EsT1sqNemu4l4535P+jYicwG1m2MAesquAHhIIAyY9iGID576ehX0/34rCCeGuVZablpL+2ki6cEwxPVlH7xtWNIc1AdxivHjkWorkWC1LrbfcNdbZhUrNuz7DZsxHP2sr+2TQdD4L9CA2bgpj6HeQt+MTfCf2PKSdVoLFdwnM8638jHL6MVcEJxeIow/YUDZGEAyR743RdRk4CGU1bJ7er9M1Q4hFfYWGOBsLBok2XXUJcchLgWET1eKdA=="");

        // the signature length have to be 256 bytes
        System.out.print(""Signature length 256 = "");
        System.out.println(signature.length);

        // the data used the generate the signature
        data = ""some text that you want to be trusted"".getBytes();

        // verify if signature is ok
        try {System.out.println(verify(data,signature,publicKey));}catch(GeneralSecurityException e){e.printStackTrace();}

        // if any byte of data changes (ex: change last byte from d to D)
        data = ""some text that you want to be trusteD"".getBytes();

        // the signature doesn't math and method verify will fail
        try {System.out.println(verify(data,signature,publicKey));}catch(GeneralSecurityException e){e.printStackTrace();}

    }

    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }
}
","
import java.io.DataOutputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Enumeration;

public class SignatureExample {
    public static void main(String[] args) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""Windows-MY"");
        keyStore.load(null, null);
        Enumeration<String> en = keyStore.aliases();
        
        while (en.hasMoreElements()) {
            String alias = en.nextElement();
            
            X509Certificate c = (X509Certificate) keyStore.getCertificate(alias);
            PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, null);
            PublicKey publicKey = c.getPublicKey();
            
            String data = ""Monika"";
            byte[] content = data.getBytes();
            
            // Signature generation
            Signature signature = Signature.getInstance(""SHA256withRSA"");
            signature.initSign(privateKey);
            signature.update(content);
            byte[] signatureBytes = signature.sign();
            System.out.println(""Generated signature: "" + bytesToHex(signatureBytes));
            
            // Signature verification
            Signature signature1 = Signature.getInstance(""SHA256withRSA"");
            signature1.initVerify(publicKey);
            signature1.update(content);
            boolean verifies = signature1.verify(signatureBytes);
            System.out.println(""Signature verifies: "" + verifies);
        }
    }
    
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format(""%02x"", b));
        }
        return sb.toString();
    }
}
"
46988680,46988906,"

    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.InvalidAlgorithmParameterException;
    import java.security.spec.AlgorithmParameterSpec;

    public class AES256Cipher {

        public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                    NoSuchAlgorithmException,
                    NoSuchPaddingException,
                    InvalidKeyException,
                    InvalidAlgorithmParameterException,
                    IllegalBlockSizeException,
                    BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = null;
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);
        }

        public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                NoSuchAlgorithmException,
                NoSuchPaddingException,
                InvalidKeyException,
                InvalidAlgorithmParameterException,
                IllegalBlockSizeException,
                BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);
        }
    }

","
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AESUtil {
    private static final String AES_ALGORITHM = ""AES"";

    public static byte[] encrypt(byte[] data, byte[] key) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        return cipher.doFinal(data);
    }

    public static byte[] decrypt(byte[] encryptedData, byte[] key) throws Exception {
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, AES_ALGORITHM);
        Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        return cipher.doFinal(encryptedData);
    }

    public static void main(String[] args) throws Exception {
        byte[] key = ""YourAESKey"".getBytes(); // Replace with your own AES key
        
        String plainText = ""Hello AES-256!"";
        byte[] encryptedData = encrypt(plainText.getBytes(), key);
        System.out.println(""Encrypted data: "" + new String(encryptedData));

        byte[] decryptedData = decrypt(encryptedData, key);
        System.out.println(""Decrypted data: "" + new String(decryptedData));
    }
}
"
46984264,46984366,"import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}","
import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

public class Encryptor {
    private static SecretKeySpec secretKey;
    private static byte[] key;

    public static void setKey(String myKey) {
        MessageDigest sha = null;
        try {
            key = myKey.getBytes(""UTF-8"");
            sha = MessageDigest.getInstance(""SHA-1"");
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16);
            secretKey = new SecretKeySpec(key, ""AES"");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static String encrypt(String strToEncrypt, String secret) {
        try {
            setKey(secret);
            Cipher cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(""UTF-8"")));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {
        String originalString = ""This is the data to be encrypted."";
        String secretKey = ""MySecretKey""; // Replace with your own secret key

        String encryptedString = encrypt(originalString, secretKey);
        System.out.println(""Encrypted String: "" + encryptedString);
    }
}
"
