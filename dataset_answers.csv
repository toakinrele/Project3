question_id,answer_id,body
875467,876785,"<p>While not recommended, you can also disable SSL cert validation altogether, using the following code that came from <a href=""https://web.archive.org/web/20061217061841/http://www.exampledepot.com/egs/javax.net.ssl/TrustAll.html"" rel=""nofollow noreferrer"">The Java Developers Almanac</a>:</p>
<blockquote>
<pre><code>import javax.net.ssl.*; import java.security.SecureRandom; import
java.security.cert.X509Certificate;

public class SSLTool {

  public static void disableCertificateValidation() {
    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[] { 
      new X509TrustManager() {
        public X509Certificate[] getAcceptedIssuers() { 
          return new X509Certificate[0]; 
        }
        public void checkClientTrusted(X509Certificate[] certs, String authType) {}
        public void checkServerTrusted(X509Certificate[] certs, String authType) {}
    }};

    // Ignore differences between given hostname and certificate hostname
    HostnameVerifier hv = new HostnameVerifier() {
      public boolean verify(String hostname, SSLSession session) { return true; }
    };

    // Install the all-trusting trust manager
    try {
      SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;);
      sc.init(null, trustAllCerts, new SecureRandom());
      HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
      HttpsURLConnection.setDefaultHostnameVerifier(hv);
    } catch (Exception e) {}   } }
</code></pre>
</blockquote>
"
1638275,1640099,"<p>Consider the following Java class. Borrowing from this code: <a href=""https://web.archive.org/web/20061217061841/http://www.exampledepot.com/egs/javax.net.ssl/TrustAll.html"" rel=""nofollow noreferrer"">Disabling Certificate Validation in an HTTPS Connection</a></p>
<h3>C:\MATLAB\MyJavaClasses\com\stackoverflow\Downloader.java</h3>
<pre><code>package com.stackoverflow;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.cert.X509Certificate;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import javax.net.ssl.HostnameVerifier;

public class Downloader {
    public static String getData(String address) throws Exception {
        // Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[] {
            new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
                public void checkClientTrusted(X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(X509Certificate[] certs, String authType) {
                }
            }
        };

        // Create a host name verifier that always passes
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };

        // Install the all-trusting trust manager
        SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;);
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        // open connection
        URL page = new URL(address);
        HttpURLConnection conn = (HttpURLConnection) page.openConnection();
        BufferedReader buff = new BufferedReader(new InputStreamReader(conn.getInputStream()));

        // read text
        String line;
        StringBuffer text = new StringBuffer();
        while ( (line = buff.readLine()) != null ) {
            //System.out.println(line);
            text.append(line + &quot;\n&quot;);
        }
        buff.close();

        return text.toString();
    }

    public static void main(String[] argv) throws Exception {
        String str = getData(&quot;https://expired.badssl.com/&quot;);
        System.out.println(str);
    }
}
</code></pre>
<h3>MATLAB</h3>
<p>First we compile the Java class (we must use a JDK version compatible with MATLAB):</p>
<pre><code>&gt;&gt; version -java
&gt;&gt; system('javac C:\MATLAB\MyJavaClasses\com\stackoverflow\Downloader.java');
</code></pre>
<p>Next we instantiate and use it MATLAB as:</p>
<pre><code>javaaddpath('C:\MATLAB\MyJavaClasses')
dl = com.stackoverflow.Downloader;
str = char(dl.getData('https://expired.badssl.com/'));
web(['text://' str], '-new')
</code></pre>
<p>Here are a few URLs with bad SSL certificates to test:</p>
<pre><code>urls = {
    'https://expired.badssl.com/'       % expired
    'https://wrong.host.badssl.com/'    % wrong host
    'https://self-signed.badssl.com/'   % self-signed
    'https://revoked.grc.com/'          % revoked
};
</code></pre>
<hr />
<p><strong>UPDATE:</strong> I should mention that starting with R2014b, MATLAB has a new function <a href=""http://www.mathworks.com/help/matlab/ref/webread.html"" rel=""nofollow noreferrer""><code>webread</code></a> that supersedes <a href=""http://www.mathworks.com/help/matlab/ref/urlread.html"" rel=""nofollow noreferrer""><code>urlread</code></a>.</p>
"
3508050,3508175,"<p>There's an example that shows how to get a Set of the root certificates and iterate through them called <a href=""http://www.java2s.com/Tutorial/Java/0490__Security/ListingtheMostTrustedCertificateAuthoritiesCAinaKeyStore.htm"" rel=""noreferrer"">Listing the Most-Trusted Certificate Authorities (CA) in a Key Store</a>.  Here's a slightly modified version that prints out each certificate (tested on Windows Vista).</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.CertificateException;
import java.security.cert.PKIXParameters;
import java.security.cert.TrustAnchor;
import java.security.cert.X509Certificate;
import java.util.Iterator;


public class Main {

    public static void main(String[] args) {
        try {
            // Load the JDK's cacerts keystore file
            String filename = System.getProperty(""java.home"") + ""/lib/security/cacerts"".replace('/', File.separatorChar);
            FileInputStream is = new FileInputStream(filename);
            KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
            String password = ""changeit"";
            keystore.load(is, password.toCharArray());

            // This class retrieves the most-trusted CAs from the keystore
            PKIXParameters params = new PKIXParameters(keystore);

            // Get the set of trust anchors, which contain the most-trusted CA certificates
            Iterator it = params.getTrustAnchors().iterator();
            while( it.hasNext() ) {
                TrustAnchor ta = (TrustAnchor)it.next();
                // Get certificate
                X509Certificate cert = ta.getTrustedCert();
                System.out.println(cert);
            }
        } catch (CertificateException e) {
        } catch (KeyStoreException e) {
        } catch (NoSuchAlgorithmException e) {
        } catch (InvalidAlgorithmParameterException e) {
        } catch (IOException e) {
        } 
    }
}
</code></pre>
"
304268,304275,"<p>There's an example at <a href=""http://www.rgagnon.com/javadetails/java-0416.html"" rel=""noreferrer"">Real's Java-How-to</a> using the <a href=""http://docs.oracle.com/javase/6/docs/api/java/security/MessageDigest.html"" rel=""noreferrer"">MessageDigest</a> class.</p>

<p>Check that page for examples using CRC32 and SHA-1 as well.</p>

<pre><code>import java.io.*;
import java.security.MessageDigest;

public class MD5Checksum {

   public static byte[] createChecksum(String filename) throws Exception {
       InputStream fis =  new FileInputStream(filename);

       byte[] buffer = new byte[1024];
       MessageDigest complete = MessageDigest.getInstance(""MD5"");
       int numRead;

       do {
           numRead = fis.read(buffer);
           if (numRead &gt; 0) {
               complete.update(buffer, 0, numRead);
           }
       } while (numRead != -1);

       fis.close();
       return complete.digest();
   }

   // see this How-to for a faster way to convert
   // a byte array to a HEX string
   public static String getMD5Checksum(String filename) throws Exception {
       byte[] b = createChecksum(filename);
       String result = """";

       for (int i=0; i &lt; b.length; i++) {
           result += Integer.toString( ( b[i] &amp; 0xff ) + 0x100, 16).substring( 1 );
       }
       return result;
   }

   public static void main(String args[]) {
       try {
           System.out.println(getMD5Checksum(""apache-tomcat-5.5.17.exe""));
           // output :
           //  0bb2827c5eacf570b6064e24e0e6653b
           // ref :
           //  http://www.apache.org/dist/
           //          tomcat/tomcat-5/v5.5.17/bin
           //              /apache-tomcat-5.5.17.exe.MD5
           //  0bb2827c5eacf570b6064e24e0e6653b *apache-tomcat-5.5.17.exe
       }
       catch (Exception e) {
           e.printStackTrace();
       }
   }
}
</code></pre>
"
4687615,4687706,"<p>Reading quickly through the source it seems that you're not far off. The following link should help (I did something similar but for FTP). For a file send from server to client, you start off with a file instance and an array of bytes. You then read the File into the byte array and write the byte array to the OutputStream which corresponds with the InputStream on the client's side.</p>

<p><a href=""http://www.rgagnon.com/javadetails/java-0542.html"" rel=""nofollow noreferrer"">http://www.rgagnon.com/javadetails/java-0542.html</a></p>

<p>Edit: Here's a working ultra-minimalistic file sender and receiver. Make sure you understand what the code is doing on both sides.</p>

<pre><code>package filesendtest;

import java.io.*;
import java.net.*;

class TCPServer {

    private final static String fileToSend = ""C:\\test1.pdf"";

    public static void main(String args[]) {

        while (true) {
            ServerSocket welcomeSocket = null;
            Socket connectionSocket = null;
            BufferedOutputStream outToClient = null;

            try {
                welcomeSocket = new ServerSocket(3248);
                connectionSocket = welcomeSocket.accept();
                outToClient = new BufferedOutputStream(connectionSocket.getOutputStream());
            } catch (IOException ex) {
                // Do exception handling
            }

            if (outToClient != null) {
                File myFile = new File( fileToSend );
                byte[] mybytearray = new byte[(int) myFile.length()];

                FileInputStream fis = null;

                try {
                    fis = new FileInputStream(myFile);
                } catch (FileNotFoundException ex) {
                    // Do exception handling
                }
                BufferedInputStream bis = new BufferedInputStream(fis);

                try {
                    bis.read(mybytearray, 0, mybytearray.length);
                    outToClient.write(mybytearray, 0, mybytearray.length);
                    outToClient.flush();
                    outToClient.close();
                    connectionSocket.close();

                    // File sent, exit the main method
                    return;
                } catch (IOException ex) {
                    // Do exception handling
                }
            }
        }
    }
}
</code></pre>

<hr>

<pre><code>package filesendtest;

import java.io.*;
import java.io.ByteArrayOutputStream;
import java.net.*;

class TCPClient {

    private final static String serverIP = ""127.0.0.1"";
    private final static int serverPort = 3248;
    private final static String fileOutput = ""C:\\testout.pdf"";

    public static void main(String args[]) {
        byte[] aByte = new byte[1];
        int bytesRead;

        Socket clientSocket = null;
        InputStream is = null;

        try {
            clientSocket = new Socket( serverIP , serverPort );
            is = clientSocket.getInputStream();
        } catch (IOException ex) {
            // Do exception handling
        }

        ByteArrayOutputStream baos = new ByteArrayOutputStream();

        if (is != null) {

            FileOutputStream fos = null;
            BufferedOutputStream bos = null;
            try {
                fos = new FileOutputStream( fileOutput );
                bos = new BufferedOutputStream(fos);
                bytesRead = is.read(aByte, 0, aByte.length);

                do {
                        baos.write(aByte);
                        bytesRead = is.read(aByte);
                } while (bytesRead != -1);

                bos.write(baos.toByteArray());
                bos.flush();
                bos.close();
                clientSocket.close();
            } catch (IOException ex) {
                // Do exception handling
            }
        }
    }
}
</code></pre>

<p><strong>Related</strong></p>

<p><a href=""https://stackoverflow.com/questions/664389/byte-array-of-unknown-length-in-java"">Byte array of unknown length in java</a></p>

<p>Edit: The following could be used to fingerprint small files before and after transfer (use SHA if you feel it's necessary):</p>

<pre><code>public static String md5String(File file) {
    try {
        InputStream fin = new FileInputStream(file);
        java.security.MessageDigest md5er = MessageDigest.getInstance(""MD5"");
        byte[] buffer = new byte[1024];
        int read;
        do {
            read = fin.read(buffer);
            if (read &gt; 0) {
                md5er.update(buffer, 0, read);
            }
        } while (read != -1);
        fin.close();
        byte[] digest = md5er.digest();
        if (digest == null) {
            return null;
        }
        String strDigest = ""0x"";
        for (int i = 0; i &lt; digest.length; i++) {
            strDigest += Integer.toString((digest[i] &amp; 0xff)
                    + 0x100, 16).substring(1).toUpperCase();
        }
        return strDigest;
    } catch (Exception e) {
        return null;
    }
}
</code></pre>
"
20227,11367849,"<p>Here's a very simply static encrypt/decrypt class biased on the Bouncy Castle no padding example by Jose Luis Montes de Oca.  This one is using ""DESede/ECB/PKCS7Padding"" so I don't have to bother manually padding.</p>

<pre><code>
    package com.zenimax.encryption;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.NoSuchProviderException;
    import java.security.Security;
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.spec.SecretKeySpec;
    import org.bouncycastle.jce.provider.BouncyCastleProvider;

    /**
     * 
     * @author Matthew H. Wagner
     */
    public class TripleDesBouncyCastle {
        private static String TRIPLE_DES_TRANSFORMATION = ""DESede/ECB/PKCS7Padding"";
        private static String ALGORITHM = ""DESede"";
        private static String BOUNCY_CASTLE_PROVIDER = ""BC"";

        private static void init()
        {
            Security.addProvider(new BouncyCastleProvider());
        }

        public static byte[] encode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher encrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            encrypter.init(Cipher.ENCRYPT_MODE, keySpec);
            return encrypter.doFinal(input);
        }

        public static byte[] decode(byte[] input, byte[] key)
                throws IllegalBlockSizeException, BadPaddingException,
                NoSuchAlgorithmException, NoSuchProviderException,
                NoSuchPaddingException, InvalidKeyException {
            init();
            SecretKey keySpec = new SecretKeySpec(key, ALGORITHM);
            Cipher decrypter = Cipher.getInstance(TRIPLE_DES_TRANSFORMATION,
                    BOUNCY_CASTLE_PROVIDER);
            decrypter.init(Cipher.DECRYPT_MODE, keySpec);
            return decrypter.doFinal(input);
        }
    }
</code>
</pre>
"
6788018,11392104,"<pre><code>import java.security.AlgorithmParameters;
import java.security.SecureRandom;
import java.security.spec.KeySpec;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

class SecurityUtils {

  private static final byte[] salt = { (byte) 0xA4, (byte) 0x0B, (byte) 0xC8,
      (byte) 0x34, (byte) 0xD6, (byte) 0x95, (byte) 0xF3, (byte) 0x13 };

  private static int BLOCKS = 128;

  public static byte[] encryptAES(String seed, String cleartext)
      throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    return cipher.doFinal(cleartext.getBytes(""UTF8""));
  }

  public static byte[] decryptAES(String seed, byte[] data) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes(""UTF8""));
    SecretKeySpec skeySpec = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    return cipher.doFinal(data);
  }

  private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    sr.setSeed(seed);
    kgen.init(BLOCKS, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
  }

  private static byte[] pad(byte[] seed) {
    byte[] nseed = new byte[BLOCKS / 8];
    for (int i = 0; i &lt; BLOCKS / 8; i++)
      nseed[i] = 0;
    for (int i = 0; i &lt; seed.length; i++)
      nseed[i] = seed[i];

    return nseed;
  }

  public static byte[] encryptPBE(String password, String cleartext)
      throws Exception {
    SecretKeyFactory factory = SecretKeyFactory
        .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
    return cipher.doFinal(cleartext.getBytes(""UTF-8""));
  }

  public static String decryptPBE(SecretKey secret, String ciphertext,
      byte[] iv) throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
    return new String(cipher.doFinal(ciphertext.getBytes()), ""UTF-8"");
  }

}
</code></pre>
"
415953,25251120,"<p>I have a Class (Hash) to convert plain text in hash in formats: md5 or sha1, simillar that php functions (<a href=""http://php.net/manual/en/function.md5.php"">md5</a>, <a href=""http://php.net/manual/en/function.sha1.php"">sha1</a>):</p>

<pre><code>public class Hash {
    /**
     * 
     * @param txt, text in plain format
     * @param hashType MD5 OR SHA1
     * @return hash in hashType 
     */
    public static String getHash(String txt, String hashType) {
        try {
                    java.security.MessageDigest md = java.security.MessageDigest.getInstance(hashType);
                    byte[] array = md.digest(txt.getBytes());
                    StringBuffer sb = new StringBuffer();
                    for (int i = 0; i &lt; array.length; ++i) {
                        sb.append(Integer.toHexString((array[i] &amp; 0xFF) | 0x100).substring(1,3));
                 }
                    return sb.toString();
            } catch (java.security.NoSuchAlgorithmException e) {
                //error action
            }
            return null;
    }

    public static String md5(String txt) {
        return Hash.getHash(txt, ""MD5"");
    }

    public static String sha1(String txt) {
        return Hash.getHash(txt, ""SHA1"");
    }
}
</code></pre>

<h2>Testing with JUnit and PHP</h2>

<h3>PHP Script:</h3>

<pre><code>&lt;?php

echo 'MD5 :' . md5('Hello World') . ""\n"";
echo 'SHA1:' . sha1('Hello World') . ""\n"";
</code></pre>

<h3>Output PHP script:</h3>

<pre><code>MD5 :b10a8db164e0754105b7a99be72e3fe5
SHA1:0a4d55a8d778e5022fab701977c5d840bbc486d0
</code></pre>

<h3>Using example and Testing with JUnit:</h3>

<pre><code>    public class HashTest {

    @Test
    public void test() {
        String txt = ""Hello World"";
        assertEquals(""b10a8db164e0754105b7a99be72e3fe5"", Hash.md5(txt));
        assertEquals(""0a4d55a8d778e5022fab701977c5d840bbc486d0"", Hash.sha1(txt));
    }

}
</code></pre>

<h3>Code in GitHub</h3>

<blockquote>
  <p><a href=""https://github.com/fitorec/java-hashes"">https://github.com/fitorec/java-hashes</a></p>
</blockquote>
"
11624571,14256570,"<p>Send e-mail in Android using the JavaMail API using Gmail authentication</p>

<p><strong>Steps to create a simple Project:</strong></p>

<p>MailSenderActivity.java</p>

<pre><code>YOUR PACKAGE;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.Button;

public class MailSenderActivity extends Activity {

    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        final Button send = (Button) this.findViewById(R.id.send);
        send.setOnClickListener(new View.OnClickListener() {

            public void onClick(View v) {
                // TODO Auto-generated method stub

                try {   
                    GMailSender sender = new GMailSender(""username@gmail.com"", ""password"");
                    sender.sendMail(""This is Subject"",   
                            ""This is Body"",   
                            ""user@gmail.com"",   
                            ""user@yahoo.com"");   
                } catch (Exception e) {   
                    Log.e(""SendMail"", e.getMessage(), e);   
                } 

            }
        });

    }
}
</code></pre>

<p>GmailSender.java</p>

<pre><code>YOUR PACKAGE;

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeMessage;   
import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GMailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"";   
    private String user;   
    private String password;   
    private Session session;   

    static {   
        Security.addProvider(new com.provider.JSSEProvider());   
    }  

    public GMailSender(String user, String password) {   
        this.user = user;   
        this.password = password;   

        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   
        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",   
                ""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);   
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{
        MimeMessage message = new MimeMessage(session);   
        DataHandler handler = new DataHandler(new ByteArrayDataSource(body.getBytes(), ""text/plain""));   
        message.setSender(new InternetAddress(sender));   
        message.setSubject(subject);   
        message.setDataHandler(handler);   
        if (recipients.indexOf(',') &gt; 0)   
            message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(recipients));   
        else  
            message.setRecipient(Message.RecipientType.TO, new InternetAddress(recipients));   
        Transport.send(message);   
        }catch(Exception e){

        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  
</code></pre>

<p>JSSE Provider </p>

<pre><code>/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the ""License""); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an ""AS IS"" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

/**
 * @author Alexander Y. Kleymenov
 * @version $Revision$
 */


import java.security.AccessController;
import java.security.Provider;

public final class JSSEProvider extends Provider {

    public JSSEProvider() {
        super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
        AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
            public Void run() {
                put(""SSLContext.TLS"",
                        ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                put(""KeyManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                put(""TrustManagerFactory.X509"",
                        ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                return null;
            }
        });
    }
}
</code></pre>

<p>ADD 3 jars found in the following link to your Android Project </p>

<ul>
<li><a href=""http://javamail-android.googlecode.com/files/mail.jar"" rel=""nofollow noreferrer"">mail.jar</a></li>
<li><a href=""http://javamail-android.googlecode.com/files/activation.jar"" rel=""nofollow noreferrer"">activation.jar</a></li>
<li><a href=""http://javamail-android.googlecode.com/files/additionnal.jar"" rel=""nofollow noreferrer"">additionnal.jar</a></li>
</ul>

<p><a href=""https://stackoverflow.com/a/6859020/28557"">Click here - How to add External Jars</a></p>

<p>Run the project and check your recipient mail account for the mail.
Cheers!!</p>

<p>Hope this helps</p>

<p>And don't forget that you cannot do network operation from the any UI activity in android.
So follow <a href=""https://stackoverflow.com/a/6343299"">this answer</a> if you have any network issue:</p>

<p>Jar files : <a href=""https://code.google.com/p/javamail-android/"" rel=""nofollow noreferrer"">https://code.google.com/p/javamail-android/</a></p>
"
13525279,13525299,"<p>IM using the following class for my Android App and it works like a charm:</p>

<pre><code>import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class Encryption {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }


    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i &lt; buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
    }


}
</code></pre>

<p><strong>Usage:</strong></p>

<pre><code>String seed=""yourseed"";
String EncryptedPass= Encryption.encrypt(seed,Value);       
return Encryption.decrypt(seed,EncryptedPass);
</code></pre>
"
13488155,13488262,"<p>Have a read on this link:</p>

<ul>
<li>Using AES with Java Technology (Could not use the link as normally due to the domain being a number): <code>http://192.9.162.55/developer/technicalArticles/Security/AES/AES_v1.html</code></li>
</ul>

<p>By default you can use up to AES 128bit.</p>

<p>In order to use 256 bit AES keys, you must download and install ""Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files"" from <a href=""http://java.sun.com/javase/downloads/index.jsp"" rel=""nofollow"">here</a>. </p>

<p>Here is a simple example which encrypts an decrypts a String message in java using AES:</p>

<pre><code> import java.security.*;
   import javax.crypto.*;
   import javax.crypto.spec.*;
   import java.io.*;

   /**
   * This program generates a AES key, retrieves its raw bytes, and
   * then reinstantiates a AES key from the key bytes.
   * The reinstantiated key is used to initialize a AES cipher for
   * encryption and decryption.
   */

   public class AES {

     /**
     * Turns array of bytes into string
     *
     * @param buf   Array of bytes to convert to hex string
     * @return  Generated hex string
     */
     public static String asHex (byte buf[]) {
      StringBuffer strbuf = new StringBuffer(buf.length * 2);
      int i;

      for (i = 0; i &lt; buf.length; i++) {
       if (((int) buf[i] &amp; 0xff) &lt; 0x10)
        strbuf.append(""0"");

       strbuf.append(Long.toString((int) buf[i] &amp; 0xff, 16));
      }

      return strbuf.toString();
     }

     public static void main(String[] args) throws Exception {

       String message=""This is just an example"";

       // Get the KeyGenerator

       KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
       kgen.init(128); // 192 and 256 bits may not be available


       // Generate the secret key specs.
       SecretKey skey = kgen.generateKey();
       byte[] raw = skey.getEncoded();

       SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");


       // Instantiate the cipher

       Cipher cipher = Cipher.getInstance(""AES"");

       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

       byte[] encrypted =
         cipher.doFinal((args.length == 0 ?
          ""This is just an example"" : args[0]).getBytes());
       System.out.println(""encrypted string: "" + asHex(encrypted));

       cipher.init(Cipher.DECRYPT_MODE, skeySpec);
       byte[] original =
         cipher.doFinal(encrypted);
       String originalString = new String(original);
       System.out.println(""Original string: "" +
         originalString + "" "" + asHex(original));
     }
   }
</code></pre>

<p>The above code will have to be modified in such a way that you read the encrypted files into a <code>StringBuffer</code>/byte array etc, un-encrypt them (in memory only) do the work needed then re-encrypt <code>StringBuffer</code>/data/bytes and write it to file.</p>

<p>Another great Cryptograpic API is:</p>

<ul>
<li><a href=""http://www.bouncycastle.org/"" rel=""nofollow"">Bouncy Castle</a></li>
</ul>

<p>There are many examples that can be found for Bouncy Castle API too:</p>

<ul>
<li><a href=""http://www.itcsolutions.eu/2011/08/24/how-to-encrypt-decrypt-files-in-java-with-aes-in-cbc-mode-using-bouncy-castle-api-and-netbeans-or-eclipse/"" rel=""nofollow"">How to encrypt/decrypt files in Java with AES in CBC mode using Bouncy Castle API and NetBeans or Eclipse</a> </li>
</ul>
"
11683946,12475859,"<p>Try as below example; Actually, It just need to used StringTokenizer. Firstly you have to token your target string. After that, encrypt the token string.  </p>

<pre><code>import java.util.StringTokenizer;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


public class AES {
    public static String asHex(byte[] buf) {
        StringBuffer strbuf = new StringBuffer(buf.length * 2);
        int i;

        for (i = 0; i &lt; buf.length; i++) {
            if (((int)buf[i] &amp; 0xff) &lt; 0x10)
                strbuf.append(""0"");
            strbuf.append(Long.toString((int)buf[i] &amp; 0xff, 16));
        }

        return strbuf.toString();
    }

    public static void main(String[] args) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        kgen.init(128); // 192 and 256 bits may not be available
        // Generate the secret key specs.
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

        String target = ""This is just an example"";
        StringTokenizer token = new StringTokenizer(target);
        while(token.hasMoreTokens()) {
            String temp = token.nextToken();
            byte[] encrypted = cipher.doFinal((args.length == 0 ?  temp : args[0]).getBytes());
            System.out.println(asHex(encrypted) + "" "");
        }
    }
}
</code></pre>

<p>Output :</p>

<pre><code>    d40186eab04d10e299801e7ad9046c06 6a71265c768a3b6e1f1a8f891d621c1d 735e3f54c8ad7242466e3517e8dd1659 5216643345db0f0c12f65c66c5363be3 b823355d5bb31bf092df98e18fa8001c
</code></pre>
"
3208160,11102291,"<p>A minor thing but if you are looking for an equivalent to hmac(key,message) then by default the python library will use the MD5 algorithm, so you need to use the HmacMD5 algorithm in Java.</p>

<p>I mention this because I had this exact problem and found this answer which was helpful, but I missed the part where a digest method was passed in to hmac() and thus went down a rabbit hole. Hopefully this answer will prevent others doing the same in the future.</p>

<p>e.g. in Python REPL</p>

<pre><code>&gt;&gt;&gt; import hmac
&gt;&gt;&gt; hmac.new(""keyValueGoesHere"", ""secretMessageToHash"").hexdigest()
'1a7bb3687962c9e26b2d4c2b833b2bf2'
</code></pre>

<p>This is equivalent to the Java method:</p>

<pre><code>import org.apache.commons.codec.binary.Hex;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

public class HashingUtility {
    public static String HMAC_MD5_encode(String key, String message) throws Exception {

        SecretKeySpec keySpec = new SecretKeySpec(
                key.getBytes(),
                ""HmacMD5"");

        Mac mac = Mac.getInstance(""HmacMD5"");
        mac.init(keySpec);
        byte[] rawHmac = mac.doFinal(message.getBytes());

        return Hex.encodeHexString(rawHmac);
    }
}
</code></pre>

<p>Note that in my example I'm doing the equivalent of .hexdigest()</p>
"
10357630,10358882,"<p>Here is a Simple Crypto utility class that might be of help to you.  Its based on the code written by ferenc.hechler posted at the following url :
<a href=""http://www.androidsnippets.com/encryptdecrypt-strings"" rel=""nofollow"">http://www.androidsnippets.com/encryptdecrypt-strings</a>
I have made some changes to it to fit my needs.</p>

<pre><code>import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class SimpleCrypto {

    private static final int KEY_SIZE = 128;

    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = encrypt(rawKey, cleartext.getBytes());
        return bin2hex(result);
    }

    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] enc = toByte(encrypted);
        final byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static String decrypt(String seed, byte[] encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = decrypt(rawKey, encrypted);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws NoSuchAlgorithmException {
        final KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        final SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(KEY_SIZE, sr); // 192 and 256 bits may not be available
        final SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }

    public static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        final byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    public static byte[] decrypt(byte[] raw, byte[] encrypted) throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        final SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        final Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        final byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return bin2hex(txt.getBytes());
    }

    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        final int len = hexString.length() / 2;
        final byte[] result = new byte[len];
        for (int i = 0; i &lt; len; i++) {
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        }
        return result;
    }

    public static byte[] getHash(String str) {
        MessageDigest digest = null;
        try {
            digest = MessageDigest.getInstance(""SHA-256"");
        } catch (NoSuchAlgorithmException ex) {
            ex.printStackTrace();
        }
        digest.reset();
        return digest.digest(str.getBytes());
    }

    static String bin2hex(byte[] data) {
        return String.format(""%0"" + (data.length * 2) + ""X"", new BigInteger(1, data));
    }
}
</code></pre>

<p>Here is how you would use it to decrypt something :</p>

<pre><code>    final String ssid = ""MY_WIFI_SSID"";
    final String encWifiKey = ""myEncryptedWifiKeyString"";

    String wifiKey = """";
    try {
        wifiKey = new String(SimpleCrypto.decrypt(SimpleCrypto.getHash(ssid), Base64.decode(encWifiKey, Base64.DEFAULT)));
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }
</code></pre>
"
10283637,10291282,"<p>If you're using AES in <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29"">CBC mode</a>, you can use the second to last block as the IV to decrypt the last block, which may be only partially full, then again to encrypt the plaintext of the last block followed by the new plaintext.</p>

<p>Here's a proof of concept:</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {

    public static void appendAES(File file, byte[] data, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            new SecureRandom().nextBytes(iv);
            rfile.write(iv);
            // we have our iv, and there's no prior data to reencrypt
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32); // second to last block
            rfile.read(iv); // get iv
            byte[] lastBlockEnc = new byte[16]; 
                // last block
                // it's padded, so we'll decrypt it and 
                // save it for the beginning of our data
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16); 
                // position ourselves to overwrite the last block
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) { // lastBlock is null if we're starting a new file
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        out = cipher.doFinal(data);
        rfile.write(out);
        rfile.close();
    }

    public static void decryptAES(File file, OutputStream out, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        // nothing special here, decrypt as usual
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) &lt; 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,""AES""), new IvParameterSpec(iv));
        byte[] buff = new byte[1&lt;&lt;13]; //8kiB
        while (true) {
            int count = fin.read(buff);
            if (count == buff.length) {
                out.write(cipher.update(buff));
            } else {
                out.write(cipher.doFinal(buff,0,count));
                break;
            }
        }
        fin.close();
    }

    public static void main(String[] args) throws Exception {
        byte[] key = new byte[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
        for (int i = 0; i&lt;1000; i++) {
            appendAES(new File(""log.aes""),""All work and no play makes Jack a dull boy. "".getBytes(""UTF-8""),key);
        }
        decryptAES(new File(""log.aes""), new FileOutputStream(""plain.txt""), key);
    }

}
</code></pre>

<p>I'd like to point out that the output is no different than what would be produced by encrypting all in one run. This is <em>not</em> a custom form of encryption --- it's standard AES/CBC/PKCS5Padding. The only implementation-specific detail is that, in the case of a blank file, I've written the iv before beginning the data.</p>

<p>EDIT: Improved (for my taste) solution using <code>CipherOutputStream</code>:</p>

<pre><code>import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.RandomAccessFile;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;


public class AppendAES {
    public static CipherOutputStream appendAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        return appendAES(file, key, null);
    }

    public static CipherOutputStream appendAES(File file, SecretKeySpec key, SecureRandom sr) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        RandomAccessFile rfile = new RandomAccessFile(file,""rw"");
        byte[] iv = new byte[16];
        byte[] lastBlock = null;
        if (rfile.length() % 16L != 0L) {
            throw new IllegalArgumentException(""Invalid file length (not a multiple of block size)"");
        } else if (rfile.length() == 16) {
            throw new IllegalArgumentException(""Invalid file length (need 2 blocks for iv and data)"");
        } else if (rfile.length() == 0L) { 
            // new file: start by appending an IV
            if (sr == null) sr = new SecureRandom();
            sr.nextBytes(iv);
            rfile.write(iv);
        } else { 
            // file length is at least 2 blocks
            rfile.seek(rfile.length()-32);
            rfile.read(iv);
            byte[] lastBlockEnc = new byte[16];
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
            lastBlock = cipher.doFinal(lastBlockEnc);
            rfile.seek(rfile.length()-16);
        } 
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
        byte[] out;
        if (lastBlock != null) {
            out = cipher.update(lastBlock);
            if (out != null) rfile.write(out);
        }
        CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(rfile.getFD()),cipher);
        return cos;
    }

    public static CipherInputStream decryptAES(File file, SecretKeySpec key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        FileInputStream fin = new FileInputStream(file);
        byte[] iv = new byte[16];
        if (fin.read(iv) &lt; 16) {
            throw new IllegalArgumentException(""Invalid file length (needs a full block for iv)"");
        };
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        CipherInputStream cis = new CipherInputStream(fin,cipher);
        return cis;
    }

    public static void main(String[] args) throws Exception {
        byte[] keyBytes = new byte[]{
            0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
        };
        SecretKeySpec key = new SecretKeySpec(keyBytes,""AES"");

        for (int i = 0; i&lt;100; i++) {
            CipherOutputStream cos = appendAES(new File(""log.aes""),key);
            cos.write(""All work and no play "".getBytes(""UTF-8""));
            cos.write(""makes Jack a dull boy.  \n"".getBytes(""UTF-8""));
            cos.close();
        }

        CipherInputStream cis = decryptAES(new File(""log.aes""), key);
        BufferedReader bread = new BufferedReader(new InputStreamReader(cis,""UTF-8""));
        System.out.println(bread.readLine());
        cis.close();
    }

}
</code></pre>
"
10303767,34098587,"<p><strong>Symmetric Key Cryptography</strong> : Symmetric key uses the same key for encryption and decryption. The main challenge with this type of cryptography is the exchange of the secret key between the two parties sender and receiver.</p>
<p><strong>Example :</strong>  The following example uses symmetric key for encryption and decryption algorithm available as part of the Sun's JCE(<strong>J</strong>ava <strong>C</strong>ryptography <strong>E</strong>xtension). Sun JCE is has two layers, the crypto API layer and the provider layer.</p>
<p><strong>DES</strong> (<strong>D</strong>ata <strong>E</strong>ncryption <strong>S</strong>tandard) was a popular symmetric key algorithm. Presently DES is outdated and  considered insecure. <strong>Triple DES</strong> and a stronger variant of <em>DES</em>. It is a symmetric-key block cipher. There are other algorithms like <strong>Blowfish</strong>, <strong>Twofish</strong> and <strong>AES</strong>(<strong>A</strong>dvanced <strong>E</strong>ncryption <strong>S</strong>tandard). AES is the latest encryption standard over the DES.</p>
<p>Steps :</p>
<ol>
<li><strong>Add the Security Provider :</strong> We are using the SunJCE Provider that is available with the JDK.</li>
<li><strong>Generate Secret Key :</strong> Use <code>KeyGenerator</code> and an algorithm to generate a secret key. We are using <code>DESede</code> (<a href=""https://stackoverflow.com/a/17281431/1697099"">DESede</a> is descriptive name for 3DES implementation: DESede = DES-Encrypt-Decrypt-Encrypt = Triple DES).</li>
<li><strong>Encode Text :</strong> For consistency across platform encode the plain text as byte using <code>UTF-8 encoding</code>.</li>
<li><strong>Encrypt Text :</strong> Instantiate <code>Cipher</code> with <code>ENCRYPT_MODE</code>, use the secret key and encrypt the bytes.</li>
<li><strong>Decrypt Text :</strong> Instantiate <code>Cipher</code> with <code>DECRYPT_MODE</code>, use the same secret key and decrypt the bytes.</li>
</ol>
<p>All the above given steps and concept are same, we just replace algorithms.</p>
<pre><code>import java.util.Base64;    
import javax.crypto.Cipher;  
import javax.crypto.KeyGenerator;   
import javax.crypto.SecretKey;  
public class EncryptionDecryptionAES {  
    static Cipher cipher;  

    public static void main(String[] args) throws Exception {
        /* 
         create key 
         If we need to generate a new key use a KeyGenerator
         If we have existing plaintext key use a SecretKeyFactory
        */ 
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        keyGenerator.init(128); // block size is 128bits
        SecretKey secretKey = keyGenerator.generateKey();
        
        /*
          Cipher Info
          Algorithm : for the encryption of electronic data
          mode of operation : to avoid repeated blocks encrypt to the same values.
          padding: ensuring messages are the proper length necessary for certain ciphers 
          mode/padding are not used with stream cyphers.  
         */
        cipher = Cipher.getInstance(&quot;AES&quot;); //SunJCE provider AES algorithm, mode(optional) and padding schema(optional)  

        String plainText = &quot;AES Symmetric Encryption Decryption&quot;;
        System.out.println(&quot;Plain Text Before Encryption: &quot; + plainText);

        String encryptedText = encrypt(plainText, secretKey);
        System.out.println(&quot;Encrypted Text After Encryption: &quot; + encryptedText);

        String decryptedText = decrypt(encryptedText, secretKey);
        System.out.println(&quot;Decrypted Text After Decryption: &quot; + decryptedText);
    }

    public static String encrypt(String plainText, SecretKey secretKey)
            throws Exception {
        byte[] plainTextByte = plainText.getBytes();
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        byte[] encryptedByte = cipher.doFinal(plainTextByte);
        Base64.Encoder encoder = Base64.getEncoder();
        String encryptedText = encoder.encodeToString(encryptedByte);
        return encryptedText;
    }

    public static String decrypt(String encryptedText, SecretKey secretKey)
            throws Exception {
        Base64.Decoder decoder = Base64.getDecoder();
        byte[] encryptedTextByte = decoder.decode(encryptedText);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);
        byte[] decryptedByte = cipher.doFinal(encryptedTextByte);
        String decryptedText = new String(decryptedByte);
        return decryptedText;
    }
}
</code></pre>
<p>Output:</p>
<pre><code>Plain Text Before Encryption: AES Symmetric Encryption Decryption
Encrypted Text After Encryption: sY6vkQrWRg0fvRzbqSAYxepeBIXg4AySj7Xh3x4vDv8TBTkNiTfca7wW/dxiMMJl
Decrypted Text After Decryption: AES Symmetric Encryption Decryption
</code></pre>
<p><a href=""http://javapapers.com/java/java-symmetric-aes-encryption-decryption-using-jce/"" rel=""noreferrer"">Source</a></p>
<p><strong>Example:</strong> Cipher with two modes, they are encrypt and decrypt. we have to start every time after setting mode to encrypt or decrypt a text.
<a href=""https://i.stack.imgur.com/lj3vU.jpg"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/lj3vU.jpg"" alt=""enter image description here"" /></a></p>
"
13102788,22445904,"<p>instead of converting bytes to HEX, you may convert to Base64 as well. I like using Apache Commons for this. Here is an example.</p>

<p>To compile you need additional Apache Commons Codec jar, which is available here:</p>

<p><a href=""http://commons.apache.org/proper/commons-codec/download_codec.cgi"" rel=""nofollow"">http://commons.apache.org/proper/commons-codec/download_codec.cgi</a></p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Encryptor {
    public static String encrypt(String key1, String key2, String value) {
        try {
            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string:""
                    + Base64.encodeBase64String(encrypted));
            return Base64.encodeBase64String(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static String decrypt(String key1, String key2, String encrypted) {
        try {
            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {

        String key1 = ""Bar12345Bar12345""; // 128 bit key
        String key2 = ""ThisIsASecretKet"";
        System.out.println(decrypt(key1, key2,
                encrypt(key1, key2, ""Hello World"")));
    }
}
</code></pre>
"
995514,21245900,"<p>I make this class and found</p>

<pre><code>package com.example.fakessl;

import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;

import android.util.Log;

public class CertificadoAceptar {
    private static TrustManager[] trustManagers;

    public static class _FakeX509TrustManager implements
            javax.net.ssl.X509TrustManager {
        private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[] {};

        public void checkClientTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public void checkServerTrusted(X509Certificate[] arg0, String arg1)
                throws CertificateException {
        }

        public boolean isClientTrusted(X509Certificate[] chain) {
            return (true);
        }

        public boolean isServerTrusted(X509Certificate[] chain) {
            return (true);
        }

        public X509Certificate[] getAcceptedIssuers() {
            return (_AcceptedIssuers);
        }
    }

    public static void allowAllSSL() {

        javax.net.ssl.HttpsURLConnection
                .setDefaultHostnameVerifier(new HostnameVerifier() {
                    public boolean verify(String hostname, SSLSession session) {
                        return true;
                    }
                });

        javax.net.ssl.SSLContext context = null;

        if (trustManagers == null) {
            trustManagers = new javax.net.ssl.TrustManager[] { new _FakeX509TrustManager() };
        }

        try {
            context = javax.net.ssl.SSLContext.getInstance(""TLS"");
            context.init(null, trustManagers, new SecureRandom());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""allowAllSSL"", e.toString());
        } catch (KeyManagementException e) {
            Log.e(""allowAllSSL"", e.toString());
        }
        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(context
                .getSocketFactory());
    }
}
</code></pre>

<p>in you code white this</p>

<pre><code>CertificadoAceptar ca = new CertificadoAceptar();
ca.allowAllSSL();
HttpsTransportSE Transport = new HttpsTransportSE(""iphost or host name"", 8080, ""/WS/wsexample.asmx?WSDL"", 30000);
</code></pre>
"
995514,24013606,"<p><a href=""http://madurangasblogs.blogspot.in/2013/08/avoiding-javaxnetsslsslpeerunverifiedex.html"" rel=""nofollow"">http://madurangasblogs.blogspot.in/2013/08/avoiding-javaxnetsslsslpeerunverifiedex.html</a></p>

<p>Courtesy Maduranga </p>

<p>When developing an application that uses https, your test server doesn't have a valid SSL certificate. Or sometimes the web site is using a self-signed certificate or the web site is using free SSL certificate. So if you try to connect to the server using Apache <code>HttpClient</code>, you will get a exception telling that the ""peer not authenticated"". Though it is not a good practice to trust all the certificates in a production software, you may have to do so according to the situation.
This solution resolves the exception caused by ""peer not authenticated"".</p>

<p>But before we go to the solution, I must warn you that this is not a good idea for a production application. This will violate the purpose of using a security certificate. So unless you have a good reason or if you are sure that this will not cause any problem, don't use this solution.</p>

<p>Normally you create a <code>HttpClient</code> like this.</p>

<p><code>HttpClient httpclient = new DefaultHttpClient();</code></p>

<p>But you have to change the way you create the HttpClient.</p>

<p>First you have to create a class extending <code>org.apache.http.conn.ssl.SSLSocketFactory</code>.</p>

<pre><code>import org.apache.http.conn.ssl.SSLSocketFactory;
import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class MySSLSocketFactory extends SSLSocketFactory {
         SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
</code></pre>

<p>Then create a method like this.</p>

<pre><code>public HttpClient getNewHttpClient() {
     try {
         KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
         trustStore.load(null, null);

         SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
         sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

         HttpParams params = new BasicHttpParams();
         HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
         HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

         SchemeRegistry registry = new SchemeRegistry();
         registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
         registry.register(new Scheme(""https"", sf, 443));

         ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

         return new DefaultHttpClient(ccm, params);
     } catch (Exception e) {
         return new DefaultHttpClient();
     }
}
</code></pre>

<p>Then you can create the <code>HttpClient</code>.</p>

<p><code>HttpClient httpclient = getNewHttpClient();</code></p>

<p>If you are trying to send a post request to a login page the rest of the code would be like this.</p>

<pre><code>private URI url = new URI(""url of the action of the form"");
HttpPost httppost =  new HttpPost(url);
List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;();  
nameValuePairs.add(new BasicNameValuePair(""username"", ""user""));  
nameValuePairs.add(new BasicNameValuePair(""password"", ""password""));
try {
    httppost.setEntity(new UrlEncodedFormEntity(nameValuePairs));
    HttpResponse response = httpclient.execute(httppost);
    HttpEntity entity = response.getEntity();
    InputStream is = entity.getContent();
} catch (UnsupportedEncodingException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (ClientProtocolException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
} catch (IOException e) {
    // TODO Auto-generated catch block
    e.printStackTrace();
}
</code></pre>

<p>You get the html page to the InputStream. Then you can do whatever you want with the returned html page.</p>

<p>But here you will face a problem. If you want to manage a session using cookies, you will not be able to do it with this method. If you want to get the cookies, you will have to do it via a browser. Then only you will receive cookies.</p>
"
20579539,20579770,"<p>in activity write </p>

<pre><code>try {   
                   GmailSender sender = new GmailSender(""gmailusername"", ""gmailpassword"","""");
                   sender.sendMail(""Registration to Model Apps:"",""username=""+username+""\n password=""+password,""gmailusername"",""gmailusername"");   
                } 
             catch (Exception e) 
               {   
                   Log.e(""SendMail"", e.getMessage(), e);   
               }



and create class  GmailSender

package com.example.ur;//write ur pakage

import javax.activation.DataHandler;   
import javax.activation.DataSource;   
import javax.activation.FileDataSource;
import javax.mail.BodyPart;
import javax.mail.Message;   
import javax.mail.PasswordAuthentication;   
import javax.mail.Session;   
import javax.mail.Transport;   
import javax.mail.internet.InternetAddress;   
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;   
import javax.mail.internet.MimeMultipart;

import android.util.Log;

import java.io.ByteArrayInputStream;   
import java.io.IOException;   
import java.io.InputStream;   
import java.io.OutputStream;   
import java.security.Security;   
import java.util.Properties;   

public class GmailSender extends javax.mail.Authenticator {   
    private String mailhost = ""smtp.gmail.com"",imagePath;   
    private String user;   
    private String password;   
    private Session session;   

    static 
    {   
        Security.addProvider(new com.example.model.JSSEProvider());   
    }  

    public GmailSender(String user, String password,String imagePath) {   
        this.user = user;   
        this.password = password;   
        this.imagePath=imagePath;
        Properties props = new Properties();   
        props.setProperty(""mail.transport.protocol"", ""smtp"");   
        props.setProperty(""mail.host"", mailhost);   
        props.put(""mail.smtp.auth"", ""true"");   


        props.put(""mail.smtp.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.port"", ""465"");   
        props.put(""mail.smtp.socketFactory.class"",   
                ""javax.net.ssl.SSLSocketFactory"");   
        props.put(""mail.smtp.socketFactory.fallback"", ""false"");   
        props.setProperty(""mail.smtp.quitwait"", ""false"");   

        session = Session.getDefaultInstance(props, this);   
    }   

    protected PasswordAuthentication getPasswordAuthentication() {   
        return new PasswordAuthentication(user, password);   
    }   

    public synchronized void sendMail(String subject, String body, String sender, String recipients) throws Exception {   
        try{


             Transport transport = session.getTransport();  

             MimeMessage message = new MimeMessage(session);  
             message.setSubject(subject);  
             message.setFrom(new InternetAddress(sender));  
             message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipients));  

             //  
             // This HTML mail have to 2 part, the BODY and the embedded image  
             //  
             MimeMultipart multipart = new MimeMultipart(""related"");  

             // first part  (the html)  
             BodyPart messageBodyPart = new MimeBodyPart();  
             String htmlText = ""&lt;H1&gt;""+body+""&lt;/H1&gt;"";  
             messageBodyPart.setContent(htmlText, ""text/html"");  

             // add it  
             multipart.addBodyPart(messageBodyPart);  

             // second part (the image)  
          //   messageBodyPart = new MimeBodyPart();  
         //    DataSource fds = new FileDataSource(imagePath);  
         //    messageBodyPart.setDataHandler(new DataHandler(fds));  
         //    messageBodyPart.setHeader(""Content-ID"",imagePath);  

             // add it  
           //  multipart.addBodyPart(messageBodyPart);  

             // put everything together  
             message.setContent(multipart);  

             transport.connect();  
             transport.sendMessage(message,message.getRecipients(Message.RecipientType.TO));  
             transport.close();  
        }catch(Exception e){
            Log.e("""", ""FILE NOT FOUND EXCEPTION ""+e.getMessage());
        }
    }   

    public class ByteArrayDataSource implements DataSource {   
        private byte[] data;   
        private String type;   

        public ByteArrayDataSource(byte[] data, String type) {   
            super();   
            this.data = data;   
            this.type = type;   
        }   

        public ByteArrayDataSource(byte[] data) {   
            super();   
            this.data = data;   
        }   

        public void setType(String type) {   
            this.type = type;   
        }   

        public String getContentType() {   
            if (type == null)   
                return ""application/octet-stream"";   
            else  
                return type;   
        }   

        public InputStream getInputStream() throws IOException {   
            return new ByteArrayInputStream(data);   
        }   

        public String getName() {   
            return ""ByteArrayDataSource"";   
        }   

        public OutputStream getOutputStream() throws IOException {   
            throw new IOException(""Not Supported"");   
        }   
    }   
}  
</code></pre>

<p>and create other class JSSEProvider</p>

<pre><code>    package com.example.model;


    import java.security.AccessController;
    import java.security.Provider;

    public final class JSSEProvider extends Provider {

        public JSSEProvider() {
            super(""HarmonyJSSE"", 1.0, ""Harmony JSSE Provider"");
            AccessController.doPrivileged(new java.security.PrivilegedAction&lt;Void&gt;() {
                public Void run() {
                    put(""SSLContext.TLS"",
                            ""org.apache.harmony.xnet.provider.jsse.SSLContextImpl"");
                    put(""Alg.Alias.SSLContext.TLSv1"", ""TLS"");
                    put(""KeyManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.KeyManagerFactoryImpl"");
                    put(""TrustManagerFactory.X509"",
                            ""org.apache.harmony.xnet.provider.jsse.TrustManagerFactoryImpl"");
                    return null;
                }
            });
        }

 }
</code></pre>

<p>import library -  activation.jar
     additionnal.jar
      mail.jar</p>
"
19698272,19723454,"<p>After I got very helpful suggestions from @deathismyfriend and other, I found out what I am missing in my C# Decrypt function.So I change my function as below.</p>

<pre><code>/// C# Error Fixed Version - CipherMode.ECB
public static string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";

private static string Encrypt(string PlainText)
{
    RijndaelManaged aes = new RijndaelManaged();
    aes.BlockSize = 128;
    aes.KeySize = 256;

    /// In Java, Same with below code
    /// Cipher _Cipher = Cipher.getInstance(""AES"");  // Java Code
    aes.Mode = CipherMode.ECB; 

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArrBytes32Value = new byte[32];
    Array.Copy(keyArr, KeyArrBytes32Value, 32);

    aes.Key = KeyArrBytes32Value;

    ICryptoTransform encrypto = aes.CreateEncryptor();

    byte[] plainTextByte = ASCIIEncoding.UTF8.GetBytes(PlainText);
    byte[] CipherText = encrypto.TransformFinalBlock(plainTextByte, 0, plainTextByte.Length);
    return Convert.ToBase64String(CipherText);
}

private static string Decrypt(string CipherText)
{  
    RijndaelManaged aes = new RijndaelManaged();
    aes.BlockSize = 128;
    aes.KeySize = 256;

    /// In Java, Same with below code
    /// Cipher _Cipher = Cipher.getInstance(""AES"");  // Java Code
    aes.Mode = CipherMode.ECB;

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArrBytes32Value = new byte[32];
    Array.Copy(keyArr, KeyArrBytes32Value, 32);

    aes.Key = KeyArrBytes32Value;

    ICryptoTransform decrypto = aes.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(CipherText.ToCharArray(), 0, CipherText.Length);
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
    return ASCIIEncoding.UTF8.GetString(decryptedData);
}
</code></pre>

<p>By using upper c# function , now I can decrypt and read cipher text.<br>
Below is what I found out after I getting error again and again. <br></p>

<pre><code>CryptographicException: Padding is invalid and cannot be removed.

 Solution:  
_RijndaelManaged.Padding = CipherMode.xxx;    ///should toggle here
_RijndaelManaged.Padding = PaddingMode.xxx;   ///should toggle here 


CryptographicException: Length of the data to decrypt is invalid. 
CryptographicException: Specified initialization vector (IV) does not match the block size for this algorithm.

Solution
1. _RijndaelManaged.BlockSize = 128; /// Must be
2. _RijndaelManaged.KeySize = 256; /// Must be
3. _RijndaelManaged.Key = Byte Array Size must be 32 in length ( more detail 32*8 = 256 KeySize )
4. _RijndaelManaged.IV = Byte Array Size must be 16 in length ( more detail 16*8 = 128 BlockSize)
</code></pre>

<p>But when it come to security reason, I think I should not use ECB mode.<br>
According to </p>

<ol>
<li><a href=""https://stackoverflow.com/a/6671819/900284"">ECB mode is not secure</a></li>
<li><a href=""https://stackoverflow.com/questions/6669181/why-does-my-aes-encryption-throws-an-invalidkeyexception"">StackOverFlow link</a></li>
</ol>

<p>So I Modify it again in Java and C#.</p>

<pre><code>// Java code - Cipher mode CBC version.
// CBC version need Initialization vector IV.
// Reference from https://stackoverflow.com/questions/6669181/why-does-my-aes-encryption-throws-an-invalidkeyexception/6669812#6669812

import java.security.Key;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.binary.Base64;

public class CryptoSecurity {

    public static String key = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
    public static byte[] key_Array = Base64.decodeBase64(key);

    public static String encrypt(String strToEncrypt)
    {       
        try
        {   
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");        

            // Initialization vector.   
            // It could be any value or generated using a random number generator.
            byte[] iv = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");    
            _Cipher.init(Cipher.ENCRYPT_MODE, SecretKey, ivspec);       

            return Base64.encodeBase64String(_Cipher.doFinal(strToEncrypt.getBytes()));     
        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());
        }
        return null;
    }

    public static String decrypt(String EncryptedMessage)
    {
        try
        {
            //Cipher _Cipher = Cipher.getInstance(""AES"");
            //Cipher _Cipher = Cipher.getInstance(""AES/ECB/PKCS5PADDING"");
            Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");            

            // Initialization vector.   
            // It could be any value or generated using a random number generator.
            byte[] iv = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            Key SecretKey = new SecretKeySpec(key_Array, ""AES"");
            _Cipher.init(Cipher.DECRYPT_MODE, SecretKey, ivspec);           

            byte DecodedMessage[] = Base64.decodeBase64(EncryptedMessage);
            return new String(_Cipher.doFinal(DecodedMessage));

        }
        catch (Exception e)
        {
            System.out.println(""[Exception]:""+e.getMessage());          

        }
        return null;
    }

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        StringBuilder sb = new StringBuilder();

        sb.append(""xml file string ..."");

        String outputOfEncrypt = encrypt(sb.toString());        
        System.out.println(""[CryptoSecurity.outputOfEncrypt]:""+outputOfEncrypt);

        String outputOfDecrypt = decrypt(outputOfEncrypt);        
        //String outputOfDecrypt = decrypt(sb.toString());        
        System.out.println(""[CryptoSecurity.outputOfDecrypt]:""+outputOfDecrypt);
    }

}
</code></pre>

<p>In C#, I modify it like below.</p>

<pre><code>// C# Code, CipherMode.CBC
// CBC version need Initialization vector IV.

public static string keyStr = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"";
private static string Encrypt(string PlainText)
{
    RijndaelManaged aes = new RijndaelManaged();
    aes.BlockSize = 128;
    aes.KeySize = 256;

    // It is equal in java 
    /// Cipher _Cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");    
    aes.Mode = CipherMode.CBC;  
    aes.Padding = PaddingMode.PKCS7; 

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArrBytes32Value = new byte[32];
    Array.Copy(keyArr, KeyArrBytes32Value, 32);

    // Initialization vector.   
    // It could be any value or generated using a random number generator.
    byte[] ivArr = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };
    byte[] IVBytes16Value = new byte[16];
    Array.Copy(ivArr, IVBytes16Value, 16);

    aes.Key = KeyArrBytes32Value;
    aes.IV = IVBytes16Value;

    ICryptoTransform encrypto = aes.CreateEncryptor();

    byte[] plainTextByte = ASCIIEncoding.UTF8.GetBytes(PlainText);
    byte[] CipherText = encrypto.TransformFinalBlock(plainTextByte, 0, plainTextByte.Length);
    return Convert.ToBase64String(CipherText);

}

private static string Decrypt(string CipherText)
{
    RijndaelManaged aes = new RijndaelManaged();
    aes.BlockSize = 128;
    aes.KeySize = 256;

    aes.Mode = CipherMode.CBC;
    aes.Padding = PaddingMode.PKCS7;

    byte[] keyArr = Convert.FromBase64String(keyStr);
    byte[] KeyArrBytes32Value = new byte[32];
    Array.Copy(keyArr, KeyArrBytes32Value, 32);

    // Initialization vector.   
    // It could be any value or generated using a random number generator.
    byte[] ivArr = { 1, 2, 3, 4, 5, 6, 6, 5, 4, 3, 2, 1, 7, 7, 7, 7 };            
    byte[] IVBytes16Value = new byte[16];
    Array.Copy(ivArr, IVBytes16Value, 16);

    aes.Key = KeyArrBytes32Value;
    aes.IV = IVBytes16Value;

    ICryptoTransform decrypto = aes.CreateDecryptor();

    byte[] encryptedBytes = Convert.FromBase64CharArray(CipherText.ToCharArray(), 0, CipherText.Length);
    byte[] decryptedData = decrypto.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);
    return ASCIIEncoding.UTF8.GetString(decryptedData);
}
</code></pre>

<p>Now it all work.
<br>For more detail about AES, <a href=""http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf"" rel=""noreferrer"">click this link</a> which I was given by @deathismyfriend. 
<br>It is also very useful.</p>
"
19053470,19053733,"<p>below is the code that i am using:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;


public class MD5Encode {
   private static String convertedToHex(byte[] data) {
    StringBuffer buf = new StringBuffer();

    for (int i = 0; i &lt; data.length; i++) {
        int halfOfByte = (data[i] &gt;&gt;&gt; 4) &amp; 0x0F;
        int twoHalfBytes = 0;

        do {
            if ((0 &lt;= halfOfByte) &amp;&amp; (halfOfByte &lt;= 9)) {
                buf.append((char) ('0' + halfOfByte));
            } else {
                buf.append((char) ('a' + (halfOfByte - 10)));
            }

            halfOfByte = data[i] &amp; 0x0F;

        } while (twoHalfBytes++ &lt; 1);
    }
    return buf.toString();
    }

    public static String MD5(String text) throws NoSuchAlgorithmException,
        UnsupportedEncodingException {
    MessageDigest md;
    md = MessageDigest.getInstance(""MD5"");
    byte[] md5 = new byte[64];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    md5 = md.digest();
    return convertedToHex(md5);
   }
}
</code></pre>

<p>and use it by this way:</p>

<pre><code>MD5Encode.MD5(""your string here"")
</code></pre>

<p>hope this will help you :)</p>
"
29224892,29228916,"<p>Try This,</p>

<pre><code>package mypackage;

import java.security.MessageDigest;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;

public class Main {

    public static void main(String[] args) throws Exception {

        String text = ""neeraj"";

        String codedtext = new Main().encrypt(text);

        String decodedtext = new Main().decrypt(codedtext);

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array
        System.out.println(decodedtext); // This correctly shows ""neeraj""
    }

    public String encrypt(String message) throws Exception {
        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher cipher = Cipher.getInstance(""DES/ECB/PKCS7Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key, iv);

        final byte[] plainTextBytes = message.getBytes(""utf-8"");
        final byte[] cipherText = cipher.doFinal(plainTextBytes);
        // final String encodedCipherText = new sun.misc.BASE64Encoder()
        // .encode(cipherText);

        return Base64.encodeBase64String(cipherText);
    }

    public String decrypt(String input) throws Exception {

        byte[] message = Base64.decodeBase64(input);

        final MessageDigest md = MessageDigest.getInstance(""md5"");
        final byte[] digestOfPassword = md.digest(""KEY""
                .getBytes(""utf-8""));
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);
        for (int j = 0, k = 16; j &lt; 8;) {
            keyBytes[k++] = keyBytes[j++];
        }

        final SecretKey key = new SecretKeySpec(keyBytes, ""DESede"");
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);
        final Cipher decipher = Cipher.getInstance(""DES/ECB/PKCS7Padding"");
        decipher.init(Cipher.DECRYPT_MODE, key, iv);

        // final byte[] encData = new
        // sun.misc.BASE64Decoder().decodeBuffer(message);
        final byte[] plainText = decipher.doFinal(message);

        return new String(plainText, ""UTF-8"");
    }
}
</code></pre>

<p>Refer to the main function for usage.</p>

<p>I have updated my code. Your C# program gives output as a base64 string. But in java the input of decrypt and output of encrypt is byte array. Convert the byte array to base64 and it will work.</p>

<p>For Base64 operation in java you need the <a href=""http://commons.apache.org/proper/commons-codec/"" rel=""nofollow noreferrer"">Apache Commons codec</a>.</p>

<p>In java 8 you can use <code>java.util.Base64</code></p>
"
13626965,24501156,"<p>I have used the below code to override the SSL checking in my project and it worked for me.</p>

<pre><code>package com.beingjavaguys.testftp;

import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URL;
import java.net.URLConnection;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.cert.X509Certificate;

/**
 * Fix for Exception in thread ""main"" javax.net.ssl.SSLHandshakeException:
 * sun.security.validator.ValidatorException: PKIX path building failed:
 * sun.security.provider.certpath.SunCertPathBuilderException: unable to find
 * valid certification path to requested target
 */
public class ConnectToHttpsUrl {
    public static void main(String[] args) throws Exception {
        /* Start of Fix */
        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() { return null; }
            public void checkClientTrusted(X509Certificate[] certs, String authType) { }
            public void checkServerTrusted(X509Certificate[] certs, String authType) { }

        } };

        SSLContext sc = SSLContext.getInstance(""SSL"");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) { return true; }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        /* End of the fix*/

        URL url = new URL(""https://nameofthesecuredurl.com"");
        URLConnection con = url.openConnection();
        Reader reader = new InputStreamReader(con.getInputStream());
        while (true) {
            int ch = reader.read();
            if (ch == -1) 
                break;
            System.out.print((char) ch);
        }
    }
}
</code></pre>
"
28233303,28233537,"<p>Try this:</p>

<pre><code> package com.telpoo.frame.net;

import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.HttpVersion;
import org.apache.http.client.HttpClient;
import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpParams;
import org.apache.http.params.HttpProtocolParams;
import org.apache.http.protocol.HTTP;

public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    public static  HttpClient getNewHttpClient() {
        try {
            KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);

            SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
            sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

}
</code></pre>

<p>and use it:</p>

<pre><code>URL myUrl = new URL(url);
            HttpClient client = MySSLSocketFactory.getNewHttpClient(); // myHttpClient();

            HttpConnectionParams.setConnectionTimeout(client.getParams(), connectTimeout);

    HttpPost post = new HttpPost(myUrl.toURI());
</code></pre>
"
28115035,28154780,"<p>maybe I'm missing something but on my side it works without a problem.
Can you try the following class simply changing the fileToBeCrypted, fileToBeDecrypted and fileDecryptedOutput variables?</p>

<pre><code>package test;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

public class TestCrypt{

    private static final String salt = ""t784"";
    private static final String cryptPassword = ""873147cbn9x5'2 79'79314"";
    private static final String fileToBeCrypted = ""c:\\Temp\\sampleFile.conf"";
    private static final String fileToBeDecrypted = ""c:\\Temp\\sampleFile.conf.crypt"";
    private static final String fileDecryptedOutput = ""c:\\Temp\\sampleFile.conf.decrypted"";

    public static void main(String[] args) throws Exception
    {
        for (int i=0; i&lt;100; i++)
        {
            encryptfile(fileToBeCrypted, cryptPassword);
            decrypt(fileToBeDecrypted, cryptPassword, fileDecryptedOutput);
            System.out.println(i);
        }
    }

    public static void encryptfile(String path,String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(path.concat("".crypt""));
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        cos.flush();
        cos.close();
        fis.close();
    }

    public static void decrypt(String path,String password, String outPath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(path);
        FileOutputStream fos = new FileOutputStream(outPath);
        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);
        SecretKeySpec sks = new SecretKeySpec(key, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }

}
</code></pre>

<p>I can iterate many times without an error!
I'm using Oracle JDK 1.8 but running in 1.7 compatibility mode.</p>

<p>Hope this helps you out.</p>

<p>Bye
Piero</p>
"
27993890,27994236,"<p>There appears to something wrong with either the password or salt your using. In the following examples, I used the salt <code>363</code> and password <code>password</code>.</p>

<p>If <a href=""http://ideone.com/GtdWbu"" rel=""nofollow"">run this code in Java</a>:</p>

<pre><code>/* package whatever; // don't place package name! */

import java.util.*;
import java.lang.*;
import java.io.*;

/* Name of the class has to be ""Main"" only if the class is public. */
class Ideone
{
    public static void main (String[] args) throws java.lang.Exception
    {
        String salt = ""363"";
        String password = ""password"";
        String md5 = MD5(MD5(salt) + MD5(password));

        System.out.println(""MD5: "" + md5);
    }

    public static String MD5(String md5) {
           try {
                java.security.MessageDigest md = java.security.MessageDigest.getInstance(""MD5"");
                byte[] array = md.digest(md5.getBytes());
                StringBuffer sb = new StringBuffer();
                for (int i = 0; i &lt; array.length; ++i) {
                  sb.append(Integer.toHexString((array[i] &amp; 0xFF) | 0x100).substring(1,3));
               }
                return sb.toString();
            } catch (java.security.NoSuchAlgorithmException e) {
            }
            return null;
    }
}
</code></pre>

<p>I get:</p>

<blockquote>
  <p>MD5: 81a40e9a2b5b97d2ecc28c26cd2d62f4</p>
</blockquote>

<p>If I execute this in MySQL, I get the same MD5 hash:</p>

<pre><code>&gt; SELECT MD5(CONCAT(MD5('363'),MD5('password')));
+-----------------------------------------+
| MD5(CONCAT(MD5('363'),MD5('password'))) |
+-----------------------------------------+
| 81a40e9a2b5b97d2ecc28c26cd2d62f4        |
+-----------------------------------------+
1 row in set (0.00 sec)
</code></pre>

<p>You have <code>Database salt</code> mentioned, so maybe your using the database salt when in fact each user has its own unique salt?</p>
"
27706853,27706920,"<p>Add this code to trust all the certificate - </p>

<pre><code>import java.io.IOException;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.apache.http.conn.ssl.SSLSocketFactory;
public class MySSLSocketFactory extends SSLSocketFactory {
    SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[] { tm }, null);
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
}
</code></pre>

<p>and use this method to get HTTPClient - </p>

<pre><code>public HttpClient getNewHttpClient() {
    try {
        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        trustStore.load(null, null);

        SSLSocketFactory sf = new MySSLSocketFactory(trustStore);
        sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);

        HttpParams params = new BasicHttpParams();
        HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
        HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        registry.register(new Scheme(""https"", sf, 443));

        ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

        return new DefaultHttpClient(ccm, params);
    } catch (Exception e) {
        return new DefaultHttpClient();
    }
}
</code></pre>

<p>This will trust all the certificates.</p>

<p>Cheers :)</p>
"
27284478,27284757,"<p>may be you can encrypt password by MD5 or other encryption.</p>

<pre><code>package test.md5;

import java.security.MessageDigest;

public class MD5Util {
    public final static String MD5(String s) {
        char hexDigits[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};       

        try {
            byte[] btInput = s.getBytes();
            // get MD5 MessageDigest obj
            MessageDigest mdInst = MessageDigest.getInstance(""MD5"");
            // update
            mdInst.update(btInput);
            // get encryption string
            byte[] md = mdInst.digest();
            // change to hexadecimal
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i &lt; j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];
                str[k++] = hexDigits[byte0 &amp; 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void main(String[] args) {
        System.out.println(MD5Util.MD5(""20121221""));
        System.out.println(MD5Util.MD5(""encrypt""));
    }
}
</code></pre>
"
26920068,26984009,"<p>I'm glad for the help of everyone who commented. Without your help I would be stucked yet. I figured out that the LDAP server does not allow bind with just the base DN.</p>

<p>After a desperate trying, I could connect using the full path of the tree:</p>

<pre><code>uid=tiagoadami,ou=proto,ou=serv,ou=user,ou=collab,ou=all,dc=XXXXX,dc=YYY,dc=ZZ
</code></pre>

<p>instead of:</p>

<pre><code>uid=tiagoadami,dc=XXXXX,dc=YYY,dc=ZZ
</code></pre>

<p>Sooooooooo looooooooong... <strong>with these 2 classes</strong> I was able to solve <strong>ALL</strong> my LDAP problems. I changed them to search inside the tree and get the full DN for a given UID. Here they are for anyone with the same problems:</p>

<p><strong><em>TrustAllCertificatesSSLSocketFactory.java</em></strong></p>

<pre><code>package com.adamiworks.commonutils.ldap;

import java.io.IOException;
import java.net.InetAddress;
import java.net.Socket;
import java.net.UnknownHostException;
import java.security.SecureRandom;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;

import javax.net.SocketFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

/**
 * This class accept all SSL Certificates even if it can assure its
 * Certification Institute.
 * 
 * DO NOT USE AT PRODUCTION ENVIRONMENTS
 * 
 * @author Tiago J. Adami
 *
 */
public class TrustAllCertificatesSSLSocketFactory extends SocketFactory {
    private SocketFactory socketFactory;

    public TrustAllCertificatesSSLSocketFactory() {
        try {
            SSLContext ctx = SSLContext.getInstance(""SSL"");
            ctx.init(null, new TrustManager[] { new AllCertificatesTrustManager() }, new SecureRandom());
            socketFactory = ctx.getSocketFactory();
        } catch (Exception ex) {
            ex.printStackTrace(System.err); /* handle exception */
        }
    }

    public static SocketFactory getDefault() {
        return new TrustAllCertificatesSSLSocketFactory();
    }

    @Override
    public Socket createSocket(String string, int i) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i);
    }

    @Override
    public Socket createSocket(String string, int i, InetAddress ia, int i1) throws IOException, UnknownHostException {
        return socketFactory.createSocket(string, i, ia, i1);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i) throws IOException {
        return socketFactory.createSocket(ia, i);
    }

    @Override
    public Socket createSocket(InetAddress ia, int i, InetAddress ia1, int i1) throws IOException {
        return socketFactory.createSocket(ia, i, ia1, i1);
    }

    private class AllCertificatesTrustManager implements X509TrustManager {
        public void checkClientTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public void checkServerTrusted(X509Certificate[] xcs, String string) throws CertificateException {
            // do nothing
        }

        public X509Certificate[] getAcceptedIssuers() {
            return new java.security.cert.X509Certificate[0];
        }
    }
}
</code></pre>

<p><strong><em>LdapUtils.java</em></strong></p>

<pre><code>package com.adamiworks.commonutils.ldap;

import java.util.Hashtable;
import java.util.Properties;

import javax.naming.AuthenticationException;
import javax.naming.Context;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import javax.naming.directory.SearchControls;
import javax.naming.directory.SearchResult;

/**
 * Authenticates with LDAP Servers. Just using a single UID this class goes deep
 * inside the user's tree and find the full DN for the given UID. It also allows
 * to connect to servers when you don't have the certificate yet... but use this
 * feature at your own risk!
 * 
 * @author Tiago J. Adami
 *
 */
public class LdapUtils {
    private InitialDirContext ldap;
    private String host;
    private int port;
    private boolean useSSL;
    private boolean ignoreCertificates;
    private String basedn;

    public InitialDirContext getLdap() {
        return ldap;
    }

    public boolean isIgnoreCertificates() {
        return ignoreCertificates;
    }

    public void setIgnoreCertificates(boolean ignoreCertificates) {
        this.ignoreCertificates = ignoreCertificates;
    }

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public String getBasedn() {
        return basedn;
    }

    public boolean isUseSSL() {
        return useSSL;
    }

    public void setUseSSL(boolean useSSL) {
        this.useSSL = useSSL;
    }

    /**
     * Default constructor
     * 
     * @param host
     * @param port
     * @param basedn
     * @param useSSL
     * @param ignoreCertificates
     */
    public LdapUtils(String host, int port, String basedn, boolean useSSL, boolean ignoreCertificates) {
        super();
        this.host = host;
        this.port = port;
        this.useSSL = useSSL;
        this.basedn = basedn;
        this.ignoreCertificates = ignoreCertificates;
    }

    /**
     * Authenticates an user and password from LDAP credentials;
     * 
     * @param uid
     * @param password
     * @return
     * @throws NamingException
     */
    public boolean authenticate(String uid, String password) {
        try {
            String url = getUrl();
            String dn = this.getDnByUid(uid);

            Properties env = new Properties();
            env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
            env.put(Context.PROVIDER_URL, url);

            env.put(Context.SECURITY_AUTHENTICATION, ""simple"");

            env.put(Context.SECURITY_PRINCIPAL, dn);
            env.put(Context.SECURITY_CREDENTIALS, password);

            if (this.useSSL) {
                env.put(Context.SECURITY_PROTOCOL, ""ssl"");
            }

            if (this.useSSL &amp;&amp; this.ignoreCertificates) {
                env.put(""java.naming.ldap.factory.socket"", ""com.adamiworks.commonutils.ldap.TrustAllCertificatesSSLSocketFactory"");
            }

            ldap = new InitialDirContext(env);
        } catch (AuthenticationException e) {
            e.printStackTrace();
            return false;
        } catch (NamingException e) {
            e.printStackTrace();
            return false;
        }

        return true;
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrl() {
        StringBuilder url = new StringBuilder();

        url.append(this.useSSL ? ""ldaps://"" : ""ldap://"");
        url.append(host);
        url.append("":"");
        url.append(port);
        return url.toString();
    }

    /**
     * Returns the url based on SSL or not
     * 
     * @return
     */
    private String getUrlWithoutSsl() {
        StringBuilder url = new StringBuilder();
        url.append(""ldap://"");
        url.append(host);
        return url.toString();
    }

    /**
     * Return LDAP authentication modes allowed by the server
     * 
     * @param url
     * @return
     * @throws NamingException
     */
    public Attributes getLdapAuths() throws NamingException {

        // Create initial context
        DirContext ctx = new InitialDirContext();

        // Read supportedSASLMechanisms from root DSE
        Attributes attrs = ctx.getAttributes(this.getUrl(), new String[] { ""supportedSASLMechanisms"" });

        System.out.println(attrs);

        return attrs;

    }

    /**
     * Returns the full DN (distinct name) for a given UID
     * 
     * @param uid
     *            the UID name of the user
     * @return full tree path of LDAP
     * @throws NamingException
     */
    @SuppressWarnings(""rawtypes"")
    public String getDnByUid(String uid) throws NamingException {
        String url = this.getUrlWithoutSsl() + ""/"" + this.basedn;

        Hashtable&lt;String, Object&gt; env = new Hashtable&lt;String, Object&gt;(11);
        env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");
        env.put(Context.PROVIDER_URL, url);

        String ret = ""uid="" + uid;
        DirContext ctx = null;

        try {
            // Create initial context
            ctx = new InitialDirContext(env);

            SearchControls controls = new SearchControls();
            controls.setSearchScope(SearchControls.SUBTREE_SCOPE);

            NamingEnumeration answer = ctx.search("""", ""(uid="" + uid + "")"", controls);

            while (answer.hasMore()) {
                SearchResult sr = (SearchResult) answer.next();
                ret = sr.getNameInNamespace();
                break;
            }

        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // Close the context when we're done
            ctx.close();
        }

        System.out.println(""FULL DN:  "" + ret);

        return ret;
    }

}
</code></pre>
"
24968466,24968616,"<p>Byte array cannot directly convert to string, and neither do the reverse direction.</p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class stackoverflow_test {
    private byte[] encrypted;

    private String encryptedtext;
    private String decrypted;

    public String Encrypt(String pInput) {

        try {

            String Input = pInput;
            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(Input.getBytes());
            //encryptedtext = new String(encrypted);
            encryptedtext = DatatypeConverter.printBase64Binary(encrypted);
            System.err.println(""encrypted:"" + encryptedtext);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return encryptedtext;
    }

    public String Decrypt(String pInput) {

        try {

            String Input = pInput;

            String key = ""Bar12345Bar12345Bar12345Bar12345"";

            SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");

            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            encrypted = DatatypeConverter.parseBase64Binary(encryptedtext);
            decrypted = new String(cipher.doFinal(encrypted)); 
            System.err.println(""decrypted: "" + decrypted);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return pInput;
    }

    public static void main(String[] ag){
        stackoverflow_test test = new stackoverflow_test();
        String a = test.Encrypt(""Byte cannot directly convert to string"");
        String b = test.Decrypt(a);
    }
}
</code></pre>

<p>Result</p>

<pre><code>encrypted:UmH+3eUagjrRDblxSStArnaktoxTLX+7qvPdwiTO7VggYmYtuXu/Ygww8ZG5SrDz
decrypted: Byte cannot directly convert to string
</code></pre>
"
24668843,24671967,"<p>For AES you can use java's libraries.</p>

<p>The fallowing code will give you an idea to start.</p>

<pre><code>import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class AES {
     public void run() {
         try {
             String text = ""Hello World"";
             String key = ""1234567891234567"";
             // Create key and cipher
             Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
             Cipher cipher = Cipher.getInstance(""AES"");

         // encrypt the text
         cipher.init(Cipher.ENCRYPT_MODE, aesKey);
         byte[] encrypted = cipher.doFinal(text.getBytes());
         System.out.println(""Encrypted text: "" + new String(encrypted));

         // decrypt the text
         cipher.init(Cipher.DECRYPT_MODE, aesKey);
         String decrypted = new String(cipher.doFinal(encrypted));
         System.out.println(""Decrypted text: "" + decrypted);
      }catch(Exception e) {
         e.printStackTrace();
      }
    }

    public static void main(String[] args) {
        AES app = new AES();
       app.run();
    }
}
</code></pre>
"
15920739,23795194,"<p>My RSA Class:</p>

<pre><code>package com.infovale.cripto;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Arrays;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;

public class RSA {


static String kPublic = """";
static String kPrivate = """";

public RSA()
{

}


public String Encrypt(String plain) throws NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {

    String encrypted;
    byte[] encryptedBytes;      

    KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
    kpg.initialize(1024);
    KeyPair kp = kpg.genKeyPair();

    PublicKey publicKey = kp.getPublic();
    PrivateKey privateKey = kp.getPrivate();

    byte[] publicKeyBytes = publicKey.getEncoded();
    byte[] privateKeyBytes = privateKey.getEncoded();

    kPublic = bytesToString(publicKeyBytes);
    kPrivate = bytesToString(privateKeyBytes);

    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    encryptedBytes = cipher.doFinal(plain.getBytes());

    encrypted = bytesToString(encryptedBytes);
    return encrypted;

}

public String Decrypt(String result) throws NoSuchAlgorithmException,
        NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {

    byte[] decryptedBytes;

    byte[] byteKeyPrivate = stringToBytes(kPrivate);

    KeyFactory kf = KeyFactory.getInstance(""RSA"");

    PrivateKey privateKey = null;
    try {

        privateKey = kf.generatePrivate(new PKCS8EncodedKeySpec(byteKeyPrivate));

    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    }

    String decrypted;

    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    decryptedBytes = cipher.doFinal(stringToBytes(result));
    decrypted = new String(decryptedBytes);
    return decrypted;

}

public String bytesToString(byte[] b) {
    byte[] b2 = new byte[b.length + 1];
    b2[0] = 1;
    System.arraycopy(b, 0, b2, 1, b.length);
    return new BigInteger(b2).toString(36);
}

public byte[] stringToBytes(String s) {
    byte[] b2 = new BigInteger(s, 36).toByteArray();
    return Arrays.copyOfRange(b2, 1, b2.length);
}
}
</code></pre>
"
23482145,23482556,"<p>As others pointed out, it is not possible to generate a <strong>unique alphanumeric string with length 11</strong> from each email address, as the <strong>alphanumeric strings with length 11</strong> are less than all the possible email addresses. So there will always be two different email addresses e1 and e2 such that <strong>F(e1) = F(e2) = S</strong> for some string <strong>S</strong> which you generate.</p>

<p>Still, given an email address <strong>e1</strong>, you can generate a string which is (let's call it) ""pseudo-unique"" i.e. a string <strong>S = F(e1)</strong> for which it is <strong>practically very hard</strong> to find another email address <strong>e2 != e1</strong> such that <strong>F(e2) = S</strong>. And as others pointed out, you can use e.g. MD5 to achieve this.</p>

<p>Look at this class and call it on the byte array obtained from your email address.</p>

<p><a href=""http://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html"" rel=""nofollow"">http://docs.oracle.com/javase/7/docs/api/java/security/MessageDigest.html</a></p>

<p>Actually here is an example using MD5.</p>

<pre><code>import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Test003 {

    public static void main(String[] args) throws Exception {
        System.out.println(getPseudoUniqueString(""test1@test.com""));
        System.out.println(getPseudoUniqueString(""test2@test.com""));            
    }

    private static String getPseudoUniqueString(String str) 
        throws NoSuchAlgorithmException 
    {
        MessageDigest md1 = MessageDigest.getInstance(""MD5"");
        md1.update(str.getBytes());
        byte[] bd1 = md1.digest();

        StringBuffer hexString = new StringBuffer();
        for (int i=0;i&lt;bd1.length;i++) {
            String hex=Integer.toHexString(0xff &amp; bd1[i]);
            if(hex.length()==1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }

        return hexString.toString().substring(0,11);
    }
}
</code></pre>
"
23561104,32583766,"<p>I just want to add that if you want to somehow store the encrypted byte array as String and then retrieve it and decrypt it (often for obfuscation of database values) you can use this approach:</p>

<pre><code>import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
public class StrongAES 
{
    public void run() 
    {
        try 
        {
            String text = ""Hello World"";
            String key = ""Bar12345Bar12345""; // 128 bit key
            // Create key and cipher
            Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(text.getBytes());

            StringBuilder sb = new StringBuilder();
            for (byte b: encrypted) {
                sb.append((char)b);
            }

            // the encrypted String
            String enc = sb.toString();
            System.out.println(""encrypted:"" + enc);

            // now convert the string to byte array
            // for decryption
            byte[] bb = new byte[enc.length()];
            for (int i=0; i&lt;enc.length(); i++) {
                bb[i] = (byte) enc.charAt(i);
            }

            // decrypt the text
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(bb));
            System.err.println(""decrypted:"" + decrypted);

        }
        catch(Exception e) 
        {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) 
    {
        StrongAES app = new StrongAES();
        app.run();
    }
}
</code></pre>
"
23561104,30591269,"<pre><code>package com.example;
import java.security.Key;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
public class StrongAES 
{
    public void run() 
    {
        try 
        {
            String text = ""Hello World"";
            String key = ""Bar12345Bar12345""; // 128 bit key
            // Create key and cipher
            Key aesKey = new SecretKeySpec(key.getBytes(), ""AES"");
            Cipher cipher = Cipher.getInstance(""AES"");
            // encrypt the text
            cipher.init(Cipher.ENCRYPT_MODE, aesKey);
            byte[] encrypted = cipher.doFinal(text.getBytes());
            System.err.println(new String(encrypted));
            // decrypt the text
            cipher.init(Cipher.DECRYPT_MODE, aesKey);
            String decrypted = new String(cipher.doFinal(encrypted));
            System.err.println(decrypted);
        }
        catch(Exception e) 
        {
            e.printStackTrace();
        }
    }
    public static void main(String[] args) 
    {
        StrongAES app = new StrongAES();
        app.run();
    }
}
</code></pre>
"
26649389,29946540,"<p>I found the solution for it by analyzing the data packets using wireshark. What I found is that while making a secure connection, android was falling back to <strong>SSLv3</strong> from <strong>TLSv1</strong> . It is a bug in android versions &lt; 4.4 , and it can be solved by removing the SSLv3 protocol from Enabled Protocols list. I made a custom socketFactory class called NoSSLv3SocketFactory.java. Use this to make a socketfactory.</p>

<pre><code>/*Copyright 2015 Bhavit Singh Sengar
Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.*/

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;


public class NoSSLv3SocketFactory extends SSLSocketFactory{
    private final SSLSocketFactory delegate;

public NoSSLv3SocketFactory() {
    this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
}

public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}

private class NoSSLv3SSLSocket extends DelegateSSLSocket {

    private NoSSLv3SSLSocket(SSLSocket delegate) {
        super(delegate);

    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; ""SSLv3"".equals(protocols[0])) {

            List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));
            if (enabledProtocols.size() &gt; 1) {
                enabledProtocols.remove(""SSLv3"");
                System.out.println(""Removed SSLv3 from enabled protocols"");
            } else {
                System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
            }
            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
        }

        super.setEnabledProtocols(protocols);
    }
}

public class DelegateSSLSocket extends SSLSocket {

    protected final SSLSocket delegate;

    DelegateSSLSocket(SSLSocket delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    @Override
    public String[] getEnabledCipherSuites() {
        return delegate.getEnabledCipherSuites();
    }

    @Override
    public void setEnabledCipherSuites(String[] suites) {
        delegate.setEnabledCipherSuites(suites);
    }

    @Override
    public String[] getSupportedProtocols() {
        return delegate.getSupportedProtocols();
    }

    @Override
    public String[] getEnabledProtocols() {
        return delegate.getEnabledProtocols();
    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        delegate.setEnabledProtocols(protocols);
    }

    @Override
    public SSLSession getSession() {
        return delegate.getSession();
    }

    @Override
    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.addHandshakeCompletedListener(listener);
    }

    @Override
    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
        delegate.removeHandshakeCompletedListener(listener);
    }

    @Override
    public void startHandshake() throws IOException {
        delegate.startHandshake();
    }

    @Override
    public void setUseClientMode(boolean mode) {
        delegate.setUseClientMode(mode);
    }

    @Override
    public boolean getUseClientMode() {
        return delegate.getUseClientMode();
    }

    @Override
    public void setNeedClientAuth(boolean need) {
        delegate.setNeedClientAuth(need);
    }

    @Override
    public void setWantClientAuth(boolean want) {
        delegate.setWantClientAuth(want);
    }

    @Override
    public boolean getNeedClientAuth() {
        return delegate.getNeedClientAuth();
    }

    @Override
    public boolean getWantClientAuth() {
        return delegate.getWantClientAuth();
    }

    @Override
    public void setEnableSessionCreation(boolean flag) {
        delegate.setEnableSessionCreation(flag);
    }

    @Override
    public boolean getEnableSessionCreation() {
        return delegate.getEnableSessionCreation();
    }

    @Override
    public void bind(SocketAddress localAddr) throws IOException {
        delegate.bind(localAddr);
    }

    @Override
    public synchronized void close() throws IOException {
        delegate.close();
    }

    @Override
    public void connect(SocketAddress remoteAddr) throws IOException {
        delegate.connect(remoteAddr);
    }

    @Override
    public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
        delegate.connect(remoteAddr, timeout);
    }

    @Override
    public SocketChannel getChannel() {
        return delegate.getChannel();
    }

    @Override
    public InetAddress getInetAddress() {
        return delegate.getInetAddress();
    }

    @Override
    public InputStream getInputStream() throws IOException {
        return delegate.getInputStream();
    }

    @Override
    public boolean getKeepAlive() throws SocketException {
        return delegate.getKeepAlive();
    }

    @Override
    public InetAddress getLocalAddress() {
        return delegate.getLocalAddress();
    }

    @Override
    public int getLocalPort() {
        return delegate.getLocalPort();
    }

    @Override
    public SocketAddress getLocalSocketAddress() {
        return delegate.getLocalSocketAddress();
    }

    @Override
    public boolean getOOBInline() throws SocketException {
        return delegate.getOOBInline();
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        return delegate.getOutputStream();
    }

    @Override
    public int getPort() {
        return delegate.getPort();
    }

    @Override
    public synchronized int getReceiveBufferSize() throws SocketException {
        return delegate.getReceiveBufferSize();
    }

    @Override
    public SocketAddress getRemoteSocketAddress() {
        return delegate.getRemoteSocketAddress();
    }

    @Override
    public boolean getReuseAddress() throws SocketException {
        return delegate.getReuseAddress();
    }

    @Override
    public synchronized int getSendBufferSize() throws SocketException {
        return delegate.getSendBufferSize();
    }

    @Override
    public int getSoLinger() throws SocketException {
        return delegate.getSoLinger();
    }

    @Override
    public synchronized int getSoTimeout() throws SocketException {
        return delegate.getSoTimeout();
    }

    @Override
    public boolean getTcpNoDelay() throws SocketException {
        return delegate.getTcpNoDelay();
    }

    @Override
    public int getTrafficClass() throws SocketException {
        return delegate.getTrafficClass();
    }

    @Override
    public boolean isBound() {
        return delegate.isBound();
    }

    @Override
    public boolean isClosed() {
        return delegate.isClosed();
    }

    @Override
    public boolean isConnected() {
        return delegate.isConnected();
    }

    @Override
    public boolean isInputShutdown() {
        return delegate.isInputShutdown();
    }

    @Override
    public boolean isOutputShutdown() {
        return delegate.isOutputShutdown();
    }

    @Override
    public void sendUrgentData(int value) throws IOException {
        delegate.sendUrgentData(value);
    }

    @Override
    public void setKeepAlive(boolean keepAlive) throws SocketException {
        delegate.setKeepAlive(keepAlive);
    }

    @Override
    public void setOOBInline(boolean oobinline) throws SocketException {
        delegate.setOOBInline(oobinline);
    }

    @Override
    public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
    }

    @Override
    public synchronized void setReceiveBufferSize(int size) throws SocketException {
        delegate.setReceiveBufferSize(size);
    }

    @Override
    public void setReuseAddress(boolean reuse) throws SocketException {
        delegate.setReuseAddress(reuse);
    }

    @Override
    public synchronized void setSendBufferSize(int size) throws SocketException {
        delegate.setSendBufferSize(size);
    }

    @Override
    public void setSoLinger(boolean on, int timeout) throws SocketException {
        delegate.setSoLinger(on, timeout);
    }

    @Override
    public synchronized void setSoTimeout(int timeout) throws SocketException {
        delegate.setSoTimeout(timeout);
    }

    @Override
    public void setTcpNoDelay(boolean on) throws SocketException {
        delegate.setTcpNoDelay(on);
    }

    @Override
    public void setTrafficClass(int value) throws SocketException {
        delegate.setTrafficClass(value);
    }

    @Override
    public void shutdownInput() throws IOException {
        delegate.shutdownInput();
    }

    @Override
    public void shutdownOutput() throws IOException {
        delegate.shutdownOutput();
    }

    @Override
    public String toString() {
        return delegate.toString();
    }

    @Override
    public boolean equals(Object o) {
        return delegate.equals(o);
    }
}
}
</code></pre>

<p>Use this class like this while connecting :</p>

<pre><code>SSLContext sslcontext = SSLContext.getInstance(""TLSv1"");

            sslcontext.init(null,
                    null,
                    null);
            SSLSocketFactory NoSSLv3Factory = new NoSSLv3SocketFactory(sslcontext.getSocketFactory());

            HttpsURLConnection.setDefaultSSLSocketFactory(NoSSLv3Factory);
            l_connection = (HttpsURLConnection) l_url.openConnection();
            l_connection.connect();
</code></pre>

<p><strong>UPDATE :</strong></p>

<p>Now, correct solution would be to install a newer security provider using <a href=""https://developer.android.com/reference/com/google/android/gms/security/ProviderInstaller.html"" rel=""noreferrer"">Google Play Services</a>:</p>

<pre><code>    ProviderInstaller.installIfNeeded(getApplicationContext());
</code></pre>

<p>This effectively gives your app access to a newer version of OpenSSL and Java Security Provider, which includes support for TLSv1.2 in SSLEngine. Once the new provider is installed, you can create an SSLEngine which supports SSLv3, TLSv1, TLSv1.1 and TLSv1.2 the usual way: </p>

<pre><code>    SSLContext sslContext = SSLContext.getInstance(""TLSv1.2"");
    sslContext.init(null, null, null);
    SSLEngine engine = sslContext.createSSLEngine();
</code></pre>

<p>Or you can restrict the enabled protocols using <code>engine.setEnabledProtocols</code>.</p>

<p>Don't forget to add the following dependency (<a href=""https://developers.google.com/android/guides/releases"" rel=""noreferrer"">latest version found here</a>):</p>

<pre><code>compile 'com.google.android.gms:play-services-auth:11.8.0'
</code></pre>

<p>For more info, checkout this <a href=""https://developer.android.com/training/articles/security-gms-provider.html"" rel=""noreferrer"">link</a>.</p>
"
26649389,40886791,"<p>Connects with https server we need certificate in handshaking from client side. 1 year back I solved a similar issue using self sign certificate in the following way-</p>

<pre><code>import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

public class HttpsTrustManager implements X509TrustManager {

private static TrustManager[] trustManagers;
private static final X509Certificate[] _AcceptedIssuers = new X509Certificate[]{};

@Override
public void checkClientTrusted(
        java.security.cert.X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {

}

@Override
public void checkServerTrusted(
        java.security.cert.X509Certificate[] x509Certificates, String s)
        throws java.security.cert.CertificateException {

}

public boolean isClientTrusted(X509Certificate[] chain) {
    return true;
}

public boolean isServerTrusted(X509Certificate[] chain) {
    return true;
}

@Override
public X509Certificate[] getAcceptedIssuers() {
    return _AcceptedIssuers;
}

public static void allowAllSSL() {
    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {

        @Override
        public boolean verify(String arg0, SSLSession arg1) {
            return true;
        }

    });

    SSLContext context = null;
    if (trustManagers == null) {
        trustManagers = new TrustManager[]{new HttpsTrustManager()};
    }

    try {
        context = SSLContext.getInstance(""TLS"");
        context.init(null, trustManagers, new SecureRandom());
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (KeyManagementException e) {
        e.printStackTrace();
    }

    HttpsURLConnection.setDefaultSSLSocketFactory(context
            .getSocketFactory());
}

}
</code></pre>

<p>Usage in client side before HttpsUrlConnection</p>

<pre><code>HttpsTrustManager.allowAllSSL();
</code></pre>

<p>hopefully it will work :)</p>
"
32508961,32565922,"<p>Following is a Java program to decrypt the above OPENSSL encryption (it requires Java 8):</p>

<pre><code>import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.Base64;
import java.util.Base64.Decoder;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class TestAesDecrypt {

    public static void main(final String[] args) throws Exception {
        final byte[] pass = ""testpass"".getBytes(StandardCharsets.US_ASCII);
        final byte[] magic = ""Salted__"".getBytes(StandardCharsets.US_ASCII);
        final String inFile = ""e:/t/e.txt"";

        String source = new String(Files.readAllBytes(Paths.get(inFile)),
                StandardCharsets.US_ASCII);
        source = source.replaceAll(""\\s"", """");
        final Decoder decoder = Base64.getDecoder();
        final byte[] inBytes = decoder.decode(source);

        final byte[] shouldBeMagic = Arrays.copyOfRange(inBytes, 0,
                magic.length);
        if (!Arrays.equals(shouldBeMagic, magic)) {
            System.out.println(""Bad magic number"");
            return;
        }

        final byte[] salt = Arrays.copyOfRange(inBytes, magic.length,
                magic.length + 8);

        final byte[] passAndSalt = concat(pass, salt);

        byte[] hash = new byte[0];
        byte[] keyAndIv = new byte[0];
        for (int i = 0; i &lt; 3; i++) {
            final byte[] data = concat(hash, passAndSalt);
            final MessageDigest md = MessageDigest.getInstance(""MD5"");
            hash = md.digest(data);
            keyAndIv = concat(keyAndIv, hash);
        }

        final byte[] keyValue = Arrays.copyOfRange(keyAndIv, 0, 32);
        final byte[] iv = Arrays.copyOfRange(keyAndIv, 32, 48);
        final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        final SecretKeySpec key = new SecretKeySpec(keyValue, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
        final byte[] clear = cipher.doFinal(inBytes, 16, inBytes.length - 16);
        final String clearText = new String(clear, StandardCharsets.ISO_8859_1);
        System.out.println(clearText);
    }

    private static byte[] concat(final byte[] a, final byte[] b) {
        final byte[] c = new byte[a.length + b.length];
        System.arraycopy(a, 0, c, 0, a.length);
        System.arraycopy(b, 0, c, a.length, b.length);
        return c;
    }
}
</code></pre>
"
9210514,36874647,"<p>Here is the solution , follow the below link Step by Step :</p>

<p><a href=""http://www.mkyong.com/webservices/jax-ws/suncertpathbuilderexception-unable-to-find-valid-certification-path-to-requested-target/"" rel=""noreferrer"">http://www.mkyong.com/webservices/jax-ws/suncertpathbuilderexception-unable-to-find-valid-certification-path-to-requested-target/</a></p>

<p>JAVA FILE : which is missing from the blog</p>

<pre><code>/*
 * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   - Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *   - Neither the name of Sun Microsystems nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS
 * IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



import java.io.*;
import java.net.URL;

import java.security.*;
import java.security.cert.*;

import javax.net.ssl.*;

public class InstallCert {

    public static void main(String[] args) throws Exception {
    String host;
    int port;
    char[] passphrase;
    if ((args.length == 1) || (args.length == 2)) {
        String[] c = args[0].split("":"");
        host = c[0];
        port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);
        String p = (args.length == 1) ? ""changeit"" : args[1];
        passphrase = p.toCharArray();
    } else {
        System.out.println(""Usage: java InstallCert &lt;host&gt;[:port] [passphrase]"");
        return;
    }

    File file = new File(""jssecacerts"");
    if (file.isFile() == false) {
        char SEP = File.separatorChar;
        File dir = new File(System.getProperty(""java.home"") + SEP
            + ""lib"" + SEP + ""security"");
        file = new File(dir, ""jssecacerts"");
        if (file.isFile() == false) {
        file = new File(dir, ""cacerts"");
        }
    }
    System.out.println(""Loading KeyStore "" + file + ""..."");
    InputStream in = new FileInputStream(file);
    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
    ks.load(in, passphrase);
    in.close();

    SSLContext context = SSLContext.getInstance(""TLS"");
    TrustManagerFactory tmf =
        TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(ks);
    X509TrustManager defaultTrustManager = (X509TrustManager)tmf.getTrustManagers()[0];
    SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
    context.init(null, new TrustManager[] {tm}, null);
    SSLSocketFactory factory = context.getSocketFactory();

    System.out.println(""Opening connection to "" + host + "":"" + port + ""..."");
    SSLSocket socket = (SSLSocket)factory.createSocket(host, port);
    socket.setSoTimeout(10000);
    try {
        System.out.println(""Starting SSL handshake..."");
        socket.startHandshake();
        socket.close();
        System.out.println();
        System.out.println(""No errors, certificate is already trusted"");
    } catch (SSLException e) {
        System.out.println();
        e.printStackTrace(System.out);
    }

    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader =
        new BufferedReader(new InputStreamReader(System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i &lt; chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println
            ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);

    OutputStream out = new FileOutputStream(""jssecacerts"");
    ks.store(out, passphrase);
    out.close();

    System.out.println();
    System.out.println(cert);
    System.out.println();
    System.out.println
        (""Added certificate to keystore 'jssecacerts' using alias '""
        + alias + ""'"");
    }

    private static final char[] HEXDIGITS = ""0123456789abcdef"".toCharArray();

    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &amp;= 0xff;
            sb.append(HEXDIGITS[b &gt;&gt; 4]);
            sb.append(HEXDIGITS[b &amp; 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

    private final X509TrustManager tm;
    private X509Certificate[] chain;

    SavingTrustManager(X509TrustManager tm) {
        this.tm = tm;
    }

    public X509Certificate[] getAcceptedIssuers() {
        throw new UnsupportedOperationException();
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }
    }

}
</code></pre>
"
40123319,42153463,"<p>Using these helper class you can encrypt and decrypt string in android simple way, but this will work only for below Android 7.0, for <strong>Android 8.0</strong> and above you can find from <a href=""https://stackoverflow.com/a/39002997/2897365""><strong>here</strong></a></p>

<pre><code>import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class AESHelper {

public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}

private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"",""Crypto"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt) {
    return toHex(txt.getBytes());
}
public static String fromHex(String hex) {
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i &lt; len; i++)
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
    return result;
}

public static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2*buf.length);
    for (int i = 0; i &lt; buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b&gt;&gt;4)&amp;0x0f)).append(HEX.charAt(b&amp;0x0f));
}
}
</code></pre>

<p>below is your method for encryption and decryption for string,</p>

<pre><code>public String encryption(String strNormalText){
    String seedValue = ""YourSecKey"";
    String normalTextEnc="""";
    try {
        normalTextEnc = AESHelper.encrypt(seedValue, strNormalText);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return normalTextEnc;
}
public String decryption(String strEncryptedText){
    String seedValue = ""YourSecKey"";
    String strDecryptedText="""";
    try {
        strDecryptedText = AESHelper.decrypt(seedValue, strEncryptedText);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return strDecryptedText;
}
</code></pre>

<p>finally you can use like as:</p>

<pre><code>String encryptedString = encryption(""Input Normal String"");
String decryptedString = decryption(""Input Encrypted String"");
</code></pre>
"
43418958,43426890,"<p>Basically there are two ways, both require a shared secret of course as markspace already mentioned in the comments.</p>

<p>One is to simply take a pseudo random number generator and seed is explicitly using a <code>SecureRandom</code> instance, e.g.</p>

<pre><code>new SecureRandom(seed);
</code></pre>

<p>where <code>seed</code> is a byte array (say, 16 bytes, the size of an AES key) representing the shared secret. As long as you synchronize the calls to the resulting instance then the values should be identical.</p>

<p>There are however a few problems with this approach:</p>

<ul>
<li>the implementation and algorithm may differ between platforms, e.g. IBM and Oracle JDK's or Android for that matter;</li>
<li>the implementation and algorithm may differ between different versions of Java;</li>
<li>the implementation and algorithm may differ between Java on different runtimes.</li>
</ul>

<p>Of course you should be able to narrow this down by using a more specific <code>getInstance</code> method, but it's unlikely that this will fully resolve the issue; I'd mostly use it - and I'm currently actually using it - for testing purposes.</p>

<hr>

<p>Another way is to use the shared secret as input to a <em>stream cipher</em> that produces a <em>key stream</em>. This key stream is generally XOR'ed with the plaintext to form the ciphertext. One of the most easy stream cipher is AES in counter mode (CTR or SIC mode). <strong>See below for an implementation that probably includes all the functions you require</strong>.</p>

<p>The problem with that approach is that the resulting key stream is just in bits, so you don't get all the goodies of the <code>SecureRandom</code> class, nor the compatibility that it provides. Unfortunately Java doesn't provide Duck typing either (where a class with the same method(s) is considered equal to another type).</p>

<p>The ways around this are two fold: either you implement <code>SecureRandomSpi</code> which handles most of the issues <em>except the seeding</em>. This will require a signing key from Oracle as you cannot use a Service Provider Implementation <em>without creating a signed provider</em>. The other way is to implement <code>SecureRandom</code> directly and override <em>all</em> methods that return random sequences (note that additional methods in future versions of Java would still not be supported). Neither is very appealing.</p>

<hr>

<p>Notes:</p>

<ul>
<li>Unfortunately I don't know of any SecureRandom PRNG's for Java that are well deterministic and well defined.</li>
<li>Note that there are secure ways to generate a shared secret on both devices as well, e.g. using Diffie-Hellman.</li>
</ul>

<hr>

<p>OK, I may need this myself, so here comes an optimized (but only limitedly tested) implementation:</p>

<pre><code>package nl.owlstead.stackoverflow;

import java.nio.ByteBuffer;
import java.util.Random;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * A well-defined pseudo-random generator that is based on a stream cipher.
 * &lt;p&gt;
 * This class mimics the {@link Random} class method signatures; it however does currently not provide:
 * &lt;ul&gt;
 * &lt;li&gt;operations returning floats or doubles including returning a Gaussian value in the range [0, 1.0) &lt;/li&gt;
 * &lt;li&gt;streams of integers or longs&lt;/li&gt;
 * &lt;/ul&gt;
 * due to laziness of the developer.
 * It does not allow for re-seeding as re-seeding is not defined for a stream cipher;
 * the same goes from retrieving a seed from the underlying entropy source as it hasn't got one.
 * &lt;p&gt;
 * It is assumed that most significant (leftmost) bytes are taken from the stream cipher first.
 * All the algorithms used to return the random values are well defined, so that compatible implementations can be generated.
 * &lt;p&gt;
 * Instances of this class are stateful and not thread safe.
 * 
 * @author Maarten Bodewes
 */
public class StreamCipherPseudoRandom {

    private static final long TWO_POW_48 = 1L &lt;&lt; 48;

    private final Cipher streamCipher;

    // must be a buffer of at least 6 bytes
    // a buffer that is x times 16 is probably most efficient for AES/CTR mode encryption within getBytes(byte[])
    private final ByteBuffer zeros = ByteBuffer.allocate(64);

    /**
     * Creates a SecureRandom from a stream cipher.
     * 
     * @param streamCipher an initialized stream cipher
     * @throws NullPointerException if the cipher is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalStateException if the cipher is not initialized
     * @throws IllegalArgumentException if the cipher is not a stream cipher
     */
    public StreamCipherPseudoRandom(final Cipher streamCipher) {
        if (streamCipher.getOutputSize(1) != 1) {
            throw new IllegalArgumentException(""Not a stream cipher"");
        }
        this.streamCipher = streamCipher;
    }

    /**
     * Generates a pseudo-random number of bytes by taking exactly the required number of bytes from the stream cipher.
     * 
     * @param data the buffer to be randomized
     */
    public void nextBytes(final byte[] data) {
        generateRandomInBuffer(ByteBuffer.wrap(data));
    }

    /**
     * Generates a pseudo-random boolean value by taking exactly 1 byte from the stream cipher,
     * returning true if and only if the returned value is odd (i.e. if the least significant bit is set to 1), false otherwise.
     * 
     * @return the random boolean
     */
    public boolean nextBoolean() {
        return (generateRandomInBuffer(ByteBuffer.allocate(Byte.BYTES)).get() &amp; 1) == 1;
    }

    /**
     * Generates a pseudo-random &lt;code&gt;int&lt;/code&gt; value by taking exactly 4 bytes from the stream cipher.
     * 
     * @return the random &lt;code&gt;int&lt;/code&gt; value
     */
    public int nextInt() {
        return generateRandomInBuffer(ByteBuffer.allocate(Integer.BYTES)).getInt();
    }

    /**
     * Generates a pseudo-random &lt;code&gt;long&lt;/code&gt; value by taking exactly 8 bytes from the stream cipher.
     * 
     * @return the random &lt;code&gt;long&lt;/code&gt; value
     */
    public long nextLong() {
        return generateRandomInBuffer(ByteBuffer.allocate(Long.BYTES)).getLong();
    }

    /**
     * Generates a pseudo-random &lt;code&gt;int&lt;/code&gt; value with &lt;code&gt;bits&lt;/code&gt; random bits in the lower part of the returned integer.
     * This method takes the minimum number of bytes required to hold the required number of bits from the stream cipher (e.g. 13 bits requires 2 bytes to hold them).
     * 
     * @param bits the number of bits in the integer, between 0 and 32 
     * @return the random &lt;code&gt;int&lt;/code&gt; value in the range [0, 2^n) where n is the number of bits
     */
    public int next(final int bits) {
        final int bytes = (bits + Byte.SIZE - 1) / Byte.SIZE;
        final ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES);
        buf.position(Integer.BYTES - bytes);
        generateRandomInBuffer(buf);
        final long l = buf.getInt(0);
        final long m = (1L &lt;&lt; bits) - 1;
        return (int) (l &amp; m);
    }

    /**
     * Generates a pseudo-random &lt;code&gt;int&lt;/code&gt; value in a range [0, n) by:
     * 
     * &lt;ol&gt;
     * &lt;li&gt;taking 6 bytes from the stream cipher and converting it into a number y&lt;/li&gt;
     * &lt;li&gt;restart the procedure if y is larger than x * n where x is the largest value such that x * n &lt;= 2^48
     * &lt;li&gt;return y % n
     * &lt;/ol&gt;
     * 
     * An exception to this rule is for n is 1 in which case this method direct returns 0, without taking any bytes from the stream cipher.

     * @param n the maximum value (exclusive) - n must be a non-zero positive number
     * @return the random &lt;code&gt;int&lt;/code&gt; value in the range [0, n)
     * @throws IllegalArgumentException if n is zero or negative 
     */
    public int nextInt(final int n) {
        if (n &lt;= 0) {
            throw new IllegalArgumentException(""max cannot be negative"");
        } else if (n == 1) {
            // only one choice
            return 0;
        }

        final ByteBuffer buf = ByteBuffer.allocate(48 / Byte.SIZE);
        long maxC = TWO_POW_48 - TWO_POW_48 % n;

        long l;
        do {
            buf.clear();
            generateRandomInBuffer(buf);
            // put 16 bits into position 32 to 47
            l = (buf.getShort() &amp; 0xFFFFL) &lt;&lt; Integer.SIZE;
            // put 32 bits into position 0 to 31
            l |= buf.getInt() &amp; 0xFFFFFFFFL;
        } while (l &gt; maxC);

       return (int) (l % n);
    }

    /**
     * Retrieves random bytes from the underlying stream cipher.
     * All methods that affect the stream cipher should use this method.
     * The bytes between the position and the limit will contain the random bytes; position and limit are left unchanged.
     * &lt;p&gt;
     * The buffer may not be read only and must support setting a mark; previous marks are discarded.
     * 
     * @param buf the buffer to receive the bytes between the position and limit 
     * @return the same buffer, to allow for 
     */
    protected ByteBuffer generateRandomInBuffer(final ByteBuffer buf) {
        while (buf.hasRemaining()) {
            // clear the zeros buffer
            zeros.clear();
            // set the number of zeros to process
            zeros.limit(Math.min(buf.remaining(), zeros.capacity()));
            try {
                // process the zero's into buf (note that the input size is leading)
                buf.mark();
                streamCipher.update(zeros, buf);
            } catch (ShortBufferException e) {
                // not enough output size, which cannot be true for a stream cipher
                throw new IllegalStateException(
                        String.format(""Cipher %s not behaving as a stream cipher"", streamCipher.getAlgorithm()));
            }
        }
        buf.reset();
        return buf;
    }

    public static void main(String[] args) throws Exception {
        Cipher streamCipher = Cipher.getInstance(""AES/CTR/NoPadding"");
        // zero key and iv for demo purposes only
        SecretKey aesKey = new SecretKeySpec(new byte[24], ""AES"");
        IvParameterSpec iv = new IvParameterSpec(new byte[16]);
        streamCipher.init(Cipher.ENCRYPT_MODE, aesKey, iv);

        StreamCipherPseudoRandom rng = new StreamCipherPseudoRandom(streamCipher);
        // chosen by fair dice roll, guaranteed to be random
        System.out.println(rng.nextInt(6) + 1);
    }
}
</code></pre>

<p>Which uses about 5 seconds on my i7 laptop (balanced power setting) for the <code>nextBytes</code> method (1 GiB input array) and AES-128 in counter mode and 4 bytes for RC4. I used AES-192 above otherwise the XKCD joke doesn't work.</p>
"
42805652,42805905,"<p>As you can see <a href=""https://github.com/loopj/android-async-http/blob/master/library/src/main/java/com/loopj/android/http/AsyncHttpClient.java#L760"" rel=""nofollow noreferrer"">here</a>, <code>setSSLFactory</code> requires an object of <code>SSLFactory</code>, so you can create your own <code>MySSLFactory</code> class. In the below example I have renamed it to <code>MyCustomSSLFactory</code>. The code for <strong>SSL Validaton</strong> is in the method <code>checkServerTrusted</code> of <code>X509TrustManager</code>. You can modify it as per your need if needed.</p>

<pre><code>import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import cz.msebera.android.httpclient.HttpVersion;
import cz.msebera.android.httpclient.conn.ClientConnectionManager;
import cz.msebera.android.httpclient.conn.scheme.PlainSocketFactory;
import cz.msebera.android.httpclient.conn.scheme.Scheme;
import cz.msebera.android.httpclient.conn.scheme.SchemeRegistry;
import cz.msebera.android.httpclient.conn.ssl.SSLSocketFactory;
import cz.msebera.android.httpclient.impl.client.DefaultHttpClient;
import cz.msebera.android.httpclient.impl.conn.tsccm.ThreadSafeClientConnManager;
import cz.msebera.android.httpclient.params.BasicHttpParams;
import cz.msebera.android.httpclient.params.HttpParams;
import cz.msebera.android.httpclient.params.HttpProtocolParams;
import cz.msebera.android.httpclient.protocol.HTTP;


/**
 * Created by prerak on 15/03/2017.
 */

public class MyCustomSSLFactory extends SSLSocketFactory {
    final SSLContext sslContext = SSLContext.getInstance(""TLS"");

    /**
     * Creates a new SSL Socket Factory with the given KeyStore.
     *
     * @param truststore A KeyStore to create the SSL Socket Factory in context of
     * @throws NoSuchAlgorithmException  NoSuchAlgorithmException
     * @throws KeyManagementException    KeyManagementException
     * @throws KeyStoreException         KeyStoreException
     * @throws UnrecoverableKeyException UnrecoverableKeyException
     */
    public MyCustomSSLFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
        super(truststore);

        X509TrustManager tm = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            }

            public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                try {
                    chain[0].checkValidity();
                } catch (Exception e) {
                    throw new CertificateException(""Certificate not valid or trusted."");
                }
            }

            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }
        };

        sslContext.init(null, new TrustManager[]{tm}, null);
    }

    /**
     * Gets a KeyStore containing the Certificate
     *
     * @param cert InputStream of the Certificate
     * @return KeyStore
     */
    public static KeyStore getKeystoreOfCA(InputStream cert) {

        // Load CAs from an InputStream
        InputStream caInput = null;
        Certificate ca = null;
        try {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            caInput = new BufferedInputStream(cert);
            ca = cf.generateCertificate(caInput);
        } catch (CertificateException e1) {
            e1.printStackTrace();
        } finally {
            try {
                if (caInput != null) {
                    caInput.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = null;
        try {
            keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return keyStore;
    }

    /**
     * Gets a Default KeyStore
     *
     * @return KeyStore
     */
    public static KeyStore getKeystore() {
        KeyStore trustStore = null;
        try {
            trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
            trustStore.load(null, null);
        } catch (Throwable t) {
            t.printStackTrace();
        }
        return trustStore;
    }

    /**
     * Returns a SSlSocketFactory which trusts all certificates
     *
     * @return SSLSocketFactory
     */
    public static SSLSocketFactory getFixedSocketFactory() {
        SSLSocketFactory socketFactory;
        try {
            socketFactory = new MyCustomSSLFactory(getKeystore());
            socketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
        } catch (Throwable t) {
            t.printStackTrace();
            socketFactory = SSLSocketFactory.getSocketFactory();
        }
        return socketFactory;
    }

    /**
     * Gets a DefaultHttpClient which trusts a set of certificates specified by the KeyStore
     *
     * @param keyStore custom provided KeyStore instance
     * @return DefaultHttpClient
     */
    public static DefaultHttpClient getNewHttpClient(KeyStore keyStore) {

        try {
            SSLSocketFactory sf = new MyCustomSSLFactory(keyStore);
            SchemeRegistry registry = new SchemeRegistry();
            registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
            registry.register(new Scheme(""https"", sf, 443));

            HttpParams params = new BasicHttpParams();
            HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);
            HttpProtocolParams.setContentCharset(params, HTTP.UTF_8);

            ClientConnectionManager ccm = new ThreadSafeClientConnManager(params, registry);

            return new DefaultHttpClient(ccm, params);
        } catch (Exception e) {
            return new DefaultHttpClient();
        }
    }

    @Override
    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    /**
     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
     */
    public void fixHttpsURLConnection() {
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    }
}
</code></pre>

<p>Now you can initialise an object of <code>MyCustomSSLSocketFactory</code> by passing your custom <code>KeyStore</code> to it.</p>

<pre><code>MyCustomSSLFactory socketFactory = new MyCustomSSLFactory(keyStore);
</code></pre>

<p>And now you can set the socket factory as:</p>

<pre><code>asyncHTTPClient.setSSLSocketFactory(socketFactory);
</code></pre>
"
42416313,42417725,"<p>Hi you are not doing MD5 Encryption, you are getting the MD5 Digest of a String and then using it to generate a Key that does DESede/CBC Encryption for you. Kindly note that MD5 is not an Encryption but a Hashing Algorithm. Details <a href=""https://stackoverflow.com/questions/4948322/fundamental-difference-between-hashing-and-encryption-algorithms"">available at this Link</a></p>

<blockquote>
  <p>Hashing is one way . You can not get convert your data/ string from a hash code. Encryption is 2 way - you can decrypt again the encrypted string if you have the key with you. Encryption function transforms a text into a nonsensical ciphertext by using an encryption key, and vice versa.</p>
</blockquote>

<p>Instead of doing a <code>decipher.update(..)</code> you need a <code>doFinal(..)</code> , and also instead of converting the encrytped <code>byte[]</code> to <code>String</code>, try  returning a <code>byte[]</code> from <code>encrypt</code> and pass a <code>byte[]</code> to decrypt as parameter; the way it is meant to be use. Below should solve your problem :</p>

<pre><code>import java.security.MessageDigest;
import java.util.Arrays;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
public class Md5Encryption 
{
    private static final String ALGORITHM = ""md5"";
    private static final String DIGEST_STRING = ""HG58YZ3CR9"";
    private static final String CHARSET_UTF_8 = ""utf-8"";
    private static final String SECRET_KEY_ALGORITHM = ""DESede"";
    private static final String TRANSFORMATION_PADDING = ""DESede/CBC/PKCS5Padding"";

    /* Encryption Method */
    public byte[] encrypt(String message) throws Exception 
    { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j &lt; 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        cipher.init(Cipher.ENCRYPT_MODE, key, iv); 

        final byte[] plainTextBytes = message.getBytes(CHARSET_UTF_8); 
        final byte[] cipherText = cipher.doFinal(plainTextBytes); 

        return cipherText; 
    } 

   /* Decryption Method */
    public String decrypt(byte[]  message) throws Exception { 
        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j &lt; 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        decipher.init(Cipher.DECRYPT_MODE, key, iv); 

        final byte[] plainText = decipher.doFinal(message); 

        return new String(plainText, CHARSET_UTF_8); 
    }

    public static void main(String[] args) throws Exception {


        String text = ""TEST STRING TO ENCRYPT"";
        byte[] codedtext = new Md5Encryption().encrypt(text);
//        String codedtext = "".U$LU`8?"";
        String decodedtext = new Md5Encryption().decrypt(codedtext); 

        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array 
        System.out.println(decodedtext); // This correctly shows ""TEST STRING TO ENCRYPT"" 
    } 


}
</code></pre>
"
41270781,41270878,"<pre><code>import java.math.BigInteger;
import java.security.MessageDigest;

public class MDTest {
    public static void main(String args[]) throws Exception {
       String s=""This is 'a' test"";
       MessageDigest m=MessageDigest.getInstance(""MD5"");
       m.update(s.getBytes(),0,s.length());
       System.out.println(""MD5: ""+new BigInteger(1,m.digest()).toString(16));
   }
}
</code></pre>

<p>this prints MD5: a69bc3b6a061b79328910b8314d40e24</p>

<p>What error are you getting?</p>
"
13022717,39851163,"<p>Use the latest X509ExtendedTrustManager instead of X509Certificate as advised here: <a href=""https://stackoverflow.com/questions/14149545/java-security-cert-certificateexception-certificates-does-not-conform-to-algori"">java.security.cert.CertificateException: Certificates does not conform to algorithm constraints</a></p>

<pre><code>    package javaapplication8;

    import java.io.InputStream;
    import java.net.Socket;
    import java.net.URL;
    import java.net.URLConnection;
    import java.security.cert.CertificateException;
    import java.security.cert.X509Certificate;
    import javax.net.ssl.HostnameVerifier;
    import javax.net.ssl.HttpsURLConnection;
    import javax.net.ssl.SSLContext;
    import javax.net.ssl.SSLEngine;
    import javax.net.ssl.SSLSession;
    import javax.net.ssl.TrustManager;
    import javax.net.ssl.X509ExtendedTrustManager;

    /**
     *
     * @author hoshantm
     */
    public class JavaApplication8 {

        /**
         * @param args the command line arguments
         * @throws java.lang.Exception
         */
        public static void main(String[] args) throws Exception {
            /*
             *  fix for
             *    Exception in thread ""main"" javax.net.ssl.SSLHandshakeException:
             *       sun.security.validator.ValidatorException:
             *           PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:
             *               unable to find valid certification path to requested target
             */
            TrustManager[] trustAllCerts = new TrustManager[]{
                new X509ExtendedTrustManager() {
                    @Override
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null;
                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] certs, String authType) {
                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] certs, String authType) {
                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] xcs, String string, Socket socket) throws CertificateException {

                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] xcs, String string, Socket socket) throws CertificateException {

                    }

                    @Override
                    public void checkClientTrusted(X509Certificate[] xcs, String string, SSLEngine ssle) throws CertificateException {

                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] xcs, String string, SSLEngine ssle) throws CertificateException {

                    }

                }
            };

            SSLContext sc = SSLContext.getInstance(""SSL"");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Create all-trusting host name verifier
            HostnameVerifier allHostsValid = new HostnameVerifier() {
                @Override
                public boolean verify(String hostname, SSLSession session) {
                    return true;
                }
            };
            // Install the all-trusting host verifier
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
            /*
             * end of the fix
             */

            URL url = new URL(""https://10.52.182.224/cgi-bin/dynamic/config/panel.bmp"");
            URLConnection con = url.openConnection();
            //Reader reader = new ImageStreamReader(con.getInputStream());

            InputStream is = new URL(url.toString()).openStream();

            // Whatever you may want to do next

        }

    }
</code></pre>
"
38179237,38181016,"<p>Here is the quick way to achieve encryption using Java</p>

<p>Input.xml</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;?xml version=""1.0"" encoding=""UTF-8"" ?&gt;
&lt;document&gt;
  &lt;party&gt;
    &lt;gtin&gt;1000909090&lt;/gtin&gt;
    &lt;pos&gt;
      &lt;attrGroupMany name=""temperatureInformation""&gt;
        &lt;row&gt;
          &lt;attr name=""temperatureCode""&gt;STORADE&lt;/attr&gt;
          &lt;attrQual name=""maximumTemperature"" qual=""FAH""&gt;80&lt;/attrQual&gt;
          &lt;attrQual name=""minimumTemperature"" qual=""ABC""&gt;10&lt;/attrQual&gt;
        &lt;/row&gt;
        &lt;row&gt;
          &lt;attr name=""temperatureCode""&gt;HANDLING&lt;/attr&gt;
          &lt;attrQual name=""maximumTemperature"" qual=""XYZ""&gt;20&lt;/attrQual&gt;
          &lt;attrQual name=""minimumTemperature"" qual=""PQR""&gt;30&lt;/attrQual&gt;
        &lt;/row&gt;
      &lt;/attrGroupMany&gt;
    &lt;/pos&gt;
  &lt;/party&gt;
&lt;/document&gt;</code></pre>
</div>
</div>
</p>

<p>test.xsl</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;?xml version=""1.0"" encoding=""UTF-8"" ?&gt;
&lt;xsl:stylesheet xmlns:xsl=""http://www.w3.org/1999/XSL/Transform"" xmlns:encyptr=""sample.MD5""
exclude-result-prefixes=""encyptr"" version=""1.0""&gt;
&lt;xsl:output indent=""yes""/&gt;
&lt;xsl:template match=""document""&gt; 
    &lt;CatalogItem&gt;
        &lt;RelationshipData&gt;
            &lt;Relationship&gt;
                &lt;RelationType&gt;SUPPLIER_DATA&lt;/RelationType&gt;  
                &lt;RelatedItems&gt;      
                    &lt;xsl:for-each select=""party/pos/attrGroupMany[@name ='temperatureInformation']/row/attrQual""&gt;                       
                        &lt;RelatedItem&gt;
                            &lt;xsl:attribute name=""referenceKey""&gt;
                                &lt;xsl:value-of select=""encyptr:getMD5(concat('SUPPLIER_DATA','-',../attr[@name='temperatureCode'],'-',@name,'-',@qual,'-',.))""/&gt;
                            &lt;/xsl:attribute&gt;
                        &lt;/RelatedItem&gt;
                    &lt;/xsl:for-each&gt;
                &lt;/RelatedItems&gt;
            &lt;/Relationship&gt;
        &lt;/RelationshipData&gt;
    &lt;/CatalogItem&gt;
&lt;/xsl:template&gt; 
&lt;/xsl:stylesheet&gt;</code></pre>
</div>
</div>
</p>

<p>MD5.java</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>package sample;

import java.io.FileInputStream;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
 import java.io.File;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
public class MD5 {
    public static String getMD5(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance(""MD5"");
            byte[] messageDigest = md.digest(input.getBytes());
            BigInteger number = new BigInteger(1, messageDigest);
            String hashtext = number.toString(16);
            // Now we need to zero pad it if you actually want the full 32 chars.
            while (hashtext.length() &lt; 32) {
                hashtext = ""0"" + hashtext;
            }
            return hashtext;
        }
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
     public static void main(String[] args) throws Exception{
         if (args.length != 3) {
             System.out.println(""Usage: java XSLTransformer inputfile.xml inputfile.xsl outputfile"");
             System.exit(1);
         }
         Transformer transformer =
             TransformerFactory.newInstance().newTransformer(new StreamSource(new File(args[1])));
         transformer.transform(new StreamSource(new File(args[0])),
                               new StreamResult(new File(args[2])));
         }
 }</code></pre>
</div>
</div>
</p>

<p>Run the <code>MD5.java</code> code by passing three parameters <code>Input.xml</code> <code>test.xsl</code> and <code>output.xml</code></p>

<p>You will get the below the required xml with encrypted values:</p>

<p>output.xml</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>&lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
&lt;CatalogItem&gt;
&lt;RelationshipData&gt;
&lt;Relationship&gt;
&lt;RelationType&gt;SUPPLIER_DATA&lt;/RelationType&gt;
&lt;RelatedItems&gt;
&lt;RelatedItem referenceKey=""8c0b1e2856825c8e799904f6f780e651""/&gt;
&lt;RelatedItem referenceKey=""0700013c4df307fbe3a46ea06e2ad205""/&gt;
&lt;RelatedItem referenceKey=""4e423d8b26dc91e5166df9a4f25490d5""/&gt;
&lt;RelatedItem referenceKey=""9a9a1440c113df91314a2a26c31d39f3""/&gt;
&lt;/RelatedItems&gt;
&lt;/Relationship&gt;
&lt;/RelationshipData&gt;
&lt;/CatalogItem&gt;</code></pre>
</div>
</div>
</p>
"
37562926,37563509,"<p>Alright, so I found the solution <a href=""https://stackoverflow.com/a/2893932/3764804"">here</a>. I simply need to install an all-trusting <code>SSL</code> certificate <a href=""https://docs.oracle.com/javase/7/docs/api/javax/net/ssl/TrustManager.html"" rel=""nofollow noreferrer""><code>TrustManager</code></a>. This is not generally a good idea though but serves well for my purpose.</p>

<pre><code>import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.KeyManagementException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public class DownloadFileExample
{
    public static void download(String downloadURL) throws IOException
    {
        URL website = new URL(downloadURL);
        String fileName = ""downloaded.zip"";

        try (InputStream inputStream = website.openStream())
        {
            Files.copy(inputStream, Paths.get(fileName), StandardCopyOption.REPLACE_EXISTING);
        }
    }

    private static void trustAllCertificates() throws NoSuchAlgorithmException, KeyManagementException
    {
        TrustManager[] trustManagers = new TrustManager[]{new X509TrustManager()
        {
            public X509Certificate[] getAcceptedIssuers()
            {
                return new X509Certificate[0];
            }

            public void checkClientTrusted(
                    X509Certificate[] certs, String authType)
            {
            }

            public void checkServerTrusted(
                    X509Certificate[] certs, String authType)
            {
            }
        }};

        SSLContext sslContext = SSLContext.getInstance(""SSL"");
        sslContext.init(null, trustManagers, new SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    }

    public static void main(String[] arguments) throws IOException, NoSuchAlgorithmException, KeyManagementException
    {
        trustAllCertificates();

        String downloadURL = ""https://mh-nexus.de/downloads/HxDSetupEN.zip"";
        download(downloadURL);
    }
}
</code></pre>
"
1709441,1710112,"<p>For output as Hex-String</p>

<pre><code>import java.security.*;
public class Test {
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();
        for (int i = 0; i &lt; publicKey.length; ++i) {
            retString.append(Integer.toHexString(0x0100 + (publicKey[i] &amp; 0x00FF)).substring(1));
        }
        System.out.println(retString);
    }
}
</code></pre>

<p>For output as byte values</p>

<pre><code>import java.security.*;
public class Test {
    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();
        retString.append(""["");
        for (int i = 0; i &lt; publicKey.length; ++i) {
            retString.append(publicKey[i]);
            retString.append("", "");
        }
        retString = retString.delete(retString.length()-2,retString.length());
        retString.append(""]"");
        System.out.println(retString); //e.g. [48, 92, 48, .... , 0, 1]
    }
}
</code></pre>
"
25122287,46465836,"<p>In case someone need the answer, I finally found the answer after 2 days of google. Basically we need to use custom TrustManager to trusts the CAs in our KeyStore, this is because in Android 2.3.x, the keystore is not being properly used. Credit to <a href=""https://github.com/delgurth"" rel=""nofollow noreferrer"">https://github.com/delgurth</a> for the CustomTrustManager. </p>

<p>Please refer: <a href=""https://github.com/ikust/hello-pinnedcerts/issues/2"" rel=""nofollow noreferrer"">https://github.com/ikust/hello-pinnedcerts/issues/2</a></p>

<p><strong>KeyPinStore.java</strong></p>

<pre><code>import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.KeyManagementException;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
public class KeyPinStore {
    private static final String[] certificates = {""certificate1.crt"", ""certificate2.crt"", ""certificate3.crt"", ""certificate4.crt""};
    private static KeyPinStore instance = null;
    private SSLContext sslContext = SSLContext.getInstance(""TLS"");

    public static synchronized KeyPinStore getInstance() throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
        if (instance == null) {
            instance = new KeyPinStore();
        }
        return instance;
    }

    private KeyPinStore() throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException, KeyManagementException {
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        for (int i = 0; i &lt; certificates.length; i++) {
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            InputStream caInput = new BufferedInputStream(Application.context.getAssets().open(""certificate/"" + certificates[i]));
            Certificate ca;
            try {
                ca = cf.generateCertificate(caInput);
                System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
            } finally {
                caInput.close();
            }

            // Create a KeyStore containing our trusted CAs
            keyStore.setCertificateEntry(""ca"" + i, ca);
        }

        // Use custom trust manager to trusts the CAs in our KeyStore
        TrustManager[] trustManagers = {new CustomTrustManager(keyStore)};

        // Create an SSLContext that uses our TrustManager
        // SSLContext context = SSLContext.getInstance(""TLS"");
        sslContext.init(null, trustManagers, null);
    }

    public SSLContext getContext() {
        return sslContext;
    }
}
</code></pre>

<p><strong>CustomTrustManager.java</strong></p>

<pre><code>import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import javax.net.ssl.X509TrustManager;

/**
 * A custom X509TrustManager implementation that trusts a specified server certificate in addition
 * to those that are in the system TrustStore.
 * Also handles an out-of-order certificate chain, as is often produced by Apache's mod_ssl
 */
public class CustomTrustManager implements X509TrustManager {

  private final TrustManager[] originalTrustManagers;
  private final KeyStore trustStore;

  /**
   * @param trustStore A KeyStore containing the server certificate that should be trusted
   * @throws NoSuchAlgorithmException
   * @throws KeyStoreException
   */
  public CustomTrustManager(KeyStore trustStore) throws NoSuchAlgorithmException, KeyStoreException {
    this.trustStore = trustStore;

    final TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory.getInstance(""X509"");
    originalTrustManagerFactory.init(trustStore);

    originalTrustManagers = originalTrustManagerFactory.getTrustManagers();
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public X509Certificate[] getAcceptedIssuers() {
    return new X509Certificate[0];
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
  }


  /**
   * Given the partial or complete certificate chain provided by the peer,
   * build a certificate path to a trusted root and return if it can be validated and is trusted
   * for client SSL authentication based on the authentication type. The authentication type is
   * determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be ""RSA"".
   * Checking is case-sensitive.
   * Defers to the default trust manager first, checks the cert supplied in the ctor if that fails.
   * @param chain the server's certificate chain
   * @param authType the authentication type based on the client certificate
   * @throws java.security.cert.CertificateException
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
    try {
      for (TrustManager originalTrustManager : originalTrustManagers) {
        ((X509TrustManager) originalTrustManager).checkServerTrusted(chain, authType);
      }
    } catch(CertificateException originalException) {
      try {
        // Ordering issue?
        X509Certificate[] reorderedChain = reorderCertificateChain(chain);
        if (! Arrays.equals(chain, reorderedChain)) {
          checkServerTrusted(reorderedChain, authType);
          return;
        }
        for (int i = 0; i &lt; chain.length; i++) {
          if (validateCert(reorderedChain[i])) {
            return;
          }
        }
        throw originalException;
      } catch(Exception ex) {
        ex.printStackTrace();
        throw originalException;
      }
    }

  }

  /**
   * Checks if we have added the certificate in the trustStore, if that's the case we trust the certificate
   * @param x509Certificate the certificate to check
   * @return true if we know the certificate, false otherwise
   * @throws KeyStoreException on problems accessing the key store
   */
  private boolean validateCert(final X509Certificate x509Certificate) throws KeyStoreException {
    return trustStore.getCertificateAlias(x509Certificate) != null;
  }

  /**
   * Puts the certificate chain in the proper order, to deal with out-of-order
   * certificate chains as are sometimes produced by Apache's mod_ssl
   * @param chain the certificate chain, possibly with bad ordering
   * @return the re-ordered certificate chain
   */
  private X509Certificate[] reorderCertificateChain(X509Certificate[] chain) {

    X509Certificate[] reorderedChain = new X509Certificate[chain.length];
    List&lt;X509Certificate&gt; certificates = Arrays.asList(chain);

    int position = chain.length - 1;
    X509Certificate rootCert = findRootCert(certificates);
    reorderedChain[position] = rootCert;

    X509Certificate cert = rootCert;
    while((cert = findSignedCert(cert, certificates)) != null &amp;&amp; position &gt; 0) {
      reorderedChain[--position] = cert;
    }

    return reorderedChain;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the root certificate in a possibly out-of-order certificate chain.
   * @param certificates the certificate change, possibly out-of-order
   * @return the root certificate, if any, that was found in the list of certificates
   */
  private X509Certificate findRootCert(List&lt;X509Certificate&gt; certificates) {
    X509Certificate rootCert = null;

    for(X509Certificate cert : certificates) {
      X509Certificate signer = findSigner(cert, certificates);
      if(signer == null || signer.equals(cert)) { // no signer present, or self-signed
        rootCert = cert;
        break;
      }
    }

    return rootCert;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the first certificate in the list of certificates that is signed by the sigingCert.
   */
  private X509Certificate findSignedCert(X509Certificate signingCert, List&lt;X509Certificate&gt; certificates) {
    X509Certificate signed = null;

    for(X509Certificate cert : certificates) {
      Principal signingCertSubjectDN = signingCert.getSubjectDN();
      Principal certIssuerDN = cert.getIssuerDN();
      if(certIssuerDN.equals(signingCertSubjectDN) &amp;&amp; !cert.equals(signingCert)) {
        signed = cert;
        break;
      }
    }

    return signed;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the certificate in the list of certificates that signed the signedCert.
   */
  private X509Certificate findSigner(X509Certificate signedCert, List&lt;X509Certificate&gt; certificates) {
    X509Certificate signer = null;

    for(X509Certificate cert : certificates) {
      Principal certSubjectDN = cert.getSubjectDN();
      Principal issuerDN = signedCert.getIssuerDN();
      if(certSubjectDN.equals(issuerDN)) {
        signer = cert;
        break;
      }
    }

    return signer;
  }
}
</code></pre>

<p>To use it, just get the SSLSocketFactory and apply it, eg:</p>

<p><strong>with HttpsURLConnection</strong></p>

<pre><code>KeyPinStore keystore = KeyPinStore.getInstance();
SSLSocketFactory sslSF = keystore.getContext().getSocketFactory();
URL url = new URL(""https://certs.cac.washington.edu/CAtest/"");
HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();
urlConnection.setSSLSocketFactory(sslSF);
InputStream in = urlConnection.getInputStream();
copyInputStreamToOutputStream(in, System.out);
</code></pre>

<p><strong>with Volley</strong></p>

<pre><code>KeyPinStore keystore = KeyPinStore.getInstance();
SSLSocketFactory sslSF = keystore.getContext().getSocketFactory();
RequestQueue mRequestQueue = Volley.newRequestQueue(context, new HurlStack(null, sslSF));
</code></pre>
"
29559215,45719212,"<p>Getting the cert when the server is recognized by the app can be done using Zielu's answer. However if the server is unrecognized (e.g. self signed or signed by unknown root authority that is not contained in your JVM's keystore) you can retrieve the server's cert programmatically using <a href=""https://github.com/escline/InstallCert"" rel=""nofollow noreferrer"" title=""InstallCert"">InstallCert</a>. An abbreviated version follows: 
[Warning: as stated by others, using an untrusted cert this way should be done only if you know and trust the cert owner otherwise it is a security risk.]</p>

<pre><code>import javax.net.ssl.*;
import java.io.*;
import java.security.*;
import java.security.cert.*;

public class FetchCert {

    public static void main(String[] args) throws Exception {
        //REPLACE THIS WITH YOUR TARGET HOST NAME
        String hostname = ""example.com"";
        SSLSocketFactory factory = HttpsURLConnection.getDefaultSSLSocketFactory();

        SSLSocket socket = (SSLSocket) factory.createSocket(hostname, 443);
        try {
            socket.startHandshake();
            socket.close();
            System.out.println(""No errors, certificate is already trusted"");
            return;
        } catch (SSLException e) {
            System.out.println(""cert likely not found in keystore, will pull cert..."");
        }


        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        char[] password = ""changeit"".toCharArray();
        ks.load(null, password);

        SSLContext context = SSLContext.getInstance(""TLS"");
        TrustManagerFactory tmf =
                TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(ks);
        X509TrustManager defaultTrustManager = (X509TrustManager) tmf.getTrustManagers()[0];
        SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
        context.init(null, new TrustManager[]{tm}, null);
        factory = context.getSocketFactory();

        socket = (SSLSocket) factory.createSocket(hostname, 443);
        try {
            socket.startHandshake();
        } catch (SSLException e) {
            //we should get to here
        }
        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println(""Could not obtain server certificate chain"");
            return;
        }

        X509Certificate cert = chain[0];
        String alias = hostname;
        ks.setCertificateEntry(alias, cert);

        System.out.println(""saving file jssecacerts to working dir"");
        System.out.println(""copy this file to your jre/lib/security folder"");
        FileOutputStream fos = new FileOutputStream(""jssecacerts"");
        ks.store(fos, password);
        fos.close();
    }
    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {

        return new X509Certificate[0];  
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
}
</code></pre>
"
44047862,44048146,"<h2>Fix #1: Fixing the variable name</h2>

<p>Variable names are <a href=""https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#naming"" rel=""nofollow noreferrer"">case-sensitive</a> in Java. Your variable name is <code>desKey</code> and not <code>deskey</code>.</p>

<h2>Fix #2: Wrapping your code into a method and handling exceptions</h2>

<p>Apart from that, you must wrap your code into a method, as shown below:</p>

<pre class=""lang-java prettyprint-override""><code>import javax.crypto.*;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

public class Gen_DESAES_key {

    public static void main(String[] args) throws NoSuchAlgorithmException,
                                                  NoSuchPaddingException,
                                                  BadPaddingException,
                                                  IllegalBlockSizeException,
                                                  InvalidKeyException {

        byte[] message = ""Hello World"".getBytes();

        KeyGenerator keygenerator = KeyGenerator.getInstance(""DES"");
        SecretKey desKey = keygenerator.generateKey();

        Cipher desCipher = Cipher.getInstance(""DES/ECB/PKCS5Padding"");
        desCipher.init(Cipher.ENCRYPT_MODE, desKey);

        byte[] encryptedMessage = desCipher.doFinal(message);
        System.out.println(new String(encryptedMessage));
    }
}
</code></pre>

<p>Please mind that your code will throw a bunch of exceptions that must be handled by a <code>try</code>-<code>catch</code> block or declared in the <code>throws</code> clause of the method. For more details, refer to the <a href=""https://docs.oracle.com/javase/tutorial/essential/exceptions/"" rel=""nofollow noreferrer"">documentation</a>.</p>

<h2>Bonus #1: Using Base64</h2>

<p>To avoid some weird characters when showing the encrypted message, you can encode it with <a href=""https://en.wikipedia.org/wiki/Base64"" rel=""nofollow noreferrer"">Base64</a>. If you are using Java 8 or later, you can use <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html"" rel=""nofollow noreferrer""><code>java.util.Base64</code></a>:</p>

<pre class=""lang-java prettyprint-override""><code>System.out.println(Base64.getEncoder().encodeToString(encryptedMessage));
</code></pre>

<h2>Bonus #2: Decrypting your message</h2>

<p>To decrypt your encrypted message, use:</p>

<pre class=""lang-java prettyprint-override""><code>desCipher.init(Cipher.DECRYPT_MODE, desKey);
byte[] decryptedMessage = desCipher.doFinal(encryptedMessage);

System.out.println(new String(decryptedMessage));
</code></pre>
"
5980658,5980789,"<p>You don't need andorid for this. You can just do it in simple java. </p>

<p>Have you tried a simple java example and see if this returns the right sha1. </p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class AeSimpleSHA1 {
    private static String convertToHex(byte[] data) {
        StringBuilder buf = new StringBuilder();
        for (byte b : data) {
            int halfbyte = (b &gt;&gt;&gt; 4) &amp; 0x0F;
            int two_halfs = 0;
            do {
                buf.append((0 &lt;= halfbyte) &amp;&amp; (halfbyte &lt;= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
                halfbyte = b &amp; 0x0F;
            } while (two_halfs++ &lt; 1);
        }
        return buf.toString();
    }

    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] textBytes = text.getBytes(""iso-8859-1"");
        md.update(textBytes, 0, textBytes.length);
        byte[] sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
}
</code></pre>

<p>Also share what your expected sha1 should be. Maybe ObjectC is doing it wrong. </p>
"
2383322,6229899,"<p>This is a solution which is hard to find in working condition for Encrypt in Java and Decrypt in .Net and finally i was able to implement in one of my project,using this we can encrypt any string in java and decrypt that at .Net end using BouncyCastle API.</p>

<p>I have used Blowfish for Encryption/Decryption:</p>

<p>You can refer files etc for bouncycastle from : <a href=""http://bouncycastle.org/latest_releases.html"" rel=""nofollow"">http://bouncycastle.org/latest_releases.html</a></p>

<h3>Java code</h3>

<pre><code>  import org.bouncycastle.util.encoders.UrlBase64;
  import org.bouncycastle.crypto.engines.BlowfishEngine;
  import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
  import org.bouncycastle.crypto.params.KeyParameter;
  import org.bouncycastle.util.Strings;

  public class EncryptString
  {
public static void main(String[] args) throws Exception
{
String plain = ""UserName=\'pgupta\'&amp;Channel=\'1\'&amp;LevelID=\'1\'&amp;LevelName=\'Super Star colony\'"";
     String key = ""x-392kla%3$*1f"";
//To getBytes in UTF8 Encoding
byte[] inBytes = plain.getBytes(""UTF8"");
byte[] keyByte = key.getBytes(""UTF8""); 

PaddedBufferedBlockCipher _cipher = new PaddedBufferedBlockCipher(new BlowfishEngine());

try
{
_cipher.init(true, new KeyParameter(keyByte));

           // Determine the minimum output buffer size
byte[] outBytes = new byte[_cipher.getOutputSize(inBytes.length)];

        // 'len' is the actual size returned
     int len = _cipher.processBytes(inBytes, 0, inBytes.length, outBytes, 0);

_cipher.doFinal(outBytes,len);

         System.out.println(""encrypted: "" + new String(UrlBase64.encode(outBytes)));
}
catch(Exception e)
     {
         System.out.println(""Exception: "" + e.toString());
     }

}
  }
</code></pre>

<h3>C# Code</h3>

<pre><code>using System;
using System.Collections.Generic;
using Org.BouncyCastle.Crypto.Paddings;
using System.Text;
using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Utilities.Encoders;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto;

public class Decrypt
{  

public string Decryption(string Request)
{
            String EncryptedS = Request;

            string convertHTML = string.Empty;
String key = ConfigurationSettings.AppSettings[""EncDecKey""];//""123456789"";

byte[] keyByte = Encoding.UTF8.GetBytes(key);   
try
{
byte[] result = BouncyCastleCrypto(false, UrlBase64.Decode(EncryptedS), key);
convertHTML = Encoding.UTF8.GetString(result);
}
catch (Org.BouncyCastle.Crypto.CryptoException ex)
{
convertHTML = ""false"";

}

return convertHTML;
}

private byte[] BouncyCastleCrypto(bool forEncrypt, byte[] input, string key)
{
try
{
byte[] keyByte = Encoding.UTF8.GetBytes(key);
_PaddedBufferedBlockCipherWithlowfish.Init(forEncrypt, new KeyParameter(keyByte));
byte[] outBytes = new byte[_PaddedBufferedBlockCipherWithlowfish.GetOutputSize(input.Length)];
int len = _PaddedBufferedBlockCipherWithlowfish.ProcessBytes(input, 0, input.Length, outBytes, 0);
_PaddedBufferedBlockCipherWithlowfish.DoFinal(outBytes, len);
return outBytes;

}
catch (Org.BouncyCastle.Crypto.CryptoException ex)
{
throw new CryptoException(ex.ToString());
}
}     
}
</code></pre>

<p>Note: Please make sure to use same key at both ends.</p>
"
6547214,6553036,"<p>At last! I made it work! Thanks for all your suggestion. I would like to share the code just in case somebody get stuck like me:</p>

<p><strong>JAVA</strong></p>

<pre><code>import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt()
    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i&lt;len; i++) {
            if ((data[i]&amp;0xFF)&lt;16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i&lt;len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i &lt; padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }
}
</code></pre>

<p><strong>HOW TO USE IT (JAVA)</strong></p>

<pre><code>mcrypt = new MCrypt();
/* Encrypt */
String encrypted = MCrypt.bytesToHex( mcrypt.encrypt(""Text to Encrypt"") );
/* Decrypt */
String decrypted = new String( mcrypt.decrypt( encrypted ) );
</code></pre>

<p>====================================================</p>

<p><strong>PHP</strong></p>

<pre><code>&lt;?php 

class MCrypt
{
    private $iv = 'fedcba9876543210'; #Same as in JAVA
    private $key = '0123456789abcdef'; #Same as in JAVA


    function __construct()
    {
    }

    function encrypt($str) {

      //$key = $this-&gt;hex2bin($key);    
      $iv = $this-&gt;iv;

      $td = mcrypt_module_open('rijndael-128', '', 'cbc', $iv);

      mcrypt_generic_init($td, $this-&gt;key, $iv);
      $encrypted = mcrypt_generic($td, $str);

      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);

      return bin2hex($encrypted);
    }

    function decrypt($code) {
      //$key = $this-&gt;hex2bin($key);
      $code = $this-&gt;hex2bin($code);
      $iv = $this-&gt;iv;

      $td = mcrypt_module_open('rijndael-128', '', 'cbc', $iv);

      mcrypt_generic_init($td, $this-&gt;key, $iv);
      $decrypted = mdecrypt_generic($td, $code);

      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);

      return utf8_encode(trim($decrypted));
    }

    protected function hex2bin($hexdata) {
      $bindata = '';

      for ($i = 0; $i &lt; strlen($hexdata); $i += 2) {
        $bindata .= chr(hexdec(substr($hexdata, $i, 2)));
      }

      return $bindata;
    }

}
</code></pre>

<p><strong>HOW TO USE IT (PHP)</strong></p>

<pre><code>&lt;?php 

$mcrypt = new MCrypt();
#Encrypt
$encrypted = $mcrypt-&gt;encrypt(""Text to encrypt"");
#Decrypt
$decrypted = $mcrypt-&gt;decrypt($encrypted);
</code></pre>
"
5520640,5520786,"<p>Welcome to encryption! As mentioned DES is symmetric and requires the same key for encryption as decryption. That key needs to be the right number of bits for the cipher that you're using. For DES that's 56-bit. Before you go too far with that though, here are a few things you might want to consider:</p>

<ol>
<li>You should use a stronger encryption standard like <a href=""http://en.wikipedia.org/wiki/Advanced_Encryption_Standard"" rel=""noreferrer"">AES</a>. It's possible to break <a href=""http://en.wikipedia.org/wiki/Data_Encryption_Standard"" rel=""noreferrer"">DES</a> encryption now.</li>
<li>If you want to use a string as the key, then you should use a strong hash function like <a href=""http://en.wikipedia.org/wiki/SHA-2"" rel=""noreferrer"">SHA-256</a> against that key string. Then take as many bits from that hash output as you need for the encryption key, 128-bit is plenty sufficient for AES. Your key string should be long like you have.</li>
<li>It'll be best to use a block cipher mode that doesn't generate the same output for the same input each time. See <a href=""http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation"" rel=""noreferrer"">block cipher modes of operation</a> for info and a visualization of why ECB mode is bad.</li>
</ol>

<p>Here's a working example of using 128-bit AES encryption in CBC mode with PKCS #5 padding:</p>

<pre><code>import java.security.MessageDigest;
import java.security.SecureRandom;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class EncryptDecrypt {
    public static void main(String[] args) throws Exception {
        // here are your inputs
        String keyString = ""averylongtext!@$@#$#@$#*&amp;(*&amp;}{23432432432dsfsdf"";
        String input = ""john doe"";

        // setup AES cipher in CBC mode with PKCS #5 padding
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        // setup an IV (initialization vector) that should be
        // randomly generated for each input that's encrypted
        byte[] iv = new byte[cipher.getBlockSize()];
        new SecureRandom().nextBytes(iv);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        // hash keyString with SHA-256 and crop the output to 128-bit for key
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(keyString.getBytes());
        byte[] key = new byte[16];
        System.arraycopy(digest.digest(), 0, key, 0, key.length);
        SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");

        // encrypt
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
        byte[] encrypted = cipher.doFinal(input.getBytes(""UTF-8""));
        System.out.println(""encrypted: "" + new String(encrypted));

        // include the IV with the encrypted bytes for transport, you'll
        // need the same IV when decrypting (it's safe to send unencrypted)

        // decrypt
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        System.out.println(""decrypted: "" + new String(decrypted, ""UTF-8""));
    }
}
</code></pre>
"
3483582,4897062,"<p>For some reason hmac_init on Quercus and GAE gives errors. One solution is to use above mentioned java method and class, import it to PHP instance and call compute.</p>

<p>1) Add scr/phpgae directory id you dont have yet
2) Add phpgae.HmacSHA256 line to src/WEB-INF/services/com.caucho.QuercusModule
3) Add scr/phpgae/HmacSHA256.java to your GAE application:</p>

<p><code>
    package phpgae;</p>

<pre><code>import java.security.InvalidKeyException;

import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;

import javax.crypto.spec.SecretKeySpec;

import com.caucho.util.Base64;

import com.caucho.quercus.module.AbstractQuercusModule;

public class HmacSHA256 extends AbstractQuercusModule {

    public String compute(String baseString, String key) throws InvalidKeyException, NoSuchAlgorithmException {
        Mac mac;
        mac = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
        mac.init(secret);
        byte[] digest = mac.doFinal(baseString.getBytes());
        return Base64.encode(digest);
    }
}
</code></pre>

<p></code></p>

<p>Note I'm using SHA256 here. Eclipse compiles everything on fly, otherwise you need to complile class manually.</p>

<p>4) On PHP here is what you do:</p>

<p><code></p>

<pre><code>&lt;?php

import phpgae.HmacSHA256;

$c = new HmacSHA256;

echo $c-&gt;compute( 'your base string' ,  'your key' );

?&gt;
</code></pre>

<p></code></p>

<p>You can find more practical <a href=""http://php-apps.appspot.com/"" rel=""nofollow"">PHP on Google App Engine</a> examples from: <a href=""http://php-apps.appspot.com/"" rel=""nofollow"">http://php-apps.appspot.com/</a></p>
"
11783062,11786924,"<p>OpenSSL generally uses its own password based key derivation method, specified in <a href=""http://www.openssl.org/docs/crypto/EVP_BytesToKey.html"" rel=""noreferrer""><code>EVP_BytesToKey</code></a>, please see the code below. Furthermore, it implicitly encodes the ciphertext as base 64 over multiple lines, which would be required to send it within the body of a mail message.</p>

<p>So the result is, in pseudocode:</p>

<pre><code>salt = random(8)
keyAndIV = BytesToKey(password, salt, 48)
key = keyAndIV[0..31]
iv = keyAndIV[32..47]
ct = AES-256-CBC-encrypt(key, iv, plaintext)
res = base64MimeEncode(""Salted__"" | salt | ct))
</code></pre>

<p>and the decryption therefore is:</p>

<pre><code>(salt, ct) = base64MimeDecode(res)
key = keyAndIV[0..31]
iv = keyAndIV[32..47]
pt = AES-256-CBC-decrypt(key, iv, plaintext)
</code></pre>

<p>which can be implemented in Java like this:</p>

<pre><code>import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.List;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.bouncycastle.util.encoders.Base64;

public class OpenSSLDecryptor {
    private static final Charset ASCII = Charset.forName(""ASCII"");
    private static final int INDEX_KEY = 0;
    private static final int INDEX_IV = 1;
    private static final int ITERATIONS = 1;

    private static final int ARG_INDEX_FILENAME = 0;
    private static final int ARG_INDEX_PASSWORD = 1;

    private static final int SALT_OFFSET = 8;
    private static final int SALT_SIZE = 8;
    private static final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;

    private static final int KEY_SIZE_BITS = 256;

    /**
     * Thanks go to Ola Bini for releasing this source on his blog.
     * The source was obtained from &lt;a href=""http://olabini.com/blog/tag/evp_bytestokey/""&gt;here&lt;/a&gt; .
     */
    public static byte[][] EVP_BytesToKey(int key_len, int iv_len, MessageDigest md,
            byte[] salt, byte[] data, int count) {
        byte[][] both = new byte[2][];
        byte[] key = new byte[key_len];
        int key_ix = 0;
        byte[] iv = new byte[iv_len];
        int iv_ix = 0;
        both[0] = key;
        both[1] = iv;
        byte[] md_buf = null;
        int nkey = key_len;
        int niv = iv_len;
        int i = 0;
        if (data == null) {
            return both;
        }
        int addmd = 0;
        for (;;) {
            md.reset();
            if (addmd++ &gt; 0) {
                md.update(md_buf);
            }
            md.update(data);
            if (null != salt) {
                md.update(salt, 0, 8);
            }
            md_buf = md.digest();
            for (i = 1; i &lt; count; i++) {
                md.reset();
                md.update(md_buf);
                md_buf = md.digest();
            }
            i = 0;
            if (nkey &gt; 0) {
                for (;;) {
                    if (nkey == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    key[key_ix++] = md_buf[i];
                    nkey--;
                    i++;
                }
            }
            if (niv &gt; 0 &amp;&amp; i != md_buf.length) {
                for (;;) {
                    if (niv == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    iv[iv_ix++] = md_buf[i];
                    niv--;
                    i++;
                }
            }
            if (nkey == 0 &amp;&amp; niv == 0) {
                break;
            }
        }
        for (i = 0; i &lt; md_buf.length; i++) {
            md_buf[i] = 0;
        }
        return both;
    }


    public static void main(String[] args) {
        try {
            // --- read base 64 encoded file ---

            File f = new File(args[ARG_INDEX_FILENAME]);
            List&lt;String&gt; lines = Files.readAllLines(f.toPath(), ASCII);
            StringBuilder sb = new StringBuilder();
            for (String line : lines) {
                sb.append(line.trim());
            }
            String dataBase64 = sb.toString();
            byte[] headerSaltAndCipherText = Base64.decode(dataBase64);

            // --- extract salt &amp; encrypted ---

            // header is ""Salted__"", ASCII encoded, if salt is being used (the default)
            byte[] salt = Arrays.copyOfRange(
                    headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);
            byte[] encrypted = Arrays.copyOfRange(
                    headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);

            // --- specify cipher and digest for EVP_BytesToKey method ---

            Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            MessageDigest md5 = MessageDigest.getInstance(""MD5"");

            // --- create key and IV  ---

            // the IV is useless, OpenSSL might as well have use zero's
            final byte[][] keyAndIV = EVP_BytesToKey(
                    KEY_SIZE_BITS / Byte.SIZE,
                    aesCBC.getBlockSize(),
                    md5,
                    salt,
                    args[ARG_INDEX_PASSWORD].getBytes(ASCII),
                    ITERATIONS);
            SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], ""AES"");
            IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);

            // --- initialize cipher instance and decrypt ---

            aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
            byte[] decrypted = aesCBC.doFinal(encrypted);

            String answer = new String(decrypted, ASCII);
            System.out.println(answer);
        } catch (BadPaddingException e) {
            // AKA ""something went wrong""
            throw new IllegalStateException(
                    ""Bad password, algorithm, mode or padding;"" +
                    "" no salt, wrong number of iterations or corrupted ciphertext."");
        } catch (IllegalBlockSizeException e) {
            throw new IllegalStateException(
                    ""Bad algorithm, mode or corrupted (resized) ciphertext."");
        } catch (GeneralSecurityException e) {
            throw new IllegalStateException(e);
        } catch (IOException e) {
            throw new IllegalStateException(e);
        }
    }        
}
</code></pre>

<p>Beware that the code specifies ASCII as character set. The character set used may differ for your application / terminal / OS.</p>

<hr>

<p>In general you should force OpenSSL to use the NIST approved PBKDF2 algorithm, as using the OpenSSL key derivation method - with an iteration count of 1 - is insecure. This may force you to use a different solution than OpenSSL. Note that password based encryption is inherently rather insecure - passwords are much less secure than randomly generated symmetric keys.</p>

<hr>

<p><a href=""https://stackoverflow.com/q/39637388/608639"">OpenSSL 1.1.0c changed the digest algorithm</a> used in some internal components. Formerly, MD5 was used, and 1.1.0 switched to SHA256. Be careful the change is not affecting you in both <code>EVP_BytesToKey</code> and commands like <code>openssl enc</code>.</p>

<p>It's probably best to explicitly specify the digest in the command line interface (e.g. <code>-md md5</code> for backwards compatibility or <code>sha-256</code> for forwards compatibility) for the and make sure that the Java code uses the same digest algorithm (<code>""MD5""</code> or <code>""SHA-256""</code> including the dash). Also see the information <a href=""https://stackoverflow.com/a/54173509/589259"">in this answer</a>.</p>
"
992019,10128606,"<p>After reading through erickson's suggestions, and gleaning what I could from a couple other postings and this example <a href=""http://cs.saddleback.edu/rwatkins/CS4B/Crypto/FileEncryptor.html"" rel=""noreferrer"">here</a>, I've attempted to update Doug's code with the recommended changes. Feel free to edit to make it better.</p>

<ul>
<li>Initialization Vector is no longer fixed</li>
<li>encryption key is derived using code from erickson</li>
<li>8 byte salt is generated in setupEncrypt() using SecureRandom()</li>
<li>decryption key is generated from the encryption salt and password</li>
<li>decryption cipher is generated from decryption key and initialization vector</li>
<li>removed hex twiddling in lieu of org.apache.commons <a href=""http://commons.apache.org/codec/download_codec.cgi"" rel=""noreferrer"">codec</a> Hex routines</li>
</ul>

<p>Some notes: This uses a 128 bit encryption key - java apparently won't do 256 bit encryption out-of-the-box. Implementing 256 requires installing some extra files into the java install directory. </p>

<p>Also, I'm not a crypto person. Take heed.</p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;
import java.security.spec.KeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;

public class Crypto
{
    String mPassword = null;
    public final static int SALT_LEN = 8;
    byte [] mInitVec = null;
    byte [] mSalt = null;
    Cipher mEcipher = null;
    Cipher mDecipher = null;
    private final int KEYLEN_BITS = 128; // see notes below where this is used.
    private final int ITERATIONS = 65536;
    private final int MAX_FILE_BUF = 1024;

    /**
     * create an object with just the passphrase from the user. Don't do anything else yet 
     * @param password
     */
    public Crypto (String password)
    {
        mPassword = password;
    }

    /**
     * return the generated salt for this object
     * @return
     */
    public byte [] getSalt ()
    {
        return (mSalt);
    }

    /**
     * return the initialization vector created from setupEncryption
     * @return
     */
    public byte [] getInitVec ()
    {
        return (mInitVec);
    }

    /**
     * debug/print messages
     * @param msg
     */
    private void Db (String msg)
    {
        System.out.println (""** Crypt ** "" + msg);
    }

    /**
     * this must be called after creating the initial Crypto object. It creates a salt of SALT_LEN bytes
     * and generates the salt bytes using secureRandom().  The encryption secret key is created 
     * along with the initialization vectory. The member variable mEcipher is created to be used
     * by the class later on when either creating a CipherOutputStream, or encrypting a buffer
     * to be written to disk.
     *  
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidParameterSpecException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     * @throws UnsupportedEncodingException
     * @throws InvalidKeyException
     */
    public void setupEncrypt () throws NoSuchAlgorithmException, 
                                                           InvalidKeySpecException, 
                                                           NoSuchPaddingException, 
                                                           InvalidParameterSpecException, 
                                                           IllegalBlockSizeException, 
                                                           BadPaddingException, 
                                                           UnsupportedEncodingException, 
                                                           InvalidKeyException
    {
        SecretKeyFactory factory = null;
        SecretKey tmp = null;

        // crate secureRandom salt and store  as member var for later use
         mSalt = new byte [SALT_LEN];
        SecureRandom rnd = new SecureRandom ();
        rnd.nextBytes (mSalt);
        Db (""generated salt :"" + Hex.encodeHexString (mSalt));

        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");

        /* Derive the key, given password and salt. 
         * 
         * in order to do 256 bit crypto, you have to muck with the files for Java's ""unlimted security""
         * The end user must also install them (not compiled in) so beware. 
         * see here:  http://www.javamex.com/tutorials/cryptography/unrestricted_policy_files.shtml
         */
        KeySpec spec = new PBEKeySpec (mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);
        tmp = factory.generateSecret (spec);
        SecretKey secret = new SecretKeySpec (tmp.getEncoded(), ""AES"");

        /* Create the Encryption cipher object and store as a member variable
         */
        mEcipher = Cipher.getInstance (""AES/CBC/PKCS5Padding"");
        mEcipher.init (Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = mEcipher.getParameters ();

        // get the initialization vectory and store as member var 
        mInitVec = params.getParameterSpec (IvParameterSpec.class).getIV();

        Db (""mInitVec is :"" + Hex.encodeHexString (mInitVec));
    }



    /**
     * If a file is being decrypted, we need to know the pasword, the salt and the initialization vector (iv). 
     * We have the password from initializing the class. pass the iv and salt here which is
     * obtained when encrypting the file initially.
     *   
     * @param initvec
     * @param salt
     * @throws NoSuchAlgorithmException
     * @throws InvalidKeySpecException
     * @throws NoSuchPaddingException
     * @throws InvalidKeyException
     * @throws InvalidAlgorithmParameterException
     * @throws DecoderException
     */
    public void setupDecrypt (String initvec, String salt) throws NoSuchAlgorithmException, 
                                                                                       InvalidKeySpecException, 
                                                                                       NoSuchPaddingException, 
                                                                                       InvalidKeyException, 
                                                                                       InvalidAlgorithmParameterException, 
                                                                                       DecoderException
    {
        SecretKeyFactory factory = null;
        SecretKey tmp = null;
        SecretKey secret = null;

        // since we pass it as a string of input, convert to a actual byte buffer here
        mSalt = Hex.decodeHex (salt.toCharArray ());
       Db (""got salt "" + Hex.encodeHexString (mSalt));

        // get initialization vector from passed string
        mInitVec = Hex.decodeHex (initvec.toCharArray ());
        Db (""got initvector :"" + Hex.encodeHexString (mInitVec));


        /* Derive the key, given password and salt. */
        // in order to do 256 bit crypto, you have to muck with the files for Java's ""unlimted security""
        // The end user must also install them (not compiled in) so beware. 
        // see here: 
      // http://www.javamex.com/tutorials/cryptography/unrestricted_policy_files.shtml
        factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(mPassword.toCharArray (), mSalt, ITERATIONS, KEYLEN_BITS);

        tmp = factory.generateSecret(spec);
        secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        /* Decrypt the message, given derived key and initialization vector. */
        mDecipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec));
    }


    /**
     * This is where we write out the actual encrypted data to disk using the Cipher created in setupEncrypt().
     * Pass two file objects representing the actual input (cleartext) and output file to be encrypted.
     * 
     * there may be a way to write a cleartext header to the encrypted file containing the salt, but I ran
     * into uncertain problems with that. 
     *  
     * @param input - the cleartext file to be encrypted
     * @param output - the encrypted data file
     * @throws IOException
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     */
    public void WriteEncryptedFile (File input, File output) throws 
                                                                                          IOException, 
                                                                                          IllegalBlockSizeException, 
                                                                                          BadPaddingException
    {
        FileInputStream fin;
        FileOutputStream fout;
        long totalread = 0;
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        fout = new FileOutputStream (output);
        fin = new FileInputStream (input);

        while ((nread = fin.read (inbuf)) &gt; 0 )
        {
            Db (""read "" + nread + "" bytes"");
            totalread += nread;

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            // and results in full blocks of MAX_FILE_BUF being written. 
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i &lt; nread; i++)
                trimbuf[i] = inbuf[i];

            // encrypt the buffer using the cipher obtained previosly
            byte [] tmp = mEcipher.update (trimbuf);

            // I don't think this should happen, but just in case..
            if (tmp != null)
                fout.write (tmp);
        }

        // finalize the encryption since we've done it in blocks of MAX_FILE_BUF
        byte [] finalbuf = mEcipher.doFinal ();
        if (finalbuf != null)
            fout.write (finalbuf);

        fout.flush();
        fin.close();
        fout.close();

        Db (""wrote "" + totalread + "" encrypted bytes"");
    }


    /**
     * Read from the encrypted file (input) and turn the cipher back into cleartext. Write the cleartext buffer back out
     * to disk as (output) File.
     * 
     * I left CipherInputStream in here as a test to see if I could mix it with the update() and final() methods of encrypting
     *  and still have a correctly decrypted file in the end. Seems to work so left it in.
     *  
     * @param input - File object representing encrypted data on disk 
     * @param output - File object of cleartext data to write out after decrypting
     * @throws IllegalBlockSizeException
     * @throws BadPaddingException
     * @throws IOException
     */
    public void ReadEncryptedFile (File input, File output) throws 
                                                                                                                                            IllegalBlockSizeException, 
                                                                                                                                            BadPaddingException, 
                                                                                                                                            IOException
    {
        FileInputStream fin; 
        FileOutputStream fout;
        CipherInputStream cin;
        long totalread = 0;
        int nread = 0;
        byte [] inbuf = new byte [MAX_FILE_BUF];

        fout = new FileOutputStream (output);
        fin = new FileInputStream (input);

        // creating a decoding stream from the FileInputStream above using the cipher created from setupDecrypt()
        cin = new CipherInputStream (fin, mDecipher);

        while ((nread = cin.read (inbuf)) &gt; 0 )
        {
            Db (""read "" + nread + "" bytes"");
            totalread += nread;

            // create a buffer to write with the exact number of bytes read. Otherwise a short read fills inbuf with 0x0
            byte [] trimbuf = new byte [nread];
            for (int i = 0; i &lt; nread; i++)
                trimbuf[i] = inbuf[i];

            // write out the size-adjusted buffer
            fout.write (trimbuf);
        }

        fout.flush();
        cin.close();
        fin.close ();       
        fout.close();   

        Db (""wrote "" + totalread + "" encrypted bytes"");
    }


    /**
     * adding main() for usage demonstration. With member vars, some of the locals would not be needed
     */
    public static void main(String [] args)
    {

        // create the input.txt file in the current directory before continuing
        File input = new File (""input.txt"");
        File eoutput = new File (""encrypted.aes"");
        File doutput = new File (""decrypted.txt"");
        String iv = null;
        String salt = null;
        Crypto en = new Crypto (""mypassword"");

        /*
         * setup encryption cipher using password. print out iv and salt
         */
        try
      {
          en.setupEncrypt ();
          iv = Hex.encodeHexString (en.getInitVec ()).toUpperCase ();
          salt = Hex.encodeHexString (en.getSalt ()).toUpperCase ();
      }
      catch (InvalidKeyException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchAlgorithmException e)
      {
          e.printStackTrace();
      }
      catch (InvalidKeySpecException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchPaddingException e)
      {
          e.printStackTrace();
      }
      catch (InvalidParameterSpecException e)
      {
          e.printStackTrace();
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (UnsupportedEncodingException e)
      {
          e.printStackTrace();
      }

        /*
         * write out encrypted file
         */
        try
      {
          en.WriteEncryptedFile (input, eoutput);
          System.out.printf (""File encrypted to "" + eoutput.getName () + ""\niv:"" + iv + ""\nsalt:"" + salt + ""\n\n"");
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (IOException e)
      {
          e.printStackTrace();
      }


        /*
         * decrypt file
         */
        Crypto dc = new Crypto (""mypassword"");
        try
      {
          dc.setupDecrypt (iv, salt);
      }
      catch (InvalidKeyException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchAlgorithmException e)
      {
          e.printStackTrace();
      }
      catch (InvalidKeySpecException e)
      {
          e.printStackTrace();
      }
      catch (NoSuchPaddingException e)
      {
          e.printStackTrace();
      }
      catch (InvalidAlgorithmParameterException e)
      {
          e.printStackTrace();
      }
      catch (DecoderException e)
      {
          e.printStackTrace();
      }

        /*
         * write out decrypted file
         */
        try
      {
          dc.ReadEncryptedFile (eoutput, doutput);
          System.out.println (""decryption finished to "" + doutput.getName ());
      }
      catch (IllegalBlockSizeException e)
      {
          e.printStackTrace();
      }
      catch (BadPaddingException e)
      {
          e.printStackTrace();
      }
      catch (IOException e)
      {
          e.printStackTrace();
      }
   }


}
</code></pre>
"
10842350,10843168,"<p>EDIT: As of Java 8 Java now includes an acceptable Base64 class, <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/Base64.html"" rel=""nofollow noreferrer""><code>java.util.Base64</code></a>.  </p>

<hr>

<p>This line</p>

<pre><code>String decodedText = com.sun.xml.internal.messaging.saaj.util.Base64.base64Decode(Base64EncodedText);
</code></pre>

<p>looks wrong. Instead, use the <a href=""http://commons.apache.org/codec/"" rel=""nofollow noreferrer"">apache commons codec</a> classes or the <a href=""http://iharder.sourceforge.net/current/java/base64/"" rel=""nofollow noreferrer"">Harder base64</a> class. Also the default padding used by mcrypt, zero padding, is arguably wrong and makes it difficult to use the results in other languages. The users comments section for the <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">mcrypt_encrypt web pages</a> has examples of how to do this.</p>

<p>Here is small example that uses the apache commons classes to decrypt your string.</p>

<pre><code>import java.nio.charset.Charset;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

public class AESToy3 {

    private static final Charset ASCII = Charset.forName(""US-ASCII"");

    public static void main(String[] args) throws Exception {
        String base64Cipher = ""iz1qFlQJfs6Ycp+gcc2z4w=="";
        byte [] cipherBytes = Base64.decodeBase64(base64Cipher);
        byte [] iv = ""1234567812345678"".getBytes(ASCII);
        byte [] keyBytes = ""1234567812345678"".getBytes(ASCII);

        SecretKey aesKey = new SecretKeySpec(keyBytes, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));

        byte[] result = cipher.doFinal(cipherBytes);
        System.out.println(Hex.encodeHexString(result));
    }

}
</code></pre>

<p>this produces the following output:</p>

<pre><code>5465737420737472696e670000000000
</code></pre>

<p>which when decoded as ASCII and removing the trailing zeros gives you <code>Test string</code></p>
"
11864696,11886011,"<p>In the end I went with PKCS#8 files encrypted using <code>PBEWithSHA256And256BitAES-CBC-BC</code></p>

<p><strong>Encryption:</strong></p>

<pre><code>import java.io.FileOutputStream;
import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.InvalidParameterSpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;

import org.bouncycastle.asn1.bc.BCObjectIdentifiers;

public class EncodePKCS8 {

/**
 * @param args
 * @throws NoSuchAlgorithmException 
 * @throws InvalidKeySpecException 
 * @throws NoSuchPaddingException 
 * @throws InvalidAlgorithmParameterException 
 * @throws InvalidKeyException 
 * @throws BadPaddingException 
 * @throws IllegalBlockSizeException 
 * @throws InvalidParameterSpecException 
 * @throws IOException 
 * @throws NoSuchProviderException 
 */
public static void main(String[] args) throws NoSuchAlgorithmException,
InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException,
InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException,
InvalidParameterSpecException, IOException, NoSuchProviderException
{
    // before we can do anything with BouncyCastle we have to register its provider
    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

    String password = ""Very long and complex password"";

    // generate RSA key pair
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    keyPairGenerator.initialize(2048);
    KeyPair keyPair = keyPairGenerator.genKeyPair();

    byte[] encryptedPkcs8 = encryptPrivateKey(password, keyPair);

    FileOutputStream fos = new FileOutputStream(""privkey.p8"");
    fos.write(encryptedPkcs8);
    fos.close();

    return;
}

private static byte[] encryptPrivateKey(String password, KeyPair keyPair)
    throws InvalidKeyException, NoSuchAlgorithmException, NoSuchProviderException,
    InvalidKeySpecException, NoSuchPaddingException,
    InvalidAlgorithmParameterException, IllegalBlockSizeException,
    BadPaddingException, InvalidParameterSpecException, IOException
{
    int count = 100000; // hash iteration count, best to leave at default or increase
    return encryptPrivateKey(password, keyPair, count);
}

/**
 * 
 * @param password
 * @param keyPair
 * @param count
 * @return PKCS#8 encoded, encrypted keyPair
 * @throws NoSuchAlgorithmException
 * @throws NoSuchProviderException
 * @throws InvalidKeySpecException
 * @throws NoSuchPaddingException
 * @throws InvalidKeyException
 * @throws InvalidAlgorithmParameterException
 * @throws IllegalBlockSizeException
 * @throws BadPaddingException
 * @throws InvalidParameterSpecException
 * @throws IOException
 */
private static byte[] encryptPrivateKey(String password, 
        KeyPair keyPair, int count) throws NoSuchAlgorithmException,
        NoSuchProviderException, InvalidKeySpecException,
        NoSuchPaddingException, InvalidKeyException,
        InvalidAlgorithmParameterException, IllegalBlockSizeException,
        BadPaddingException, InvalidParameterSpecException, IOException
{
    // extract the encoded private key, this is an unencrypted PKCS#8 private key
        byte[] encodedprivkey = keyPair.getPrivate().getEncoded();

        // Use a PasswordBasedEncryption (PBE) algorithm, OID of this algorithm will be saved
        // in the PKCS#8 file, so changing it (when more standard algorithm or safer
        // algorithm is available) doesn't break backwards compatibility.
        // In other words, decryptor doesn't need to know the algorithm before it will be
        // able to decrypt the PKCS#8 object.
        String encAlg = BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc.getId();

        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Create PBE parameter set
        PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());
        SecretKeyFactory keyFac = SecretKeyFactory.getInstance(encAlg, ""BC"");
        SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);

        Cipher pbeCipher = Cipher.getInstance(encAlg, ""BC"");

        // Initialize PBE Cipher with key and parameters
        pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

        // Encrypt the encoded Private Key with the PBE key
        byte[] ciphertext = pbeCipher.doFinal(encodedprivkey);

        // Now construct  PKCS #8 EncryptedPrivateKeyInfo object
        AlgorithmParameters algparms = AlgorithmParameters.getInstance(encAlg, ""BC"");
        algparms.init(pbeParamSpec);
        EncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);

        // DER encoded PKCS#8 encrypted key
        byte[] encryptedPkcs8 = encinfo.getEncoded();

        return encryptedPkcs8;
    }
}
</code></pre>

<p><strong>Decryption:</strong></p>

<pre><code>import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;
import java.security.spec.RSAPublicKeySpec;

import javax.crypto.Cipher;
import javax.crypto.EncryptedPrivateKeyInfo;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

public class DecodePKCS8 {

    /**
     * @param args
     * @throws IOException 
     * @throws NoSuchPaddingException When file is corrupted
     * @throws NoSuchAlgorithmException When no BC provider has been loaded 
     * @throws InvalidKeySpecException When decryption of file failed
     * @throws InvalidAlgorithmParameterException When file is corrupted
     * @throws InvalidKeyException When Unlimited cryptography extensions are not installed
     */
    public static void main(String[] args) throws
    IOException, NoSuchAlgorithmException, NoSuchPaddingException,
    InvalidKeySpecException, InvalidKeyException, InvalidAlgorithmParameterException
    {
        // before we can do anything with BouncyCastle we have to register its provider
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

        String password = ""Very long and complex password"";

        // read DER encoded key from files
        byte[] encodedprivkey = getFileBytes(""privkey.p8"");

        // this is a encoded PKCS#8 encrypted private key
        EncryptedPrivateKeyInfo ePKInfo = new EncryptedPrivateKeyInfo(encodedprivkey);

        // first we have to read algorithm name and parameters (salt, iterations) used
        // to encrypt the file
        Cipher cipher = Cipher.getInstance(ePKInfo.getAlgName());
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());

        SecretKeyFactory skFac = SecretKeyFactory.getInstance(ePKInfo
                .getAlgName());
        Key pbeKey = skFac.generateSecret(pbeKeySpec);

        // Extract the iteration count and the salt
        AlgorithmParameters algParams = ePKInfo.getAlgParameters();
        cipher.init(Cipher.DECRYPT_MODE, pbeKey, algParams);

        // Decrypt the encryped private key into a PKCS8EncodedKeySpec
        KeySpec pkcs8KeySpec = ePKInfo.getKeySpec(cipher);

        // Now retrieve the RSA Public and private keys by using an
        // RSA key factory.
        KeyFactory rsaKeyFac = KeyFactory.getInstance(""RSA"");
        // First get the private key
        PrivateKey rsaPriv = rsaKeyFac.generatePrivate(pkcs8KeySpec);
        // Now derive the RSA public key from the private key
        RSAPublicKeySpec rsaPubKeySpec = new RSAPublicKeySpec(((RSAKey) rsaPriv).getModulus(),
                ((RSAPrivateCrtKey) rsaPriv).getPublicExponent());
        PublicKey rsaPubKey = (RSAPublicKey) rsaKeyFac.generatePublic(rsaPubKeySpec);

    System.out.println(""Key extracted, public part: "" + rsaPubKey);
    }

    private static byte[] getFileBytes(String path)
    {
        File f = new File(path);
        int sizecontent = ((int) f.length()); // no key file will ever be bigger than 4GiB...
        byte[] data = new byte[sizecontent];
        try 
            {
            FileInputStream freader = new FileInputStream(f);
            freader.read(data, 0, sizecontent) ;
            freader.close();
            return data;
            }
        catch(IOException ioe)
        {
            System.out.println(ioe.toString());
            return null;
        }
    }
}
</code></pre>
"
11116143,11119059,"<p>I'm using openssl like Whity already mentioned. Here is my striped down example. Be aware of any character encoding, line ending, etc. This results in changed binary representation of your text data.</p>

<p><strong>PHP-RSA_SHA256-Sign:</strong></p>

<pre><code>&lt;?php

$data = ""For my current project I have to send a signature from PHP to Java application. I am using Crypt/RSA right now for signing my data."";

$private_key = &lt;&lt;&lt;EOD
-----BEGIN RSA PRIVATE KEY-----
MIIBOgIBAAJBANDiE2+Xi/WnO+s120NiiJhNyIButVu6zxqlVzz0wy2j4kQVUC4Z
RZD80IY+4wIiX2YxKBZKGnd2TtPkcJ/ljkUCAwEAAQJAL151ZeMKHEU2c1qdRKS9
sTxCcc2pVwoAGVzRccNX16tfmCf8FjxuM3WmLdsPxYoHrwb1LFNxiNk1MXrxjH3R
6QIhAPB7edmcjH4bhMaJBztcbNE1VRCEi/bisAwiPPMq9/2nAiEA3lyc5+f6DEIJ
h1y6BWkdVULDSM+jpi1XiV/DevxuijMCIQCAEPGqHsF+4v7Jj+3HAgh9PU6otj2n
Y79nJtCYmvhoHwIgNDePaS4inApN7omp7WdXyhPZhBmulnGDYvEoGJN66d0CIHra
I2SvDkQ5CmrzkW5qPaE2oO7BSqAhRZxiYpZFb5CI
-----END RSA PRIVATE KEY-----
EOD;

$binary_signature = """";

$algo = ""SHA256"";
openssl_sign($data, $binary_signature, $private_key, $algo);
print(base64_encode($binary_signature) .""\n"");

?&gt;
</code></pre>

<p>The output of base64 encoded binary signature is: </p>

<blockquote>
  <p>OnqiWnFQ2nAjOa1S57Du9jDpVr4Wp2nLdMk2FX+/qX1+SAHpVsW1JvQYqQUDlxvbTOE9vg6dlU6i3omR7KipLw==</p>
</blockquote>

<p><strong>JAVA-RSA_SHA256-Verify:</strong></p>

<pre><code>import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;

import org.apache.commons.codec.binary.Base64;

public class RsaVerify {

    public static void main(String args[]){
        String publicKey = 
//              ""-----BEGIN PUBLIC KEY-----""+
                ""MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANDiE2+Xi/WnO+s120NiiJhNyIButVu6""+
                ""zxqlVzz0wy2j4kQVUC4ZRZD80IY+4wIiX2YxKBZKGnd2TtPkcJ/ljkUCAwEAAQ=="";
//              ""-----END PUBLIC KEY-----"";

        byte[] data = ""For my current project I have to send a signature from PHP to Java application. I am using Crypt/RSA right now for signing my data."".getBytes();
        byte[] signature = Base64.decodeBase64(""OnqiWnFQ2nAjOa1S57Du9jDpVr4Wp2nLdMk2FX+/qX1+SAHpVsW1JvQYqQUDlxvbTOE9vg6dlU6i3omR7KipLw=="");

        try {
            System.out.println(verify(data, signature, publicKey));
        } catch (GeneralSecurityException e) {
            e.printStackTrace();
        }

    }

    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(Base64.decodeBase64(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }
}
</code></pre>
"
10221411,10222196,"<p><code>[B@cb7e2c</code> is not the output of your encryption.  It's the result of trying to print or call <code>toString()</code> on a byte[] object.  (For example, look at the result of <code>System.out.println(new byte[0]);</code>)  </p>

<p>Try feeding the encrypted byte[] directly back into the decryption function, and use <code>new String(dec)</code> to print the results.  If you want to view/save the encrypted data as a string, encode it as hex or base64.</p>

<p>Here's the distinction. <code>byte[]</code> means an array of bytes.  It is binary data, a series of 8 bit signed numbers. If you're used to working with ascii only, the distinction between a series of <code>byte</code>s and a <code>String</code> might seem trivial, but there are many ways to represent strings in binary.  The encryption and decryption you're doing doesn't care what the string looks like or if the data represents a string at all; it's just looking at the bits. </p>

<p>If you want to encrypt a string, you'll need to convert it to a series of bytes. At the other end, once you've decrypted the bytes that make up a the string, you'll need to convert them back.  <code>myString.getBytes()</code> and <code>new String(myBytea)</code> are often effective, but a bit sloppy since they just use default encoding.  If Alice's system used utf-8 and Bob's used utf-16, her message wouldn't make much sense to him. So it's always best to specify the character encoding using, for instance, <code>myString.getBytes(""utf-8"")</code> and <code>new String(myBytea,""utf-8"")</code>.</p>

<p>Here are a few functions from a project I'm working on, along with a demonstration <code>main</code> function:</p>

<pre><code>import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.xml.bind.DatatypeConverter;

public class RSAExample {
    private static byte[] h2b(String hex){
        return DatatypeConverter.parseHexBinary(hex);
    }
    private static String b2h(byte[] bytes){
        return DatatypeConverter.printHexBinary(bytes);
    }

    private static SecureRandom sr = new SecureRandom();

    public static KeyPair newKeyPair(int rsabits) throws NoSuchAlgorithmException {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(rsabits, sr);
        return generator.generateKeyPair();
    }

    public static byte[] pubKeyToBytes(PublicKey key){
        return key.getEncoded(); // X509 for a public key
    }
    public static byte[] privKeyToBytes(PrivateKey key){
        return key.getEncoded(); // PKCS8 for a private key
    }

    public static PublicKey bytesToPubKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(bytes));
    }
    public static PrivateKey bytesToPrivKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(bytes));
    }

    public static byte[] encryptWithPubKey(byte[] input, PublicKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return cipher.doFinal(input);
    }
    public static byte[] decryptWithPrivKey(byte[] input, PrivateKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key);
        return cipher.doFinal(input);
    }


    public static void main(String[] args) throws Exception {
        KeyPair kp = newKeyPair(1&lt;&lt;11); // 2048 bit RSA; might take a second to generate keys
        PublicKey pubKey = kp.getPublic();
        PrivateKey privKey = kp.getPrivate();
        String plainText = ""Dear Bob,\nWish you were here.\n\t--Alice"";
        byte[] cipherText = encryptWithPubKey(plainText.getBytes(""UTF-8""),pubKey);
        System.out.println(""cipherText: ""+b2h(cipherText));
        System.out.println(""plainText:"");
        System.out.println(new String(decryptWithPrivKey(cipherText,privKey),""UTF-8""));
    }
}
</code></pre>
"
13433529,18358247,"<p>Because all of this didn't help me to generate an encrypted password which was deterministic on all android devices (&gt;=2.1), I searched for another AES implementation. I found one which works for me on all devices. I'm not a security specialist, I'm not sure if the technique isn't as secure as it could be. I'm only posting the code for people who have run in the same problem that I had face before.</p>
<pre><code>import java.security.GeneralSecurityException;
import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import android.util.Log;

public class EncodeDecodeAES {


    private static final String TAG_DEBUG = &quot;TAG&quot;;
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String iv = &quot;fedcba9876543210&quot;;//Dummy iv (CHANGE IT!)
    private String SecretKey = &quot;0123456789abcdef&quot;;//Dummy secretKey (CHANGE IT!)

    public EncodeDecodeAES() {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), &quot;AES&quot;);

        try {
            cipher = Cipher.getInstance(&quot;AES/CBC/NoPadding&quot;);
        } catch (GeneralSecurityException e) {
            Log.d(TAG_DEBUG, e.getMessage());
        }
    }

    public byte[] encrypt(String text) throws Exception {
        if (text == null || text.length() == 0)
            throw new Exception(&quot;Empty string&quot;);

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(&quot;[encrypt] &quot; + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception {
        if (code == null || code.length() == 0)
            throw new Exception(&quot;Empty string&quot;);

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e) {
            Log.d(TAG_DEBUG, e.getMessage());
            throw new Exception(&quot;[decrypt] &quot; + e.getMessage());
        }
        return decrypted;
    }

    public static String bytesToHex(byte[] data) {
        if (data == null) {
            return null;
        }

        int len = data.length;
        String str = &quot;&quot;;
        for (int i = 0; i &lt; len; i++) {
            if ((data[i] &amp; 0xFF) &lt; 16)
                str = str + &quot;0&quot; + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i] &amp; 0xFF);
        }
        return str;
    }

    public static byte[] hexToBytes(String str) {
        if (str == null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i = 0; i &lt; len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);
            }
            return buffer;
        }
    }

    private static String padString(String source) {
        char paddingChar = ' ';
        int size = 16;
        int x = source.length() % size;
        int padLength = size - x;

        for (int i = 0; i &lt; padLength; i++) {
            source += paddingChar;
        }

        return source;
    }
}
</code></pre>
<p>You can use it like:</p>
<pre><code>EncodeDecodeAES aes = new EncodeDecodeAES ();
/* Encrypt */
String encrypted = EncodeDecodeAES.bytesToHex(aes.encrypt(&quot;Text to Encrypt&quot;));
/* Decrypt */
String decrypted = new String(aes.decrypt(encrypted));
</code></pre>
<p>Source: <a href=""http://www.androidsnippets.com/encrypt-decrypt-between-android-and-php"" rel=""nofollow noreferrer"">HERE</a></p>
"
18573573,18573851,"<p><strong>Look at this</strong></p>

<pre><code>import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class AesFileIo {
//    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private static final String AES_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    public AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String decrypt(String text) {

        StringBuilder stringBuilder = new StringBuilder(); 
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);
            String decryptedValue = new String(cipher.doFinal(decordedValue),""UTF-8"");
            Log.e(""decrypted Value :"",decryptedValue);
            return decryptedValue; 
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public String encrypt(String text) {
        String encryptedValue=null;
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encValue = cipher.doFinal(text.getBytes());
            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return encryptedValue;
    }
}
</code></pre>

<p><strong>How to use</strong></p>

<pre><code>public static byte[] iv = { '0', '0','0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0' };
    private static final byte[] keyValue = new byte[] { 'b', 'i', 'r', 'a', 'j', 'z', 'a', 'l', 'a', 'v', 'a', 'd', 'i', 'y', 'a', 'r' };
AesFileIo aes = new AesFileIo(keyValue, iv);
String encrypetedText = aes.encrypt(str);
String decryptedText = aes.decrypt(encrypetedText);

System.out.println(""EncrypetedText : "" + encrypetedText);
System.out.println(""DecryptedText : "" + decryptedText);
</code></pre>
"
17972024,17975379,"<p>This doesn't really answer your question, but it does provide some pointers.</p>
<p>You need to do a little digging to ensure you are decrypting in exactly the same way as PHP's <code>mcrypt()</code>. You need to make sure your key generation, encoding/decoding and cipher algorithm match exactly.</p>
<p><strong>Keys</strong></p>
<pre><code>&quot;CLp4j13gADa9AmRsqsXGJ&quot;.getBytes(&quot;UTF-8&quot;);
</code></pre>
<p>is probably not the right way to create the key source bytes. The <a href=""http://www.php.net/manual/en/function.mcrypt-encrypt.php"" rel=""nofollow noreferrer"">docs</a> seem to indicate that <code>mcrypt()</code> pads the key and data with <code>\0</code> if it isn't the right size. Note that your method produces a 168 bit key, which is not a valid key size and I'm not sure what java is going to do about it.</p>
<p><strong>Algorithm</strong><br />
Make sure the cipher mode and padding are the same. Does <code>mcrypt()</code> use ECB, CBC, something else?</p>
<p><strong>Encoding</strong><br />
Ciphers work on bytes, not Strings. Make sure your conversion between the two is the same in java and PHP.</p>
<p>Here is a reference test for CAST6 using test vectors from <a href=""https://www.rfc-editor.org/rfc/rfc2612#page-10"" rel=""nofollow noreferrer"">https://www.rfc-editor.org/rfc/rfc2612#page-10</a>. Note the key, ciphertext and plaintext are hex encoded.</p>
<pre><code>import java.security.Provider;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Hex;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class Cast6 {

    static final String KEY_ALGO = &quot;CAST6&quot;;
    static final String CIPHER_ALGO = &quot;CAST6/ECB/NOPADDING&quot;;
    
    static String keytext = &quot;2342bb9efa38542c0af75647f29f615d&quot;;
    static String plaintext = &quot;00000000000000000000000000000000&quot;;
    static String ciphertext = &quot;c842a08972b43d20836c91d1b7530f6b&quot;;
    
    static Provider bc = new BouncyCastleProvider();
    
    public static void main(String[] args) throws Exception {
        
        System.out.println(&quot;encrypting&quot;);
        String actual = encrypt();
        System.out.println(&quot;actual: &quot; + actual);
        System.out.println(&quot;expect: &quot; + ciphertext);

        System.out.println(&quot;decrypting&quot;);
        actual = decrypt();
        System.out.println(&quot;actual: &quot; + actual);
        System.out.println(&quot;expect: &quot; + plaintext);
    }

    static String encrypt() throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);
        
        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        
        byte[] input = Hex.decodeHex(plaintext.toCharArray());
        byte[] output = cipher.doFinal(input);
        String actual = Hex.encodeHexString(output);
        return actual;
    }
    

    static String decrypt() throws Exception {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);
        
        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.DECRYPT_MODE, key);
        
        byte[] output = cipher.doFinal(Hex.decodeHex(ciphertext.toCharArray()));
        
        String actual = Hex.encodeHexString(output);
        return actual;  
    }

}
</code></pre>
"
17079579,17080884,"<p><a href=""http://android-developers.blogspot.in/2013/02/using-cryptography-to-store-credentials.html"" rel=""noreferrer"">http://android-developers.blogspot.in/2013/02/using-cryptography-to-store-credentials.html</a></p>

<p><a href=""http://developer.android.com/reference/javax/crypto/SecretKeyFactory.html"" rel=""noreferrer"">http://developer.android.com/reference/javax/crypto/SecretKeyFactory.html</a></p>

<p>Check the above links. Use the below for reference.Modify the below according to your needs. </p>

<p>Usage</p>

<pre><code> try {
 DescEncrypter ec = new DescEncrypter();
 byte[] cipherText =ec.encrypt(""hi"", ""hello"");
 String enc = new String(cipherText,""UTF-8"");
 String decryp= ec.decrypt(""hi"", cipherText);
 } catch (UnsupportedEncodingException e) {
   e.printStackTrace();
}
</code></pre>

<p>DescEncrypter.java</p>

<pre><code>    import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class DescEncrypter {

    public static final int SALT_LENGTH = 20;
    public static final int PBE_ITERATION_COUNT = 200; //1024;

    private static final String PBE_ALGORITHM = ""PBEWithSHA256And256BitAES-CBC-BC"";

    //algoritmo / modo / relleno 
    private static final String CIPHER_ALGORITHM = ""AES/CBC/PKCS5Padding"";

    byte[] iv = ""1234567890asdfgh"".getBytes();

    byte[] salt = ""dfghjklpoiuytgftgyhj"".getBytes();

    public byte[] encrypt(String password, String cleartext) {

        byte[] encryptedText = null;

        try {


            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);

            //Realizamos el cifrado
            encryptedText = encryptionCipher.doFinal(cleartext.getBytes());

        } catch (Exception e) {
            e.printStackTrace();
        }

        return encryptedText;
    }

    public String decrypt(String password, byte[] encryptedText) {

        String cleartext = """";

        try {

            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simtrica
            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);

            //Realizamos el descifrado
            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);

            cleartext =  new String(decryptedText); 

        } catch (Exception e) {
            e.printStackTrace();
        }

        return cleartext;
    }      
}
</code></pre>
"
15669550,15669908,"<p><strong>DISCLAIMER</strong></p>

<p><strong>The OP (Pimp Trizkit), is the one who found <a href=""https://stackoverflow.com/a/15672400/814702"">the right solution</a></strong>. I just used his solution (with minor change) to showcase the result and to have fun. All rights reserved)</p>

<p>Also, the bytes array to hex string converting algorithm offered by the OP  is <strong>much faster</strong>, than the ones in my example code. See <a href=""https://stackoverflow.com/a/15672400/814702""><strong>his solution</strong></a> for the implementation.<br>
(For the details read the comments down below)</p>

<hr>

<p>One of the manual solutions:<br>
(<strong>Important!</strong> It was my first answer, but it's only for getting hash from the <em>text string</em>, not from the <em>hex string</em> as the OP asked. See the <strong>update</strong> below):
</p>

<pre class=""lang-java prettyprint-override""><code>import java.security.MessageDigest;

public class TestHash {

    public static void main(String[] args) throws Exception {
        String password = ""9a"";

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(password.getBytes());
        byte[] byteData = md.digest();
        // byte[] byteData = md.digest(password.getBytes());    // both updates and completes the hash computation

        // Method 1 of converting bytes to hex format
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; byteData.length; i++) {
            sb.append(Integer.toString((byteData[i] &amp; 0xFF) + 0x100, 16).substring(1));
        }

        System.out.println(""1) Hex format : "" + sb.toString());

        // Method 2 of converting bytes to hex format
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i &lt; byteData.length; i++) {
            String hex = Integer.toHexString(0xff &amp; byteData[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        System.out.println(""2) Hex format : "" + hexString.toString());      
    }
}
</code></pre>

<p>Output:</p>

<pre class=""lang-java prettyprint-override""><code>1) Hex format : e8eef065fb7295044d65b305bab18a9a645d1abf
2) Hex format : e8eef065fb7295044d65b305bab18a9a645d1abf
</code></pre>

<hr>

<p><strong>UPDATE</strong></p>

<p>Based on the <a href=""https://stackoverflow.com/a/15672400/814702"">OP found solution</a>, here is the  code, that showcases getting the SHA-1 hash from a <strong>hex string</strong> instead of a <em>text string</em>. Plus it presents several methods of manually converting byte arrays to hex string (just for fun). Sorry, I was in a mood ))</p>

<p><strong>See my comments</strong> inside the <code>main</code> method and inside different <code>bytesToHexString()</code> methods for the explanation of important moments.</p>

<pre class=""lang-java prettyprint-override""><code>import java.security.MessageDigest;
import java.math.BigInteger;
import javax.xml.bind.DatatypeConverter;

public class TestHash3 {

    public static void main(String[] args) throws Exception {
        String hexString = ""1234"";

        /*
         * NB!
         * Before passing hex string to DatatypeConverter.parseHexBinary(),
         * we need to check if the hex sting is even-length, 
         * otherwise DatatypeConverter.parseHexBinary() will throw a
         * java.lang.IllegalArgumentException: hexBinary needs to be even-length
         */
        hexString = (hexString.length() % 2 == 0) ? hexString : ""0"" + hexString;
        byte[] bytes = DatatypeConverter.parseHexBinary(hexString);

        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] byteData = md.digest(bytes);

        System.out.println(""1) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString1(byteData));
        System.out.println(""2) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString2(byteData));
        System.out.println(""3) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString3(byteData));
        System.out.println(""4) SHA-1 hash for the hex string "" + hexString + "": "" +
                            bytesToHexString4(byteData));
    }

    public static String bytesToHexString1(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            hexBuffer.append(Integer.toString((bytes[i] &amp; 0xFF) + 0x100, 16).substring(1));
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString2(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer(bytes.length * 2);
        for (byte b: bytes) {
            int n = b &amp; 0xFF;   // casting to integer to avoid problems with negative bytes
            if (n &lt; 0x10) {
                hexBuffer.append(""0"");
            }
            hexBuffer.append(Integer.toHexString(n));
        }

        return hexBuffer.toString();
    }       

    public static String bytesToHexString3(byte[] bytes) {
        StringBuffer hexBuffer = new StringBuffer();
        for (int i = 0; i &lt; bytes.length; i++) {
            String hexString = Integer.toHexString(0xff &amp; bytes[i]);
            // NB! E.g.: Integer.toHexString(0x0C) will return ""C"", not ""0C""            
            if (hexString.length() == 1) {
                hexBuffer.append('0');
            }
            hexBuffer.append(hexString);
        }

        return hexBuffer.toString();
    }

    public static String bytesToHexString4(byte[] bytes) {
        String hexString = new BigInteger(1, bytes).toString(16);

        /*
         * NB!
         * We need an even-length hex string to propely represent bytes in hexadecimal.
         * A hexadecimal representation of one byte consists of two hex digits.
         * If the value is less than 16 (dec), it is prepended with zero
         * E.g.:
         * 1  (byte)    ==&gt; 01 (hex)    // pay attention to the prepended zero
         * 15 (byte)    ==&gt; 0F (hex)
         * 16 (byte)    ==&gt; 10 (hex)    // no need to prepend
         * 255(byte)    ==&gt; FF (hex)
         *
         * BigInteger.toString(16) can return both even and odd-length hex strings.
         * E.g.:
         * byte[] bytes = {15, 16}  // two bytes
         * BigInteger(1, bytes).toString(16) will produce (NB!): f10
         * But we need (NB!): 0f10
         * So we must check if the resulting hex string is even-length,
         * and if not, prepend it with zero.
         */
        return ((hexString.length() % 2 == 0) ? hexString : ""0"" + hexString);
    }
}
</code></pre>

<p>Output:</p>

<pre class=""lang-java prettyprint-override""><code>1) SHA-1 hash for the hex string 1234: ffa76d854a2969e7b9d83868d455512fce0fd74d
2) SHA-1 hash for the hex string 1234: ffa76d854a2969e7b9d83868d455512fce0fd74d
3) SHA-1 hash for the hex string 1234: ffa76d854a2969e7b9d83868d455512fce0fd74d
4) SHA-1 hash for the hex string 1234: ffa76d854a2969e7b9d83868d455512fce0fd74d
</code></pre>

<p><br />
btw Checking if the hex string is even-length inside <code>byteToHexString4()</code> so it could be used independently.</p>

<hr>

<p><strong>UPDATE 2</strong></p>

<p>The user <a href=""https://stackoverflow.com/users/438742/kan"">@kan</a> brought one more method of converting byte array to hex string, very simple one liner and the <strong>second fastest</strong> after the OP's method.</p>

<p><a href=""http://docs.oracle.com/javase/7/docs/api/javax/xml/bind/DatatypeConverter.html#printHexBinary(byte[])"" rel=""nofollow noreferrer"">DatatypeConverter.printHexBinary(byte[] val)</a></p>
"
20929105,20929131,"<p>The following code might help you. Using this you can encrypt/decrypt strings between PHP and Android.</p>

<p>Java Part:</p>

<pre><code>import java.security.NoSuchAlgorithmException;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class MCrypt {

    private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)
    private IvParameterSpec ivspec;
    private SecretKeySpec keyspec;
    private Cipher cipher;

    private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)

    public MCrypt()
    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i&lt;len; i++) {
            if ((data[i]&amp;0xFF)&lt;16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() &lt; 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i&lt;len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i &lt; padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }
}
</code></pre>

<p>PHP Part:</p>

<pre><code>&lt;?php 

class MCrypt
{
    private $iv = 'fedcba9876543210'; #Same as in JAVA
    private $key = '0123456789abcdef'; #Same as in JAVA


    function __construct()
    {
    }

    function encrypt($str) {

      //$key = $this-&gt;hex2bin($key);    
      $iv = $this-&gt;iv;

      $td = mcrypt_module_open('rijndael-128', '', 'cbc', $iv);

      mcrypt_generic_init($td, $this-&gt;key, $iv);
      $encrypted = mcrypt_generic($td, $str);

      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);

      return bin2hex($encrypted);
    }

    function decrypt($code) {
      //$key = $this-&gt;hex2bin($key);
      $code = $this-&gt;hex2bin($code);
      $iv = $this-&gt;iv;

      $td = mcrypt_module_open('rijndael-128', '', 'cbc', $iv);

      mcrypt_generic_init($td, $this-&gt;key, $iv);
      $decrypted = mdecrypt_generic($td, $code);

      mcrypt_generic_deinit($td);
      mcrypt_module_close($td);

      return utf8_encode(trim($decrypted));
    }

    protected function hex2bin($hexdata) {
      $bindata = '';

      for ($i = 0; $i &lt; strlen($hexdata); $i += 2) {
        $bindata .= chr(hexdec(substr($hexdata, $i, 2)));
      }

      return $bindata;
    }

}
</code></pre>

<p>Usage (Java):</p>

<pre><code>mcrypt = new MCrypt();
/* Encrypt */
String encrypted = MCrypt.bytesToHex( mcrypt.encrypt(""Text to Encrypt"") );
/* Decrypt */
String decrypted = new String( mcrypt.decrypt( encrypted ) );
</code></pre>

<p>Usage (PHP):</p>

<pre><code>$mcrypt = new MCrypt();
#Encrypt
$encrypted = $mcrypt-&gt;encrypt(""Text to encrypt"");
#Decrypt
$decrypted = $mcrypt-&gt;decrypt($encrypted);
</code></pre>
"
24338108,24339146,"<p>I would like to share a piece of code.. well actually a whole class which can do what you require if you customize it to your own needs. I have used this in one of my application where I used to encrypt/decrypt a file with the generated public/private keys. Same can be applied to Strings as well.</p>

<pre><code>import java.security.*;
import java.security.spec.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.io.*;
import java.util.*;

/**
 *  This class encrypts and decrypts a file using CipherStreams
 *  and a 256-bit Rijndael key. The key is then encrypted using
 *  a 1024-bit RSA key, which is password-encrypted.
 */
public class FileEncryptorRSA {
  /**
   *    When files are encrypted, this will be appended to the end
   *    of the filename.
   */
  private static final String ENCRYPTED_FILENAME_SUFFIX="".encrypted"";

  /**
   *    When files are decrypted, this will be appended to the end
   *    of the filename.
   */
  private static final String DECRYPTED_FILENAME_SUFFIX="".decrypted"";

  /**
   *    Number of times the password will be hashed with MD5
   *    when transforming it into a TripleDES key.
   */
  private static final int ITERATIONS = 1000;

  /**
   *    FileEncryptor is started with one of three options:
   *
   *    -c: create key pair and write it to 2 files
   *    -e: encrypt a file, given as an argument
   *    -d: decrypt a file, given as an argument
   */
  public static void main (String[] args)
  throws Exception {
    if ((args.length &lt; 1) || (args.length &gt; 2)) {
      usage();
    } else if (""-c"".equals(args[0])) {
      createKey();
    } else if (""-e"".equals(args[0])) {
      encrypt(args[1]);
    } else if (""-d"".equals(args[0])) {
      decrypt(args[1]);
    } else {
      usage();
    }
  }

  private static void usage() {
    System.err.println(""Usage: java FileEncryptor -c|-e|-d [filename]"");
    System.exit(1);
  }

  /**
   *    Creates a 1024 bit RSA key and stores it to
   *    the filesystem as two files.
   */
  private static void createKey()
  throws Exception {
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    System.out.print(""Password to encrypt the private key: "");
    String password = in.readLine();
    System.out.println(""Generating an RSA keypair..."");

    // Create an RSA key
    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");
    keyPairGenerator.initialize(1024);
    KeyPair keyPair = keyPairGenerator.genKeyPair();

    System.out.println(""Done generating the keypair.\n"");

    // Now we need to write the public key out to a file
    System.out.print(""Public key filename: "");
    String publicKeyFilename = in.readLine();

    // Get the encoded form of the public key so we can
    // use it again in the future. This is X.509 by default.
    byte[] publicKeyBytes = keyPair.getPublic().getEncoded();

    // Write the encoded public key out to the filesystem
    FileOutputStream fos = new FileOutputStream(publicKeyFilename);
    fos.write(publicKeyBytes);
    fos.close();

    // Now we need to do the same thing with the private key,
    // but we need to password encrypt it as well.
    System.out.print(""Private key filename: "");
    String privateKeyFilename = in.readLine();

    // Get the encoded form. This is PKCS#8 by default.
    byte[] privateKeyBytes = keyPair.getPrivate().getEncoded();

    // Here we actually encrypt the private key
    byte[] encryptedPrivateKeyBytes =
    passwordEncrypt(password.toCharArray(),privateKeyBytes);

    fos = new FileOutputStream(privateKeyFilename);
    fos.write(encryptedPrivateKeyBytes);
    fos.close();
  }

  /**
   *    Encrypt the given file with a session key encrypted with an
   *    RSA public key which will be read in from the filesystem.
   */
  private static void encrypt(String fileInput)
  throws Exception {

    BufferedReader in = new BufferedReader
    (new InputStreamReader(System.in));
    System.out.print(""Public Key to encrypt with: "");
    String publicKeyFilename = in.readLine();

    // Load the public key bytes
    FileInputStream fis = new FileInputStream(publicKeyFilename);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    int theByte = 0;
    while ((theByte = fis.read()) != -1)
    {
      baos.write(theByte);
    }
    fis.close();

    byte[] keyBytes = baos.toByteArray();
    baos.close();

    // Turn the encoded key into a real RSA public key.
    // Public keys are encoded in X.509.
    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PublicKey publicKey = keyFactory.generatePublic(keySpec);

    // Open up an output file for the output of the encryption
    String fileOutput = fileInput + ENCRYPTED_FILENAME_SUFFIX;
    DataOutputStream output = new DataOutputStream
    (new FileOutputStream(fileOutput));

    // Create a cipher using that key to initialize it
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey);

    // Now create a new 256 bit Rijndael key to encrypt the file itself.
    // This will be the session key.
    KeyGenerator rijndaelKeyGenerator = KeyGenerator.getInstance(""Rijndael"");
    rijndaelKeyGenerator.init(256);
    System.out.println(""Generating session key..."");
    Key rijndaelKey = rijndaelKeyGenerator.generateKey();
    System.out.println(""Done generating key."");

    // Encrypt the Rijndael key with the RSA cipher
    // and write it to the beginning of the file.
    byte[] encodedKeyBytes= rsaCipher.doFinal(rijndaelKey.getEncoded());
    output.writeInt(encodedKeyBytes.length);
    output.write(encodedKeyBytes);

    // Now we need an Initialization Vector for the symmetric cipher in CBC mode
    SecureRandom random = new SecureRandom();
    byte[] iv = new byte[16];
    random.nextBytes(iv);

    // Write the IV out to the file.
    output.write(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);

    // Create the cipher for encrypting the file itself.
    Cipher symmetricCipher = Cipher.getInstance(""Rijndael/CBC/PKCS5Padding"");
    symmetricCipher.init(Cipher.ENCRYPT_MODE, rijndaelKey, spec);

    CipherOutputStream cos = new CipherOutputStream(output, symmetricCipher);

    System.out.println(""Encrypting the file..."");

    FileInputStream input = new FileInputStream(fileInput);

    theByte = 0;
    while ((theByte = input.read()) != -1)
    {
      cos.write(theByte);
    }
    input.close();
    cos.close();
    System.out.println(""File encrypted."");
    return;
  }

  /**
   *    Decrypt the given file.
   *    Start by getting the RSA private key
   *    and decrypting the session key embedded
   *    in the file. Then decrypt the file with
   *    that session key.
   */
  private static void decrypt(String fileInput)
  throws Exception {

    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    System.out.print(""Private Key to decrypt with: "");
    String privateKeyFilename = in.readLine();

    System.out.print(""Password for the private key: "");
    String password = in.readLine();

    // Load the private key bytes
    FileInputStream fis = new FileInputStream(privateKeyFilename);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    int theByte = 0;
    while ((theByte = fis.read()) != -1)
    {
      baos.write(theByte);
    }
    fis.close();

    byte[] keyBytes = baos.toByteArray();
    baos.close();

    keyBytes = passwordDecrypt(password.toCharArray(), keyBytes);

    // Turn the encoded key into a real RSA private key.
    // Private keys are encoded in PKCS#8.
    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PrivateKey privateKey = keyFactory.generatePrivate(keySpec);

    // Create a cipher using that key to initialize it
    Cipher rsaCipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");

    // Read in the encrypted bytes of the session key
    DataInputStream dis = new DataInputStream(new FileInputStream(fileInput));
    byte[] encryptedKeyBytes = new byte[dis.readInt()];
    dis.readFully(encryptedKeyBytes);

    // Decrypt the session key bytes.
    rsaCipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte[] rijndaelKeyBytes = rsaCipher.doFinal(encryptedKeyBytes);

    // Transform the key bytes into an actual key.
    SecretKey rijndaelKey = new SecretKeySpec(rijndaelKeyBytes, ""Rijndael"");

    // Read in the Initialization Vector from the file.
    byte[] iv = new byte[16];
    dis.read(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance(""Rijndael/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, rijndaelKey, spec);
    CipherInputStream cis = new CipherInputStream(dis, cipher);

    System.out.println(""Decrypting the file..."");
    FileOutputStream fos = new FileOutputStream(fileInput + DECRYPTED_FILENAME_SUFFIX);

    // Read through the file, decrypting each byte.
    theByte = 0;
    while ((theByte = cis.read()) != -1)
    {
      fos.write(theByte);
    }
    cis.close();
    fos.close();
    System.out.println(""Done."");
    return;
  }

  /**
   *    Utility method to encrypt a byte array with a given password.
   *    Salt will be the first 8 bytes of the byte array returned.
   */
  private static byte[] passwordEncrypt(char[] password, byte[] plaintext) throws Exception {

    // Create the salt.
    byte[] salt = new byte[8];
    Random random = new Random();
    random.nextBytes(salt);

    // Create a PBE key and cipher.
    PBEKeySpec keySpec = new PBEKeySpec(password);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithSHAAndTwofish-CBC"");
    SecretKey key = keyFactory.generateSecret(keySpec);
    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATIONS);
    Cipher cipher = Cipher.getInstance(""PBEWithSHAAndTwofish-CBC"");
    cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);

    // Encrypt the array
    byte[] ciphertext = cipher.doFinal(plaintext);

    // Write out the salt, then the ciphertext and return it.
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    baos.write(salt);
    baos.write(ciphertext);
    return baos.toByteArray();
  }

  /**
   *    Utility method to decrypt a byte array with a given password.
   *    Salt will be the first 8 bytes in the array passed in.
   */
  private static byte[] passwordDecrypt(char[] password, byte[] ciphertext) throws Exception {

    // Read in the salt.
    byte[] salt = new byte[8];
    ByteArrayInputStream bais = new ByteArrayInputStream(ciphertext);
    bais.read(salt,0,8);

    // The remaining bytes are the actual ciphertext.
    byte[] remainingCiphertext = new byte[ciphertext.length-8];
    bais.read(remainingCiphertext,0,ciphertext.length-8);

    // Create a PBE cipher to decrypt the byte array.
    PBEKeySpec keySpec = new PBEKeySpec(password);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBEWithSHAAndTwofish-CBC"");
    SecretKey key = keyFactory.generateSecret(keySpec);
    PBEParameterSpec paramSpec = new PBEParameterSpec(salt, ITERATIONS);
    Cipher cipher = Cipher.getInstance(""PBEWithSHAAndTwofish-CBC"");

    // Perform the actual decryption.
    cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
    return cipher.doFinal(remainingCiphertext);
  }
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p><strong><em>You will require to change Java policy of you JVM to Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction for using this code.
All related information regarding change in JAVA Policy can be found <a href=""http://www.oracle.com/technetwork/java/javase/downloads/jce-7-download-432124.html"" rel=""nofollow"">HERE</a></em></strong></p>
"
23374233,23455539,"<p>As someone already mentioned, there's not a clear way to find out which algorithms are available. So what I decided to do, is to create a helper for that.</p>

<pre><code>import android.util.Base64;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.KeySpec;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

/**
 * Created by sergi.castellsague on 04/05/2014.
 */
public class SecurityManager
{
private static final int ITERATIONS = 1000;

public enum HashMethod
{
    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }
    };

    public abstract String getHashString();

}

public static HashMethod getAppropriateHash()
{
    HashMethod method = null;

    if ( isPBKDFAvailable() )
    {
        method = HashMethod.PBKDF2;
    }
    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }
    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
    {
        method = HashMethod.SHA1;
    }

    return method;
}


private static boolean isPBKDFAvailable()
{
    try
    {
        SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
    }
    catch ( Exception notAvailable)
    {
        return false;
    }
    return true;
}

private static boolean isDigestAvailable( String method )
{
    try
    {
        MessageDigest.getInstance( method );
    }
    catch ( Exception notAvailable )
    {
        return false;
    }

    return true;
}

public static String getHashedPassword( HashMethod method, String password )
{
    String hashed;

    if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )
    {
        hashed = generatePBKDF( password );
    }
    else
    {
        hashed = password;
        for ( int i = 0; i &lt; ITERATIONS; i++ )
        {
            hashed = generateDigestPassword( password, method.getHashString() );
        }
    }

    return hashed;
}

private static String generatePBKDF( String password )
{
    // Generate a 512-bit key
    final int outputKeyLength = 512;

    char[] chars = new char[password.length()];
    password.getChars( 0, password.length(), chars, 0 );
    byte[] salt = ""salt_on_client_is_funny"".getBytes(); // In security terms, this is worthess. However, it's required.

    byte[] hashedPassBytes = new byte[0];
    try
    {
        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
        KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );

        hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();
    }
    catch ( Exception shouldNotHappen )
    {}

    return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );
}

private static String generateDigestPassword( String password, String algorithm )
{
    byte[] digest = new byte[0];
    byte[] buffer = password.getBytes();

    try {
        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
        messageDigest.reset();
        messageDigest.update( buffer );
        digest = messageDigest.digest();
    }
    catch ( NoSuchAlgorithmException ex )
    {}

    return Base64.encodeToString(digest, Base64.DEFAULT);
}
}
</code></pre>

<p>The usage is pretty simple:</p>

<pre><code>String password = ""BestPasswordEver123!!"";
SecurityManager.HashMethod hashMethod = SecurityManager.getAppropriateHash();
SecurityManager.getHashedPassword( hashMethod, password )
</code></pre>

<p>Oh, and note that depending on:</p>

<ol>
<li>Algorithm used</li>
<li>Amount of iterations</li>
<li>Device</li>
</ol>

<p><strong>The calculation, might be something from 0.5s to 10s (or more...), so you better do it in an other Thread =)</strong></p>
"
22201511,22218410,"<p>I'm not entirely sure what was wrong with my code. Maybe @ntoskrnl was right. Nevertheless I followed an example and it worked. <a href=""https://stackoverflow.com/questions/2090765/encryption-compatable-between-android-and-c-sharp"">There is the code</a> , that I followed. I'm giving the full code in here too. In case somebody needs it:</p>

<p>Java side:</p>

<pre><code>import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import android.util.Base64;
import android.util.Log;

public class Crypto {
     public static final String TAG = ""smsfwd"";

        private static Cipher aesCipher;
        private static SecretKey secretKey;
        private static IvParameterSpec ivParameterSpec;

        private static String CIPHER_TRANSFORMATION = ""AES/CBC/PKCS5Padding"";
        private static String CIPHER_ALGORITHM = ""AES"";
        // Replace me with a 16-byte key, share between Java and C#
        private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

        private static String MESSAGEDIGEST_ALGORITHM = ""MD5"";

        public Crypto(String passphrase) {
            byte[] passwordKey = encodeDigest(passphrase);

            try {
                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
            } catch (NoSuchPaddingException e) {
                Log.e(TAG, ""No such padding PKCS5"", e);
            }

            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
            ivParameterSpec = new IvParameterSpec(rawSecretKey);
        }

        public String encryptAsBase64(byte[] clearData) {
            byte[] encryptedData = encrypt(clearData);
            return  Base64.encodeToString(encryptedData, Base64.DEFAULT);
        }

        public byte[] encrypt(byte[] clearData) {
            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }

            byte[] encryptedData;
            try {
                encryptedData = aesCipher.doFinal(clearData);
            } catch (IllegalBlockSizeException e) {
                Log.e(TAG, ""Illegal block size"", e);
                return null;
            } catch (BadPaddingException e) {
                Log.e(TAG, ""Bad padding"", e);
                return null;
            }
            return encryptedData;
        }

        private byte[] encodeDigest(String text) {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
                return digest.digest(text.getBytes());
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
            }

            return null;
        }
}
</code></pre>

<p>MainActivity:</p>

<pre><code>public void clck(View v) {
        try {

            Crypto crpt = new Crypto(""MyDifficultPassw"");
            System.out.println(crpt.encryptAsBase64(""tryToEncrypt"".getBytes()));

        } catch (Exception e) {
            System.out.println(e.toString());
        }

    }
</code></pre>

<p>The outpt was : 2xrT+9gHAw4Nh9H57kluwQ==
ASP.Net side:</p>

<pre><code>protected void Page_Load(object sender, EventArgs e)
        {
                Crypto crp = new Crypto(""MyDifficultPassw"");
                string asd = crp.DecryptFromBase64(""2xrT+9gHAw4Nh9H57kluwQ=="");
        }

        public class Crypto
        {
            private ICryptoTransform rijndaelDecryptor;
            // Replace me with a 16-byte key, share between Java and C#
            private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

            public Crypto(string passphrase)
            {
                byte[] passwordKey = encodeDigest(passphrase);
                RijndaelManaged rijndael = new RijndaelManaged();
                rijndaelDecryptor = rijndael.CreateDecryptor(passwordKey, rawSecretKey);
            }

            public string Decrypt(byte[] encryptedData)
            {
                byte[] newClearData = rijndaelDecryptor.TransformFinalBlock(encryptedData, 0, encryptedData.Length);
                return Encoding.ASCII.GetString(newClearData);
            }

            public string DecryptFromBase64(string encryptedBase64)
            {
                return Decrypt(Convert.FromBase64String(encryptedBase64));
            }

            private byte[] encodeDigest(string text)
            {
                MD5CryptoServiceProvider x = new System.Security.Cryptography.MD5CryptoServiceProvider();
                byte[] data = Encoding.ASCII.GetBytes(text);
                return x.ComputeHash(data);
            }
        }

        static string DecryptStringFromBytes_Aes(byte[] cipherText, byte[] Key
, byte[] IV)
        {
            // Check arguments. 
            if (cipherText == null || cipherText.Length &lt;= 0)
                throw new ArgumentNullException(""cipherText"");
            if (Key == null || Key.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");
            if (IV == null || IV.Length &lt;= 0)
                throw new ArgumentNullException(""Key"");

            // Declare the string used to hold 
            // the decrypted text. 
            string plaintext = null;

            // Create an Aes object 
            // with the specified key and IV. 
            using (Aes aesAlg = Aes.Create())
            {
                aesAlg.Key = Key;
                aesAlg.IV = IV;
                aesAlg.Padding = PaddingMode.None;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key
, aesAlg.IV);



                // Create the streams used for decryption. 
                using (MemoryStream msDecrypt = new MemoryStream(cipherText))
                {

                    using (CryptoStream csDecrypt = new CryptoStream(msDecrypt
, decryptor, CryptoStreamMode.Read))
                    {

                        using (StreamReader srDecrypt = new StreamReader(
csDecrypt))
                        {

                            // Read the decrypted bytes from the decrypting 

                            // and place them in a string.
                            plaintext = srDecrypt.ReadToEnd();
                        }
                    }
                }

            }

            return plaintext;

        }
</code></pre>
"
6486121,20066617,"<pre><code>package com.cipher;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class Encrypt {

    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        // TODO Auto-generated method stub
String s=""You are doing encryption at deep level"";
SecureRandom sr=SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(s.getBytes());
byte[] k=new byte[128/8];
sr.nextBytes(k);
SecretKeySpec spec=new SecretKeySpec(k,""AES"");
byte[] iv={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
IvParameterSpec ivs=new IvParameterSpec(iv);
Cipher cps=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cps.init(Cipher.ENCRYPT_MODE,spec,ivs);
byte[] iv2=cps.doFinal(s.getBytes());
System.out.println(""En""+iv2);
Cipher cpr=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cpr.init(Cipher.DECRYPT_MODE, spec,ivs);
byte[] iv3=cpr.doFinal(iv2);
String ds=new String(iv3);
System.out.println(ds);


    }

}
</code></pre>
"
28622438,28624160,"<p>I think that you are making two mistakes :)</p>

<p>I've corrected your sample code to make it work :</p>

<pre><code>import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}
</code></pre>

<p>The first mistake is that you generate 2 different salts (when using the encrypt method), so encrypted/decrypted logs were differents (logical, but the decryption would still work because you are calling the decryption directly after encryption).</p>

<p>The second mistake was for the secret key. You need to generate a secret key when you are encrypting, but not decrypting. To put it more simply, it is as if i was encrypting with the password ""encrypt"" and that you are trying to decrypt it with the password ""decrypt"".</p>

<p>I would advise you to generate every random stuff (such as private key, salt etc on startup). But beware that when you'll stop your app, you won't be able to decrypt old stuff unless getting the exact same random stuff.</p>

<p>Hope I helped :)</p>

<p>Regards,</p>
"
26633349,27928360,"<p>I think I have solved this. The fundamental idea is the same than in the code in the question (avoid SSLv3 as the only protocol available), but the code performing it is different:</p>

<pre><code>import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.channels.SocketChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.net.ssl.HandshakeCompletedListener;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLParameters;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;

    /**
     * {@link javax.net.ssl.SSLSocketFactory} that doesn't allow {@code SSLv3} only connections
     * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;
     *
     * &lt;p&gt; see https://code.google.com/p/android/issues/detail?id=78187 &lt;/p&gt;
     */
    public class NoSSLv3Factory extends SSLSocketFactory {
        private final SSLSocketFactory delegate;

        public NoSSLv3Factory() {
            this.delegate = HttpsURLConnection.getDefaultSSLSocketFactory();
        }

        @Override
        public String[] getDefaultCipherSuites() {
            return delegate.getDefaultCipherSuites();
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return delegate.getSupportedCipherSuites();
        }

        private static Socket makeSocketSafe(Socket socket) {
            if (socket instanceof SSLSocket) {
                socket = new NoSSLv3SSLSocket((SSLSocket) socket);
            }
            return socket;
        }

        @Override
        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
        }

        /**
         * Created by robUx4 on 25/10/2014.
         */
        private static class DelegateSSLSocket extends SSLSocket {

            protected final SSLSocket delegate;

            DelegateSSLSocket(SSLSocket delegate) {
                this.delegate = delegate;
            }

            @Override
            public String[] getSupportedCipherSuites() {
                return delegate.getSupportedCipherSuites();
            }

            @Override
            public String[] getEnabledCipherSuites() {
                return delegate.getEnabledCipherSuites();
            }

            @Override
            public void setEnabledCipherSuites(String[] suites) {
                delegate.setEnabledCipherSuites(suites);
            }

            @Override
            public String[] getSupportedProtocols() {
                return delegate.getSupportedProtocols();
            }

            @Override
            public String[] getEnabledProtocols() {
                return delegate.getEnabledProtocols();
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                delegate.setEnabledProtocols(protocols);
            }

            @Override
            public SSLSession getSession() {
                return delegate.getSession();
            }

            @Override
            public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.addHandshakeCompletedListener(listener);
            }

            @Override
            public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
                delegate.removeHandshakeCompletedListener(listener);
            }

            @Override
            public void startHandshake() throws IOException {
                delegate.startHandshake();
            }

            @Override
            public void setUseClientMode(boolean mode) {
                delegate.setUseClientMode(mode);
            }

            @Override
            public boolean getUseClientMode() {
                return delegate.getUseClientMode();
            }

            @Override
            public void setNeedClientAuth(boolean need) {
                delegate.setNeedClientAuth(need);
            }

            @Override
            public void setWantClientAuth(boolean want) {
                delegate.setWantClientAuth(want);
            }

            @Override
            public boolean getNeedClientAuth() {
                return delegate.getNeedClientAuth();
            }

            @Override
            public boolean getWantClientAuth() {
                return delegate.getWantClientAuth();
            }

            @Override
            public void setEnableSessionCreation(boolean flag) {
                delegate.setEnableSessionCreation(flag);
            }

            @Override
            public boolean getEnableSessionCreation() {
                return delegate.getEnableSessionCreation();
            }

            @Override
            public void bind(SocketAddress localAddr) throws IOException {
                delegate.bind(localAddr);
            }

            @Override
            public synchronized void close() throws IOException {
                delegate.close();
            }

            @Override
            public void connect(SocketAddress remoteAddr) throws IOException {
                delegate.connect(remoteAddr);
            }

            @Override
            public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
                delegate.connect(remoteAddr, timeout);
            }

            @Override
            public SocketChannel getChannel() {
                return delegate.getChannel();
            }

            @Override
            public InetAddress getInetAddress() {
                return delegate.getInetAddress();
            }

            @Override
            public InputStream getInputStream() throws IOException {
                return delegate.getInputStream();
            }

            @Override
            public boolean getKeepAlive() throws SocketException {
                return delegate.getKeepAlive();
            }

            @Override
            public InetAddress getLocalAddress() {
                return delegate.getLocalAddress();
            }

            @Override
            public int getLocalPort() {
                return delegate.getLocalPort();
            }

            @Override
            public SocketAddress getLocalSocketAddress() {
                return delegate.getLocalSocketAddress();
            }

            @Override
            public boolean getOOBInline() throws SocketException {
                return delegate.getOOBInline();
            }

            @Override
            public OutputStream getOutputStream() throws IOException {
                return delegate.getOutputStream();
            }

            @Override
            public int getPort() {
                return delegate.getPort();
            }

            @Override
            public synchronized int getReceiveBufferSize() throws SocketException {
                return delegate.getReceiveBufferSize();
            }

            @Override
            public SocketAddress getRemoteSocketAddress() {
                return delegate.getRemoteSocketAddress();
            }

            @Override
            public boolean getReuseAddress() throws SocketException {
                return delegate.getReuseAddress();
            }

            @Override
            public synchronized int getSendBufferSize() throws SocketException {
                return delegate.getSendBufferSize();
            }

            @Override
            public int getSoLinger() throws SocketException {
                return delegate.getSoLinger();
            }

            @Override
            public synchronized int getSoTimeout() throws SocketException {
                return delegate.getSoTimeout();
            }

            @Override
            public boolean getTcpNoDelay() throws SocketException {
                return delegate.getTcpNoDelay();
            }

            @Override
            public int getTrafficClass() throws SocketException {
                return delegate.getTrafficClass();
            }

            @Override
            public boolean isBound() {
                return delegate.isBound();
            }

            @Override
            public boolean isClosed() {
                return delegate.isClosed();
            }

            @Override
            public boolean isConnected() {
                return delegate.isConnected();
            }

            @Override
            public boolean isInputShutdown() {
                return delegate.isInputShutdown();
            }

            @Override
            public boolean isOutputShutdown() {
                return delegate.isOutputShutdown();
            }

            @Override
            public void sendUrgentData(int value) throws IOException {
                delegate.sendUrgentData(value);
            }

            @Override
            public void setKeepAlive(boolean keepAlive) throws SocketException {
                delegate.setKeepAlive(keepAlive);
            }

            @Override
            public void setOOBInline(boolean oobinline) throws SocketException {
                delegate.setOOBInline(oobinline);
            }

            @Override
            public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
                delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
            }

            @Override
            public synchronized void setReceiveBufferSize(int size) throws SocketException {
                delegate.setReceiveBufferSize(size);
            }

            @Override
            public void setReuseAddress(boolean reuse) throws SocketException {
                delegate.setReuseAddress(reuse);
            }

            @Override
            public synchronized void setSendBufferSize(int size) throws SocketException {
                delegate.setSendBufferSize(size);
            }

            @Override
            public void setSoLinger(boolean on, int timeout) throws SocketException {
                delegate.setSoLinger(on, timeout);
            }

            @Override
            public synchronized void setSoTimeout(int timeout) throws SocketException {
                delegate.setSoTimeout(timeout);
            }

            @Override
            public void setSSLParameters(SSLParameters p) {
                delegate.setSSLParameters(p);
            }

            @Override
            public void setTcpNoDelay(boolean on) throws SocketException {
                delegate.setTcpNoDelay(on);
            }

            @Override
            public void setTrafficClass(int value) throws SocketException {
                delegate.setTrafficClass(value);
            }

            @Override
            public void shutdownInput() throws IOException {
                delegate.shutdownInput();
            }

            @Override
            public void shutdownOutput() throws IOException {
                delegate.shutdownOutput();
            }

            @Override
            public String toString() {
                return delegate.toString();
            }

            @Override
            public boolean equals(Object o) {
                return delegate.equals(o);
            }
        }

        /**
         * An {@link javax.net.ssl.SSLSocket} that doesn't allow {@code SSLv3} only connections
         * &lt;p&gt;fixes https://github.com/koush/ion/issues/386&lt;/p&gt;
         */
        private static class NoSSLv3SSLSocket extends DelegateSSLSocket {

            private NoSSLv3SSLSocket(SSLSocket delegate) {
                super(delegate);

                String canonicalName = delegate.getClass().getCanonicalName();
                if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")) {
                    // try replicate the code from HttpConnection.setupSecureSocket()
                    try {
                        Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
                        if (null != msetUseSessionTickets) {
                            msetUseSessionTickets.invoke(delegate, true);
                        }
                    } catch (NoSuchMethodException ignored) {
                    } catch (InvocationTargetException ignored) {
                    } catch (IllegalAccessException ignored) {
                    }
                }
            }

            @Override
            public void setEnabledProtocols(String[] protocols) {
                if (protocols != null &amp;&amp; protocols.length == 1 &amp;&amp; ""SSLv3"".equals(protocols[0])) {
                    // no way jose
                    // see issue https://code.google.com/p/android/issues/detail?id=78187
                    List&lt;String&gt; enabledProtocols = new ArrayList&lt;String&gt;(Arrays.asList(delegate.getEnabledProtocols()));
                    if (enabledProtocols.size() &gt; 1) {
                        enabledProtocols.remove(""SSLv3"");
                    }
                    protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
                }
                super.setEnabledProtocols(protocols);
            }
        }

    }
</code></pre>

<p>and somewhere in your code, before creating the Connection:</p>

<pre><code>    static {
    HttpsURLConnection.setDefaultSSLSocketFactory(new NoSSLv3Factory());
}
</code></pre>

<p>This code is taken from <a href=""https://code.google.com/p/android/issues/detail?id=78187"">https://code.google.com/p/android/issues/detail?id=78187</a>, where you can find a fully explanation on why this is happening in Android 4.X.</p>

<p>I've had this in production from one week and seems to have done the trick.</p>
"
26849580,26851569,"<p>Yes, you can use the same key; it is even required to use the same key. You should however never use the same key / IV combination as that is not secure. So often the IV gets prefixed to the ciphertext instead.</p>

<p>Note that the following implementation shows you how to generate the random IV without <code>SecureRandom</code>, but that's a bit disingenious as the <code>Cipher</code> class will just use the default one internally to create the IV. For CBC the IV may be known to an attacker, but the attacker should not be able to distinguish it from random data.</p>

<p>In this example the key data is simply stored within a ""constant"". Storing the key within source code may not provide enough security. Instead it is often encrypted with a public key, password, stored on a USB key, stored within a smartcard or HSM etc. etc. Key management is however a vast subject so I won't discuss it further for this answer.</p>

<p>In Java you should however use <code>SecretKey</code>/<code>SecretKeySpec</code> to create keys from known data and <code>IvParameterSpec</code> for a known IV (or Nonce).</p>

<pre><code>import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidParameterSpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AESWithStaticKeyAndRandomIV {

    private static byte[] KEY = new byte[] { (byte) 0x14, (byte) 0x0b,
            (byte) 0x41, (byte) 0xb2, (byte) 0x2a, (byte) 0x29, (byte) 0xbe,
            (byte) 0xb4, (byte) 0x06, (byte) 0x1b, (byte) 0xda, (byte) 0x66,
            (byte) 0xb6, (byte) 0x74, (byte) 0x7e, (byte) 0x14 };

    public static byte[] encrypt(byte[] plaintext) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key = new SecretKeySpec(KEY, ""AES"");
            cipher.init(Cipher.ENCRYPT_MODE, key);

            AlgorithmParameters params = cipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

            byte[] ciphertext = new byte[iv.length
                    + cipher.getOutputSize(plaintext.length)];
            System.arraycopy(iv, 0, ciphertext, 0, iv.length);
            cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
                    iv.length);
            return ciphertext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | InvalidParameterSpecException
                | ShortBufferException | IllegalBlockSizeException
                | BadPaddingException e) {
            throw new IllegalStateException(
                    ""CBC encryption with standard algorithm should never fail"",
                    e);
        }
    }

    public static byte[] decrypt(byte[] ciphertext) throws IllegalBlockSizeException,
            BadPaddingException {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKeySpec key = new SecretKeySpec(KEY, ""AES"");

            if (ciphertext.length &lt; cipher.getBlockSize()) {
                throw new IllegalArgumentException(
                        ""Ciphertext too small to contain IV"");
            }

            IvParameterSpec ivSpec = new IvParameterSpec(ciphertext, 0,
                    cipher.getBlockSize());
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

            byte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length
                    - cipher.getBlockSize())];
            cipher.doFinal(ciphertext, cipher.getBlockSize(), ciphertext.length
                    - cipher.getBlockSize(), plaintext, 0);
            return plaintext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | ShortBufferException
                | InvalidAlgorithmParameterException e) {
            throw new IllegalStateException(
                    ""CBC decryption with standard algorithm should be available"",
                    e);
        }
    }

    public static void main(String[] args) throws Exception {
           byte[] plaintext = decrypt(encrypt(""owlstead"".getBytes(StandardCharsets.UTF_8)));
           System.out.println(new String(plaintext, StandardCharsets.UTF_8));
    }
}
</code></pre>

<hr>

<p>With a key store (you have to use JCEKS for now):</p>

<pre><code>import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.security.AlgorithmParameters;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyStore;
import java.security.KeyStore.ProtectionParameter;
import java.security.KeyStore.SecretKeyEntry;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableEntryException;
import java.security.cert.CertificateException;
import java.security.spec.InvalidParameterSpecException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class AESWithStaticKeyAndRandomIV {

    private static final String KEY_ALIAS = ""secret"";

    private static byte[] KEY = new byte[] { (byte) 0x14, (byte) 0x0b,
            (byte) 0x41, (byte) 0xb2, (byte) 0x2a, (byte) 0x29, (byte) 0xbe,
            (byte) 0xb4, (byte) 0x06, (byte) 0x1b, (byte) 0xda, (byte) 0x66,
            (byte) 0xb6, (byte) 0x74, (byte) 0x7e, (byte) 0x14 };

    private static ProtectionParameter PASSWORD = new KeyStore.PasswordProtection(
            new char[] {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'});

    private final KeyStore store;

    private AESWithStaticKeyAndRandomIV(KeyStore store) {
        this.store = store;
    }

    public byte[] encrypt(byte[] plaintext) {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }
            cipher.init(Cipher.ENCRYPT_MODE, key);

            AlgorithmParameters params = cipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

            byte[] ciphertext = new byte[iv.length
                    + cipher.getOutputSize(plaintext.length)];
            System.arraycopy(iv, 0, ciphertext, 0, iv.length);
            cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
                    iv.length);
            return ciphertext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | InvalidParameterSpecException
                | ShortBufferException | IllegalBlockSizeException
                | BadPaddingException e) {
            throw new IllegalStateException(
                    ""CBC encryption with standard algorithm should never fail"",
                    e);
        }
    }

    public byte[] decrypt(byte[] ciphertext) throws IllegalBlockSizeException,
            BadPaddingException {
        try {
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }

            if (ciphertext.length &lt; cipher.getBlockSize()) {
                throw new IllegalArgumentException(
                        ""Ciphertext too small to contain IV"");
            }

            IvParameterSpec ivSpec = new IvParameterSpec(ciphertext, 0,
                    cipher.getBlockSize());
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

            byte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length
                    - cipher.getBlockSize())];
            cipher.doFinal(ciphertext, cipher.getBlockSize(), ciphertext.length
                    - cipher.getBlockSize(), plaintext, 0);
            return plaintext;
        } catch (InvalidKeyException | NoSuchAlgorithmException
                | NoSuchPaddingException | ShortBufferException
                | InvalidAlgorithmParameterException e) {
            throw new IllegalStateException(
                    ""CBC decryption with standard algorithm should be available"",
                    e);
        }
    }

    public static KeyStore createStoreWithSecretKey() {

        try {
            KeyStore keyStore = KeyStore.getInstance(""JCEKS"");
            keyStore.load(null);
            SecretKey key = new SecretKeySpec(KEY, ""AES"");
            keyStore.setEntry(KEY_ALIAS, new KeyStore.SecretKeyEntry(key), PASSWORD);
            return keyStore;
        } catch (KeyStoreException | NoSuchAlgorithmException
                | CertificateException | IOException e) {
            throw new IllegalStateException(""Unable to create key store"", e);
        }
    }

    public static void main(String[] args) throws Exception {
        AESWithStaticKeyAndRandomIV crypt = new AESWithStaticKeyAndRandomIV(
                createStoreWithSecretKey());

        byte[] plaintext = crypt.decrypt(crypt.encrypt(""owlstead""
                .getBytes(StandardCharsets.UTF_8)));
        System.out.println(new String(plaintext, StandardCharsets.UTF_8));
    }
}
</code></pre>
"
25121868,25123606,"<p>I tried to reproduce your code.</p>

<p>For the password <em>test</em> it produces the following BASE64 output</p>

<p><code>Q0Y2QkI0MTBFRUJFOTAyNkU1OUZGMUNGMzU0NkYzMkI3NDZFMzE5RjQzNTc0MDM5QjU2MUI2NEQxOTQzNzRGMDRENDM0QzMyQjg3MjMwQkM1N0I0ODFDRDlEODlBNjMxQjMyNjRGQjNBQjAwMEYwNjk5Rjc0NUNEQjgzMzY1RkM=</code></p>

<p>I used the following code:</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

//import javax.xml.bind.DatatypeConverter;
import android.util.Base64;


public class Support {

    private static final String SALT = ""3D5900AE-111A-45BE-96B3-D9E4606CA793"";
    private static final int MAX_HASH_ITERATIONS = 10;

    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String result = Support.GetPasswordHash(""test"");
        System.out.println(result);
    }

    public static String GetPasswordHash(String plaintextPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = plaintextPassword;
        for (int hashLimit = 0; hashLimit &lt; MAX_HASH_ITERATIONS; hashLimit++) {
            hashData = GetHash(SALT + hashData);
        }
        return hashData;
    }

    //Gets the hash value of the data using SHA512Managed
    private static String GetHash(String unhashedData) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        return getMD5Password(unhashedData);
    }

    //Verifies the hash
    public static boolean VerifyHashedPassword(String plaintextPassword, String encryptedPassword) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        String hashData = GetPasswordHash(plaintextPassword);
        return encryptedPassword.equals(hashData);
    }


    public static String getMD5Password(String password) throws NoSuchAlgorithmException, UnsupportedEncodingException{
        MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-512""); 
        digest.update(password.getBytes(""UTF-16LE"")); 
        byte messageDigest[] = digest.digest();

        StringBuilder sb = new StringBuilder();
        for(int iPos = 0; iPos &lt; messageDigest.length; iPos++) {
            String h = Integer.toHexString(0xFF &amp; messageDigest[iPos]);
            while (h.length() &lt; 2) {
                h = ""0"" + h;
            }
            sb.append(h);
        }

        String md5String = sb.toString().toUpperCase();     
        String res = Base64.encodeToString(md5String.getBytes(), Base64.DEFAULT);

        return res;
    }
}
</code></pre>
"
34074485,34075332,"<p><strong>Basic Layout / Top-Down Approach</strong></p>

<p>Start with what you know and put that into methods. You start with names and the stuff they need to perform. Don't think about implementation for a second, just about the flow of logic. </p>

<p>In your case, you'll need something like:</p>

<pre><code>public void createHash(File sourceDir, File targetDir)

public String createHash(File file)

public void writeHash(File toFile, String hash)
</code></pre>

<p><strong>Wrap it in main()</strong></p>

<p>You need to fill in your class-name there.</p>

<pre><code>public static void main(String[] args) {
   new YourClass().createHash(new File(args[0]), new File(args[1]));
}
</code></pre>

<p><strong>Implement Top-Down</strong></p>

<p>Start with the outermost method and try to get that right. You can start with dummy code for the rest. </p>

<pre><code>public void createHash(File sourceDir, File targetDir) {
  for(File f : sourceDir.listFiles()) {
     String hash = createHash(f); //That you almost have
     File target = new File(targetDir, f.getName()+"".hash"");
     writeHash(target, hash);
  } 
}

public String createHash(f) {
  return f.getName(); //This is where your existing code will go later
}

public String writeHash(File target, String hash) {
  System.out.println(""I'd write "" + hash + "" to File "" + file.getName());
}
</code></pre>

<p>Now your program should be able to iterate through source folder, create (dummy) hashes and print to System.out what files it would write.</p>

<p><strong>Refine methods</strong></p>

<p>Now do the rest step by step - one method at a time. Until you're done or something breaks - in which case you come back for help.</p>

<pre><code>  public String createHash(File datafile) throws IOException {
    //SNIP - YOUR CODE BEGINS
    MessageDigest md = MessageDigest.getInstance(""SHA1"");
    FileInputStream fis = new FileInputStream(datafile);
    byte[] dataBytes = new byte[1024];

    int nread = 0; 

    while ((nread = fis.read(dataBytes)) != -1) {
      md.update(dataBytes, 0, nread);
    }

    byte[] mdbytes = md.digest();

    //convert the byte to hex format
    StringBuffer sb = new StringBuffer("""");
    for (int i = 0; i &lt; mdbytes.length; i++) {
      sb.append(Integer.toString((mdbytes[i] &amp; 0xff) + 0x100, 16).substring(1));
    }
  //SNAP - YOUR CODE ENDS
  }
  public void writeFile(File target, String hash) {
     try(FileOutputStream fo = new FileOutputStream(target)) {
       fo.write(hash.getBytes());
     } catch(IOException e) {
       System.err.println(""No Hash Written for "" + target.getName());
     }
  }
</code></pre>

<p><strong>Working Example</strong></p>

<pre><code>import java.io.*;
import java.security.MessageDigest;

public class Checksums {

    public static void main(String[] args) {
        String sourceDir = ""/Users/Jan/Desktop/Folder1"";
        String targetDir = ""/Users/Jan/Desktop/Folder2"";
        try {
            new Checksums().createHash(new File(sourceDir), new File(targetDir));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void createHash(File sourceDir, File targetDir) throws Exception {
        for (File f : sourceDir.listFiles()) {
            String hash = createHash(f); // That you almost have
            File target = new File(targetDir, f.getName() + "".hash"");
            writeHash(target, hash);
        }
    }

    public String createHash(File datafile) throws Exception {
        // SNIP - YOUR CODE BEGINS
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        FileInputStream fis = new FileInputStream(datafile);
        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format
        StringBuffer sb = new StringBuffer("""");
        for (int i = 0; i &lt; mdbytes.length; i++) {
            sb.append(Integer.toString((mdbytes[i] &amp; 0xff) + 0x100, 16).substring(1));
        }
        // SNAP - YOUR CODE ENDS
        return sb.toString();
    }

    public void writeHash(File target, String hash) {
        try (FileOutputStream fo = new FileOutputStream(target)) {
            fo.write(hash.getBytes());
            System.out.println(""Hash written for "" + target.getAbsolutePath());
        } catch (IOException e) {
            System.err.println(""No Hash Written for "" + target.getName());
        }
    }

}
</code></pre>
"
31432218,31433753,"<p>Found the solution from Artjom.</p>

<pre><code>import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.InvalidCipherTextException;
import org.bouncycastle.crypto.engines.RijndaelEngine;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.paddings.ZeroBytePadding;
import org.bouncycastle.crypto.params.KeyParameter;

import java.nio.charset.Charset;

public class Encrypt {
    public static void main(String[] args) throws InvalidCipherTextException {
        String key = ""b1U995YFbERWuzO72GmKSBWpACVIb3L9"";
        String data = ""sellerid=Company&amp;returnsreference=0003&amp;contents_value=101&amp;contents_description=clothes&amp;fullname=Joe%20Bloggs&amp;company=Company&amp;email=joe.bloggs@gmail.com&amp;email_confirm=joe.bloggs@gmail.com&amp;telephone=123&amp;address_line_1=1&amp;city=Acampo&amp;postcode=952200001&amp;country_code=US&amp;weight=1&amp;height=2&amp;length=3&amp;width=4"";
        encrypt(key, data);
    }

    private static void encrypt(String key, String data) throws InvalidCipherTextException {
        byte[] givenKey = key.getBytes(Charset.forName(""ASCII""));
        final int keysize = 256;
        byte[] keyData = new byte[keysize / Byte.SIZE];
        System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
        KeyParameter keyParameter = new KeyParameter(keyData);
        BlockCipher rijndael = new RijndaelEngine(256);
        ZeroBytePadding c = new ZeroBytePadding();
        PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);
        pbbc.init(true, keyParameter);
        byte[] plaintext = data.getBytes(Charset.forName(""UTF8""));
        byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
        int offset = 0;
        offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
        offset += pbbc.doFinal(ciphertext, offset);
        System.out.println(""Encrypted: "" + Base64.encodeBase64String(ciphertext));
    }
}
</code></pre>

<p>This prints out the following:</p>

<pre><code>Encrypted: BUMVdaCQoce//aQWEsMgSHNRsWVPvi02ljCtF1PUfEA8Wm0tTZ6EUBEGsAiTOSINwiWikaoGm5jyBRaajHgtgj4y/7R8t5KkxEwM5H9iU/X56c8H65p3pV2P7wNayLiu5eUcLJBXb+siqCCi2VFETgGOMC8o9zjXPQ0oNCYYy5+tT2NGxSGebjM7XMIOAkIKCKvSbF+lUdxPRS1vs5ILuvzx9LP4+461ZYGYmmDKX35qPbCnsx8xaYkXnhAO8W1ddm1ylcanyAFWb2hk6UUmS7SGpSmJMAVwyUDT2uFxaizL4Z6p+KeBRgjPW2i9b5gC/MpjphJO4IKhTqKfHwziinYQ6FZOtDKtD7JC8om1kINpaMIZEHLXHEHF/iuqRbaFcH+M1Qph4Uu95d0eJ0x1A2rs2zRdlWVR72RHVIWez0w=
</code></pre>
"
30429112,30431207,"<pre><code>import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.DESKeySpec;
import android.util.Base64;

public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}
</code></pre>

<p>You can use it like this:</p>

<pre><code>private SimpleCrypto simpleCrypto = new SimpleCrypto();

String MasterPassword = ""qssfFs32fFwada"";

String encryptedText = simpleCrypto.encrypt(MasterPassword, ""Hello World"");
Log.i(encryptedText, encryptedText);

String decryptedText = decrypt(MasterPassword, encryptedText);
Log.i(decryptedText, decryptedText);
</code></pre>

<p>Of course you have to change the ""Master Password"" with something else and save it to string.xml</p>
"
38477845,38492575,"<p>Java only approach (look ma, no libraries):</p>

<pre><code>package nl.owlstead.stackoverflow;

import java.io.File;
import java.math.BigInteger;
import java.nio.file.Files;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class LoadRSAKeyFromText {

    public static void main(String[] args) throws Exception {
        // parse the lines to find the modulus n and public exponent e
        List&lt;String&gt; all = Files.readAllLines(new File(args[0]).toPath());
        String nString = null, eString = null;
        for (String line : all) {
            Pattern nPattern = Pattern.compile(""\""n\""\\s*:\\s*\""(.*?)\"",?"");
            Matcher nMatcher = nPattern.matcher(line);
            if (nMatcher.matches()) {
                nString = nMatcher.group(1).replaceAll(""\\s+"", """");
            }

            Pattern ePattern = Pattern.compile(""\""e\""\\s*:\\s*\""(.*?)\"",?"");
            Matcher eMatcher = ePattern.matcher(line);
            if (eMatcher.matches()) {
                eString = eMatcher.group(1);
            }
        }

        // decode base 64 (with _ and -, so URL safe)
        Decoder urlDecoder = Base64.getUrlDecoder();
        byte[] nData = urlDecoder.decode(nString);
        byte[] eData = urlDecoder.decode(eString);

        // convert to *positive* integers
        BigInteger n = new BigInteger(1, nData);
        BigInteger e = new BigInteger(1, eData);

        // create RSA specification and convert to key
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(n, e);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        RSAPublicKey pk = (RSAPublicKey) kf.generatePublic(keySpec);
        System.out.println(pk.getAlgorithm());
    }
}
</code></pre>

<p>Java doesn't know this kind of format so you have to parse it yourself, or find a decoder. I was lazy and programmed it.</p>
"
34522859,34533032,"<p>PKCS#1 keys are almost but not completely the same as X.509 keys.</p>

<p>The following snippet will create a Java JCA compliant public key. It will then try and perform the (default) OAEP decryption.</p>

<pre><code>package nl.owlstead.stackoverflow;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.security.Signature;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.Base64.Decoder;

import javax.crypto.Cipher;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class PKCS1PublicKey {

    public static RSAPublicKey fromPKCS1Encoding(byte[] pkcs1EncodedPublicKey) {
        // --- parse public key ---
        org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pkcs1EncodedPublicKey);
        } catch (Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }
    }

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        String pkey = ""MIIBCgKCAQEA2tF2g/muNw9xKTVcIkjUMvMhygtIW49yo1PgbwqDQ/w9MSfEARtYYF6Tenfz0twaR/eI14GXmlIffflORe4eaSuMBhwQFOIKU/1+v1BV3RLqGGblvHTVaMVm49AGiqxNnh1LBbcSrC5UhMqlL/HGiku0oYsbjLzwcLc5ac6aBQVD60wWGNm1g26lRQGRbCLqxVfcWKT3AMvEQK3cEx/En7/5Vg1V8xnJraNMrO8UGnaX8LLJFzYJiSCEShh7F+pMHbf4MaBekw7Aaf5hPJtczNsR137R92Be3OP4idI5NLmTV+Pi1DWlxhjEhswKH88SP+gsW31gS7B/ddECUqewQwIDAQAB"";
        Decoder decoder = Base64.getDecoder();
        byte[] dpkey = decoder.decode(pkey);
        RSAPublicKey publicKey = fromPKCS1Encoding(dpkey);

        String plainData = ""Hi I m here"";
        String data = ""aP0nuYYA1hE5odsCkR/DcdRbBvO2Z8IOlqXf/bKZJiG8HELIop90Vno1dKC1qyHEAOXy0gtH7GtJamzoBjDZmHPT6eto9EZP/xE7xZ8L05kjp0z2thLqO7on4C6DrG++TK1j+E3T7V0UeU874WIB0AEVzu1XUKFW6aeuU67a/gdn8N2n7N/WXtlyNSVZXg8f4PeUhGvFJrhINZT7BuMMZj1gZs4wMJPAICwfvVeg02RPH0N3Ybf2iVgRuZlmtQXGTyBlCxe9ybdHzuQM6nXghpLNmaOzCypb+yVs3Da7E0b3/fKQ7JqPSquWex2ERZbIMSTC6oCzc1rOF6iKVAd92Q=="";
        byte[] ciphertext = decoder.decode(data);

        // this will fail of course if the ""signature"" was generated using OAEP - use PSS signatures instead (see comments below)
        verifyBC(publicKey, plainData, ciphertext);
        System.out.flush();
        decryptBC(publicKey, plainData, ciphertext);
        System.out.flush();
        decryptSun(publicKey, plainData, ciphertext);
        System.out.flush();
    }

    private static void decryptBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""BC"");
        // this *should* fail
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }

    private static void decryptSun(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""SunJCE"");
        // this fails beautifully
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }

    private static void verifyBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        // what should work (for PKCS#1 v1.5 signatures), requires Bouncy Castle provider
        Signature sig = Signature.getInstance( ""SHA256withRSAandMGF1"");
        sig.initVerify(publicKey);
        sig.update(plainData.getBytes(UTF_8));
        System.out.println(sig.verify(ciphertext));
    }
}
</code></pre>

<p>The SunJCE implementation of OAEP will fail because it will not accept the public key for signature verification:</p>

<blockquote>
  <p>OAEP cannot be used to sign or verify signatures</p>
</blockquote>

<p>Now that has to be one of the most clear and informative exceptions I've met in a cryptography API. You can also use the Bouncy Castle provider and this one will ""decrypt"" the hash value. That's however not how OAEP should be used, you should be using PSS to verify signatures.</p>

<p>You should be using the PHP RSA <a href=""http://phpseclib.sourceforge.net/rsa/examples.html#sign,sign1"" rel=""nofollow""><code>sign</code></a> method instead, using <code>setHash</code> to setup SHA-256.</p>
"
31915617,39615507,"<p>If you are looking for a java program to encrypt data with public key and decrypt it with private key then here is the code (using RSA algorithm),</p>

<pre><code>import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.Cipher;

/**
 * @author visruthcv
 *
 */
public class CryptographyUtil {

    private static final String ALGORITHM = ""RSA"";

    public static byte[] encrypt(byte[] publicKey, byte[] inputData)
            throws Exception {

        PublicKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePublic(new X509EncodedKeySpec(publicKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);

        byte[] encryptedBytes = cipher.doFinal(inputData);

        return encryptedBytes;
    }

    public static byte[] decrypt(byte[] privateKey, byte[] inputData)
            throws Exception {

        PrivateKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePrivate(new PKCS8EncodedKeySpec(privateKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, key);

        byte[] decryptedBytes = cipher.doFinal(inputData);

        return decryptedBytes;
    }

    public static KeyPair generateKeyPair()
            throws NoSuchAlgorithmException, NoSuchProviderException {

        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM);

        SecureRandom random = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");

        // 512 is keysize
        keyGen.initialize(512, random);

        KeyPair generateKeyPair = keyGen.generateKeyPair();
        return generateKeyPair;
    }

    public static void main(String[] args) throws Exception {

        KeyPair generateKeyPair = generateKeyPair();

        byte[] publicKey = generateKeyPair.getPublic().getEncoded();
        byte[] privateKey = generateKeyPair.getPrivate().getEncoded();

        byte[] encryptedData = encrypt(publicKey,
                ""hi this is Visruth here"".getBytes());

        byte[] decryptedData = decrypt(privateKey, encryptedData);

        System.out.println(new String(decryptedData));

    }

}
</code></pre>
"
44234719,44251884,"<p>A working version can be found - <a href=""https://github.com/chaudhuri-ab/CrossPlatformCiphers"" rel=""noreferrer"">https://github.com/chaudhuri-ab/CrossPlatformCiphers</a></p>

<p>Some things to keep in mind is the that if you do not specify OPENSSL_RAW_DATA in PHP the data will be encrypted as base64. That was throwing me off.</p>

<p>PHP:</p>

<pre><code>class PHP_AES_Cipher {

    private static $OPENSSL_CIPHER_NAME = ""aes-128-cbc""; //Name of OpenSSL Cipher 
    private static $CIPHER_KEY_LEN = 16; //128 bits

    /**
     * Encrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * @param type $key - key to use should be 16 bytes long (128 bits)
     * @param type $iv - initialization vector
     * @param type $data - data to encrypt
     * @return encrypted data in base64 encoding with iv attached at end after a :
     */

    static function encrypt($key, $iv, $data) {
        if (strlen($key) &lt; PHP_AES_Cipher::$CIPHER_KEY_LEN) {
            $key = str_pad(""$key"", PHP_AES_Cipher::$CIPHER_KEY_LEN, ""0""); //0 pad to len 16
        } else if (strlen($key) &gt; PHP_AES_Cipher::$CIPHER_KEY_LEN) {
            $key = substr($str, 0, PHP_AES_Cipher::$CIPHER_KEY_LEN); //truncate to 16 bytes
        }

        $encodedEncryptedData = base64_encode(openssl_encrypt($data, PHP_AES_Cipher::$OPENSSL_CIPHER_NAME, $key, OPENSSL_RAW_DATA, $iv));
        $encodedIV = base64_encode($iv);
        $encryptedPayload = $encodedEncryptedData."":"".$encodedIV;

        return $encryptedPayload;

    }

    /**
     * Decrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * @param type $key - key to use should be 16 bytes long (128 bits)
     * @param type $data - data to be decrypted in base64 encoding with iv attached at the end after a :
     * @return decrypted data
     */
    static function decrypt($key, $data) {
        if (strlen($key) &lt; PHP_AES_Cipher::$CIPHER_KEY_LEN) {
            $key = str_pad(""$key"", PHP_AES_Cipher::$CIPHER_KEY_LEN, ""0""); //0 pad to len 16
        } else if (strlen($key) &gt; PHP_AES_Cipher::$CIPHER_KEY_LEN) {
            $key = substr($str, 0, PHP_AES_Cipher::$CIPHER_KEY_LEN); //truncate to 16 bytes
        }

        $parts = explode(':', $data); //Separate Encrypted data from iv.
        $decryptedData = openssl_decrypt(base64_decode($parts[0]), PHP_AES_Cipher::$OPENSSL_CIPHER_NAME, $key, OPENSSL_RAW_DATA, base64_decode($parts[1]));

        return $decryptedData;
    }

}
</code></pre>

<p>Java:</p>

<pre><code>package ciphers;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.util.Base64;

public class Java_AES_Cipher {

    private static String CIPHER_NAME = ""AES/CBC/PKCS5PADDING"";
    private static int CIPHER_KEY_LEN = 16; //128 bits

    /**
     * Encrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * 
     * @param key  - key to use should be 16 bytes long (128 bits)
     * @param iv - initialization vector
     * @param data - data to encrypt
     * @return encryptedData data in base64 encoding with iv attached at end after a :
     */
    public static String encrypt(String key, String iv, String data) {
        try {
            if (key.length() &lt; Java_AES_Cipher.CIPHER_KEY_LEN) {
                int numPad = Java_AES_Cipher.CIPHER_KEY_LEN - key.length();

                for(int i = 0; i &lt; numPad; i++){
                    key += ""0""; //0 pad to len 16 bytes
                }

            } else if (key.length() &gt; Java_AES_Cipher.CIPHER_KEY_LEN) {
                key = key.substring(0, CIPHER_KEY_LEN); //truncate to 16 bytes
            }


            IvParameterSpec initVector = new IvParameterSpec(iv.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, initVector);

            byte[] encryptedData = cipher.doFinal((data.getBytes()));

            String base64_EncryptedData = Base64.getEncoder().encodeToString(encryptedData);
            String base64_IV = Base64.getEncoder().encodeToString(iv.getBytes(""UTF-8""));

            return base64_EncryptedData + "":"" + base64_IV;

        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

    /**
     * Decrypt data using AES Cipher (CBC) with 128 bit key
     * 
     * @param key - key to use should be 16 bytes long (128 bits)
     * @param data - encrypted data with iv at the end separate by :
     * @return decrypted data string
     */

    public static String decrypt(String key, String data) {
        try {

            String[] parts = data.split("":"");

            IvParameterSpec iv = new IvParameterSpec(Base64.getDecoder().decode(parts[1]));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] decodedEncryptedData = Base64.getDecoder().decode(parts[0]);

            byte[] original = cipher.doFinal(decodedEncryptedData);

            return new String(original);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return null;
    }

}
</code></pre>
"
43960761,43965528,"<p>There is a bit of a problem here: Java's focus is almost entirely on TLS and the cryptography required to implement TLS. For TLS a private key and a certificate is required. So you get into a situation where you:</p>

<ol>
<li>have to generate a (bogus) self signed certificate to go with your public key or;</li>
<li>have to find another way of storing the private key without a certificate.</li>
</ol>

<p>However, with (2.) you quickly get a method that isn't very compatible. If you want to go that way, you could create a PKCS#8 encrypted private key that is encrypted using PBE / CBC.</p>

<p>So here's some code to create a self signed certificate and use that to store the key. Note the expiration date, you could set it to 100 years to be on the safe side (or you could actually do some key management).</p>

<pre><code>import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStore.Entry;
import java.security.KeyStore.PrivateKeyEntry;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.Provider;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Security;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Calendar;
import java.util.Date;

import org.bouncycastle.asn1.x500.X500Name;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.cert.X509CertificateHolder;
import org.bouncycastle.cert.X509v3CertificateBuilder;
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.OperatorCreationException;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;

public class StoreKeyPair {
    public static KeyPair generateKeyPair() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(""RSA"");
        generator.initialize(2048, new SecureRandom());
        KeyPair pair = generator.generateKeyPair();

        return pair;
    }

    public static Certificate selfSign(KeyPair keyPair, String subjectDN)
            throws OperatorCreationException, CertificateException, IOException
    {
        Provider bcProvider = new BouncyCastleProvider();
        Security.addProvider(bcProvider);

        long now = System.currentTimeMillis();
        Date startDate = new Date(now);

        X500Name dnName = new X500Name(subjectDN);

        // Using the current timestamp as the certificate serial number
        BigInteger certSerialNumber = new BigInteger(Long.toString(now));

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
        // 1 Yr validity
        calendar.add(Calendar.YEAR, 1);

        Date endDate = calendar.getTime();

        // Use appropriate signature algorithm based on your keyPair algorithm.
        String signatureAlgorithm = ""SHA256WithRSA"";

        SubjectPublicKeyInfo subjectPublicKeyInfo = SubjectPublicKeyInfo.getInstance(keyPair
                .getPublic().getEncoded());

        X509v3CertificateBuilder certificateBuilder = new X509v3CertificateBuilder(dnName,
                certSerialNumber, startDate, endDate, dnName, subjectPublicKeyInfo);

        ContentSigner contentSigner = new JcaContentSignerBuilder(signatureAlgorithm).setProvider(
                bcProvider).build(keyPair.getPrivate());

        X509CertificateHolder certificateHolder = certificateBuilder.build(contentSigner);

        Certificate selfSignedCert = new JcaX509CertificateConverter()
                .getCertificate(certificateHolder);

        return selfSignedCert;
    }

    public static void main(String[] args) throws Exception {
        KeyPair generatedKeyPair = generateKeyPair();

        String filename = ""test_gen_self_signed.pkcs12"";
        char[] password = ""test"".toCharArray();

        storeToPKCS12(filename, password, generatedKeyPair);

        KeyPair retrievedKeyPair = loadFromPKCS12(filename, password);

        // you can validate by generating a signature and verifying it or by
        // comparing the moduli by first casting to RSAPublicKey, e.g.:

        RSAPublicKey pubKey = (RSAPublicKey) generatedKeyPair.getPublic();
        RSAPrivateKey privKey = (RSAPrivateKey) retrievedKeyPair.getPrivate();
        System.out.println(pubKey.getModulus().equals(privKey.getModulus()));
    }

    private static KeyPair loadFromPKCS12(String filename, char[] password)
            throws KeyStoreException, NoSuchAlgorithmException, CertificateException,
            FileNotFoundException, IOException, UnrecoverableEntryException {
        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");

        try (FileInputStream fis = new FileInputStream(filename);) {
            pkcs12KeyStore.load(fis, password);
        }

        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(password);
        Entry entry = pkcs12KeyStore.getEntry(""owlstead"", param);
        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;
        PublicKey publicKey = privKeyEntry.getCertificate().getPublicKey();
        PrivateKey privateKey = privKeyEntry.getPrivateKey();
        return new KeyPair(publicKey, privateKey);
    }

    private static void storeToPKCS12(
            String filename, char[] password,
            KeyPair generatedKeyPair) throws KeyStoreException, IOException,
            NoSuchAlgorithmException, CertificateException, FileNotFoundException,
            OperatorCreationException {

        Certificate selfSignedCertificate = selfSign(generatedKeyPair, ""CN=owlstead"");

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        pkcs12KeyStore.load(null, null);

        KeyStore.Entry entry = new PrivateKeyEntry(generatedKeyPair.getPrivate(),
                new Certificate[] { selfSignedCertificate });
        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(password);

        pkcs12KeyStore.setEntry(""owlstead"", entry, param);

        try (FileOutputStream fos = new FileOutputStream(filename)) {
            pkcs12KeyStore.store(fos, password);
        }
    }
}
</code></pre>

<p>Note that I was too lazy to properly handle the exceptions.</p>

<p>This code uses a slightly altered version of <a href=""https://stackoverflow.com/a/43918337/589259"">this answer</a>, see my comments for why I changed the code.</p>

<hr>

<p>The public key can of course be stored separately as well. Just call <code>getEncoded</code> and store the resulting SubjectPublicKeyInfo structure.</p>
"
41934099,41934100,"<p><strong>TL,DR</strong>: OpenJDK 8 package from Alpine doesn't support ciphers that use elliptic curve, like <code>ECDHE</code>. Use <code>-Dcom.sun.net.ssl.enableECC=false</code> on Java options to kindly ask OpenJDK to not use such ciphers.</p>

<p>This nice Atlassian <a href=""https://confluence.atlassian.com/stashkb/list-ciphers-used-by-jvm-679609085.html"" rel=""noreferrer"">paper</a> describes how to list all default and available ciphers from JVM using the following code:</p>

<pre><code>import java.util.Iterator;
import java.util.Map;
import java.util.TreeMap;
import javax.net.ssl.SSLServerSocketFactory;

public class Ciphers
{
    public static void main(String[] args)
        throws Exception
    {
        SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();

        String[] defaultCiphers = ssf.getDefaultCipherSuites();
        String[] availableCiphers = ssf.getSupportedCipherSuites();

        TreeMap ciphers = new TreeMap();

        for(int i=0; i&lt;availableCiphers.length; ++i )
            ciphers.put(availableCiphers[i], Boolean.FALSE);

        for(int i=0; i&lt;defaultCiphers.length; ++i )
            ciphers.put(defaultCiphers[i], Boolean.TRUE);

        System.out.println(""Default\tCipher"");
        for(Iterator i = ciphers.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry cipher=(Map.Entry)i.next();

            if(Boolean.TRUE.equals(cipher.getValue()))
                System.out.print('*');
            else
                System.out.print(' ');

            System.out.print('\t');
            System.out.println(cipher.getKey());
        }
    }
}
</code></pre>

<p>Running this code on OpenJDK 8 from Alpine 3.5 doesn't list any <code>ECDHE</code> cipher, on the other side this same code lists several such ciphers from OpenJDK 8 installed on a CentOS 7 box.</p>

<p>For some reason ciphers that use elliptic curve are sent from the client to the server as available ciphers on a Wildfly application. Outside Wildfly - eg <code>java SomeClass</code> or <code>java -jar some.jar</code> these ciphers aren't send and the communication works. This behavior can be observed adding <code>-Djavax.net.debug=all</code> on Java options.</p>
"
41162523,41162646,"<p>To get your hashcode:</p>

<pre><code>public static byte[] sha1(byte[] data)
Calculates the SHA-1 digest and returns the value as a byte[].
Parameters:
data - Data to digest
Returns:
SHA-1 digest
</code></pre>

<p>Found these at
<a href=""https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html#sha1Hex(java.lang.String)"" rel=""nofollow noreferrer"">https://commons.apache.org/proper/commons-codec/apidocs/org/apache/commons/codec/digest/DigestUtils.html#sha1Hex(java.lang.String)</a></p>

<p>This helps your process.</p>

<pre><code>import java.io.UnsupportedEncodingException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.apache.commons.codec.binary.Base64;
import org.bouncycastle.jcajce.provider.asymmetric.rsa.DigestSignatureSpi.SHA1;

public class SHA1_test {

    public static String sha1(String s, String keyString)
            throws UnsupportedEncodingException, NoSuchAlgorithmException,
            InvalidKeyException {

        SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""),
                ""HmacSHA1"");
        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(key);

        byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));

        return new String(Base64.encodeBase64(bytes));

    }

    public static void main(String[] args) throws InvalidKeyException,
            UnsupportedEncodingException, NoSuchAlgorithmException {
        Boolean validate = false;
        String code = sha1(""admin"", ""123456"");
        String your_user_inputString = ""testpassword"";

        if (code.equals(sha1(your_user_inputString, ""123456""))) {
            System.out.println(""Correct"");
        } else {
            System.out.println(""Bad password"");
        }

    }

}
</code></pre>

<p>This works!!!</p>
"
28042594,47128415,"<p>Check this complete and working code to verify <strong>signature</strong> after signing some text/data using digest <strong>SHA256</strong>with<strong>RSA</strong>:</p>

<pre><code>/* verifyRSAsha256.java */
import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.PublicKey;
import java.security.Signature;
import java.security.spec.X509EncodedKeySpec;
import javax.xml.bind.DatatypeConverter;

/*
Compile:
clear &amp;&amp; javac verifyRSAsha256.java &amp;&amp; java verifyRSAsha256

Create private key:
openssl genrsa -des3 -out encrypted.pem 2048 &amp;&amp; openssl rsa -in encrypted.pem -out private.pem -outform PEM &amp;&amp; openssl rsa -in private.pem -pubout &gt; public.pem

Create signature:
/bin/echo -n ""some text that you want to be trusted"" &gt; data.txt
openssl dgst -sha256 -sign private.pem data.txt &gt; signature.tmp
base64 signature.tmp

Verify signature:
openssl dgst -sha256 -verify public.pem -signature signature.tmp data.txt
*/

public class verifyRSAsha256 {

    public static void main(String args[]){
        String publicKey = 
        //  ""-----BEGIN PUBLIC KEY-----""+
            ""MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwns0JWYgEshlpLYsZQFc""+
            ""d5iVSqIHDO0zISLlO1aK4bbbosSvRE81+inKrG5mlnkIrv0+mJ/qTLY1RdBAVAe4""+
            ""GPLTpHmLJhEtq7stydm2cCTEPRwfJNjoHqATDHEm1KLVGA8k0hztfMr8fLChE3/K""+
            ""n2MHxzs7qhMLyBdPqbVC9RNja3i+Nl814xPTSXJ50zdJMLC56VtIU0xjqNjXN8iQ""+
            ""pLZ2EfcP55nZ/venD01yxfsUn4sQLFTAlXqygA10fdDv9y0eZvgaGGSb4MuPT7yD""+
            ""BfgNEU3tl4nRdSzPNkCkCmkuaa/pqZ5uw+G0HBwaQlHDwsnIcwE/xo6aHpt4xF4W""+
            ""/QIDAQAB"";
        //  ""-----END PUBLIC KEY-----"";

        byte[] signature, data;

        // the signature is a binary data and I encoded it with base64, so the signature must be decoded from base64 to binary again
        signature = DatatypeConverter.parseBase64Binary(""Yy9CdQDfdYWwZkSu2SZgoFABHk5Bd3tzYvX73QR+GDCWpUsWrO5CXRF+j3dBz+bq1SRQ+1c1hdez5mMeE1587s4Mos8EsT1sqNemu4l4535P+jYicwG1m2MAesquAHhIIAyY9iGID576ehX0/34rCCeGuVZablpL+2ki6cEwxPVlH7xtWNIc1AdxivHjkWorkWC1LrbfcNdbZhUrNuz7DZsxHP2sr+2TQdD4L9CA2bgpj6HeQt+MTfCf2PKSdVoLFdwnM8638jHL6MVcEJxeIow/YUDZGEAyR743RdRk4CGU1bJ7er9M1Q4hFfYWGOBsLBok2XXUJcchLgWET1eKdA=="");

        // the signature length have to be 256 bytes
        System.out.print(""Signature length 256 = "");
        System.out.println(signature.length);

        // the data used the generate the signature
        data = ""some text that you want to be trusted"".getBytes();

        // verify if signature is ok
        try {System.out.println(verify(data,signature,publicKey));}catch(GeneralSecurityException e){e.printStackTrace();}

        // if any byte of data changes (ex: change last byte from d to D)
        data = ""some text that you want to be trusteD"".getBytes();

        // the signature doesn't math and method verify will fail
        try {System.out.println(verify(data,signature,publicKey));}catch(GeneralSecurityException e){e.printStackTrace();}

    }

    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }
}
</code></pre>

<p>You can create a private and public key using openssl command line tool:</p>

<pre><code>openssl genrsa -des3 -out encrypted.pem 2048 
openssl rsa -in encrypted.pem -out private.pem -outform PEM
openssl rsa -in private.pem -pubout &gt; public.pem
</code></pre>

<p>You can create one signature with your private key using openssl command line tool:</p>

<pre><code>/bin/echo -n ""some text that you want to be trusted"" &gt; data.txt
openssl dgst -sha256 -sign private.pem data.txt &gt; signature.tmp
</code></pre>

<p>You can verify if the signature is correct using openssl command line tool:</p>

<pre><code>openssl dgst -sha256 -verify public.pem -signature signature.tmp data.txt
</code></pre>
"
46988680,46988906,"<p>You can use the code given by dealforest on github from the following link: 
<a href=""https://gist.github.com/dealforest/1949873#file-aes256cipher-java"" rel=""nofollow noreferrer"">AES256 encrypt android</a></p>

<p>I put the code below if you want to get it more easily ;)</p>

<pre><code>

    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;

    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.InvalidAlgorithmParameterException;
    import java.security.spec.AlgorithmParameterSpec;

    public class AES256Cipher {

        public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                    NoSuchAlgorithmException,
                    NoSuchPaddingException,
                    InvalidKeyException,
                    InvalidAlgorithmParameterException,
                    IllegalBlockSizeException,
                    BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = null;
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);
        }

        public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                NoSuchAlgorithmException,
                NoSuchPaddingException,
                InvalidKeyException,
                InvalidAlgorithmParameterException,
                IllegalBlockSizeException,
                BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);
        }
    }

</code></pre>

<p>And here's how to use the class:</p>

<pre><code>

    String key = ""e8ffc7e56311679f12b6fc91aa77a5eb"";
    byte[] keyBytes = key.getBytes(""UTF-8"");
    byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

    String plainText;
    byte[] cipherData;
    String base64Text;

    //############## Request(crypt) ##############
    plainText  = ""crypt text!!"";
    cipherData = AES256Cipher.encrypt(ivBytes, keyBytes, plainText.getBytes(""UTF-8""));
    base64Text = Base64.encodeToString(cipherData, Base64.DEFAULT);
    Log.d(""encrypt"", base64Text);

    //############## Response(decrypt) ##############
    base64Text = ""72XrlydqnUzVrDfDE7ncnQ=="";
    cipherData = AES256Cipher.decrypt(ivBytes, keyBytes, Base64.decode(base64Text.getBytes(""UTF-8""), Base64.DEFAULT));
    plainText = new String(cipherData, ""UTF-8"");
    Log.d(""dcrypt"", plainText);

</code></pre>

<p>I haven't tested it, but I think the code still works.</p>
"
46984264,46984366,"<p>if you know the secretkey then you can decrypt the data  see following code for encryption and decryption of AES-256 . the code is written in JAVA 
check this link <a href=""https://stackoverflow.com/questions/28622438/aes-256-password-based-encryption-decryption-in-java"">AES-256 Password Based Encryption/Decryption in Java</a></p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>import java.security.AlgorithmParameters;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.xml.bind.DatatypeConverter;

public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}</code></pre>
</div>
</div>
</p>
"
